[toc]

# 1.2

## [390. 消除游戏](https://leetcode-cn.com/problems/elimination-game/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/390.png)

这个题，刚看到的时候想到了约瑟夫环问题（可是这个问题的解法已经记不清了...）

其实是一个找规律的题

我们知道，按照这个规律删除，最后只会剩下1个数字，就是我们要返回的，所以其实我们只需要知道**每一轮开头的元素**（或者结尾的元素），因为到了最后一轮，就只剩下一个元素了

因为隔一个删除一个，所以每次剩下的数可以构成等差数列，假设是第k轮删除，那么这个等差数列的公差$d = 2 ^{k - 1}$（第一轮公差为1，第二轮公差为2，第三轮公差为4...）

根据题目删除的规律，每一轮剩下的元素个数$count_k = \lfloor\frac{count_{k - 1}}{2}\rfloor$

现在考虑**每一轮开头的元素**：

如果是奇数轮次，即这些轮次会从左开始向右删除，那么对应下一轮次的序列开头的元素：$num_{k + 1} = num_{k} + d_k$

如果是偶数轮次，即这些轮次会从右向左删除，如果当前序列长度为偶数的话，下一轮序列的开头保持不变，而序列长度为奇数的话，有：$num_{k + 1} = num_{k} + d_k$

```java
class Solution {
    public int lastRemaining(int n) {
        if (n == 1) return 1;
        int begin = 1;
        int step = 1;
        int len = n;
        int k = 1;
        while (len > 1) {
            if ((k & 1) == 1) {
                begin += step;
            }else if ((len & 1) == 1) {
                begin += step;
            }
            step *= 2;
            k++;  
            len /= 2;
        }
        return begin;
    }
}
```

## 约瑟夫环问题

其实对应的是：

[剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/%E5%89%91%E6%8C%8762.png)

我觉得就递推公式就挺好的

假设$n = 10, m = 3$：考虑$f(10,3)$为最后的答案

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF_1.png)

我们从剩下的序列中获得答案，显然和$f(9,3)$并不完全相等，但是二者是具有相似的地方的，都是从9个中，每3个删除一个，所以其实是有共通的点的

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF_2.png)

我们把删除过一次的$f(10,3)$整理一下，变成了取模的形式（第二行），通过拆分，将其化成和$f(9,3)$类似的形式（第三行）

相当于对于$f(9,3)$的结果加3并和10取模

所以：$f(10,3) = (f(9,3) + 3) \mod 10$

这个其实就是递推公式：$f(n, m) = (f(n - 1,m) + m) \mod n$

这个公式的baseCase是当$n = 1$的时候，显然此时$f(1, m) = 0$

写成递归的形式：

```java
class Solution {
    public int lastRemaining(int n, int m) {
        if (n == 1) return 0;
        return (lastRemaining(n - 1, m) + m) % n;
    }
}
```

写成迭代的形式：

```java
class Solution {
    public int lastRemaining(int n, int m) {
        if (n == 1) return 0;
        int val = 0;
        int count = 1;
        while (count < n) {
            val = (val + m) % (count + 1);
            count++;
        }
        return val;
    }
}
```

# 1.4

## [913-猫和老鼠](https://leetcode-cn.com/problems/cat-and-mouse/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/913.png)

这个题官解讲的挺好的

这种属于是博弈，对于每个玩家而言，具有获胜，失败，和局的情况。其实在给定了初始条件后，这句每个玩家的状态都是已知的了，题目要求我们求的也就是这个状态（获胜，失败或平局）

下面的来自于[官解](https://leetcode-cn.com/problems/cat-and-mouse/solution/mao-he-lao-shu-by-leetcode-solution-444x/)，博弈中的三个状态：必胜状态、必败状态、必和状态

对于某一个特定的状态，必然时上面三种状态之一：所有玩家都向着对自己最有利的方向进行游戏

如果当前状态可以转移到一个必败状态，则对于下一个玩家而言，下一个状态是必败状态，而当前状态对于当前玩家而言是必胜状态

如果当前状态能转移的所有状态都是必胜状态，则对于下一个玩家而言，下一个状态是必胜状态，而当前状态对于当前玩家而言是必败状态

如果当前状态可以转移的状态中没有一个必败状态，但是存在一个必和状态，那么对于下一玩家而言，下一个状态是必和状态，而对于当前玩家是必和状态

所以总结一下：**对于任意一个当前状态玩家，他首先会向着必败状态转移（使得下一个玩家是必败状态，那么自己就是必胜状态），如果没有必败状态，会向着必和状态转移，如果没有必和状态，那么当前玩家的当前状态是必败状态**

其实根据上面的分析也能知道，博弈问题，涉及到状态的转移，适合使用动态规划求解：

这里定义：`dp[mouse][cat][turns]`为老鼠位于`mouse`节点，猫位于`cat`节点，当前进行了`turns`次游戏后的状态

* 首先，如果当前`mouse = 0`，说明老鼠到洞了，此时状态是老鼠赢

* 如果当前`cat = mouse && cat != 0`，说明此时猫抓到老鼠了，此时状态是猫赢

上面这两种情况是base case

要注意的是如果`turns = 2n`，说明此时状态为必和状态，其中n是图中节点的个数；这是因为图中一共就n个节点，老鼠初始位于节点1，希望到达节点0，就算都走一遍，也只需要走n - 1次；对于猫同理，他们都走了n - 1次；当`turn = 2n`时，说明老鼠至少重复走过了一个节点（对于猫也同理），所以此时为平局

实际中，我们使用的是自顶向下的dp，其实相当于dfs和记忆化搜索，所以具体的，将dp更改为buffer作为缓存

```java
class Solution {
    private static final int DRAW = 0;
    private static final int MOUSE_WIN = 1;
    private static final int CAT_WIN = 2;
    private int[][] graph;
    private int[][][] buffer;
    private int n;
    public int catMouseGame(int[][] graph) {
        this.graph = graph;
        this.n = graph.length;
        this.buffer = new int[n][n][2 * n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                Arrays.fill(buffer[i][j], -1);
            }
        }
        return get(1, 2, 0);
    }

    private int get(int mouse, int cat, int turns) {
        if (turns >= 2 * n) {
            return DRAW;
        }
        if (buffer[mouse][cat][turns] != -1) {
            return buffer[mouse][cat][turns];
        }
        if (mouse == cat) {
            buffer[mouse][cat][turns] = CAT_WIN;
            return buffer[mouse][cat][turns];
        }
        if (mouse == 0) {
            buffer[mouse][cat][turns] = MOUSE_WIN;
            return buffer[mouse][cat][turns];
        }
        
        int rst = -1;
        //如果turns为偶数，说明此时是老鼠应该移动
        if ((turns & 1) == 0) {
            /*
            老鼠移动会向着老鼠赢，或者平局的方向
            如果它遍历自己所有的邻节点都不能找到一个至少平局的状态
            那么当前状态是猫赢了，所以rst的默认值是猫必胜
            */
            rst = CAT_WIN;
            for (int next : graph[mouse]) {
                int state = get(next, cat, turns + 1);
                if (state != CAT_WIN) {
                    rst = state;
                    //只要找到一个邻节点的状态是老鼠必赢，那么当前的老鼠也是必赢
                    if (rst == MOUSE_WIN) {
                        break;
                    }
                }
            }
        }else {
            //猫的分析和老鼠类似
            rst = MOUSE_WIN;
            for (int next : graph[cat]) {
                if (next == 0) continue;
                int state = get(mouse, next, turns + 1);
                if (state != MOUSE_WIN) {
                    rst = state;
                    if (rst == CAT_WIN) {
                        break;
                    }
                }
            }    
        }
        buffer[mouse][cat][turns] = rst;
        return buffer[mouse][cat][turns];

    }
}
```

# 1.6

## [71-简化路径](https://leetcode-cn.com/problems/simplify-path/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/71.png)

直接通过`/`进行字符串分割，并使用栈存储路径

分割的字符串分四种情况：

* 字符串为空：这种不知道是怎么产生的，反正就是有空字符串
* 字符串为`.`：这种对应的其实是原来字符串中的：`/.`表示当前的路径，和上面一样直接跳过就好
* 字符串为`..`：这种对应的是返回到上一级目录`/..`，因为要返回上一级路径，所以此时弹栈
* 其他：这种就入栈就好

```java
class Solution {
    public String simplifyPath(String path) {
        String[] dir = path.split("/");
        int n = dir.length;
        Deque<String> deque = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            if ("".equals(dir[i]) || ".".equals(dir[i])) continue;
            if ("..".equals(dir[i])) {
                if (!deque.isEmpty()) {
                    deque.pollLast();
                } 
            }else {
                deque.offerLast(dir[i]);
            }
        }
        StringBuilder builder = new StringBuilder();
        while (!deque.isEmpty()) {
            builder.append("/").append(deque.pollFirst());
        }
        if (builder.length() == 0) builder.append("/");
        return builder.toString();
    }
}
```

# 1.10

## [306-累加数](https://leetcode-cn.com/problems/additive-number/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/306.png)

暴力搜索，首先要明确的是，如果我们确定了前两个数字，那么一个字符串是不是一个累加数就已经可以确定了，因为每一个数都是由前面的两个加和构造的，所以通过递推的形式可以获得所有数

关键在于确定前面的两个数字：我们怎么知道前面的两个数字长什么样呢，假如字符串中前面4位字符表示最开始的两个数字，那么一共具有3种组合方式：

* `num.substring(0, 1)`和`num.substring(1, 4)`
* `num.substring(0, 2)`和`num.substring(2, 4)`
* `num.substring(0, 3)`和`num.substring(3, 4)`

所以我们需要获取上面三种组合方式求出的和，然后将其和字符串后面的部分进行比较，如果可以匹配，说明这是一种可能的组合，然后我们根据递推确定当前字符串是不是以前两个数字为开头的组合数；如果上面三种都已经枚举过了，并且三种都不能匹配后面的数字，说明如果当前字符串是一个组合数，那么前面两个数字至少占用了前5个字符...，然后继续暴力枚举

所以现在的几个任务：

* 假设前面两个数字占用了n位，我们需要枚举出这n位所有可能的组合的和
* 如果某一种组合能够匹配后面的字符，就进行递推，递推的终点是`index == nums.length()`

```java
class Solution {
    private String num;
    private List<String> path;
    public boolean isAdditiveNumber(String num) {
        this.num = num;
        this.path = new ArrayList<>();
        int n = num.length();
        for (int i = 2; i < n; i++) {
            String[] tmpSums = sums(i - 1);
            for (int j = 0; j < tmpSums.length; j++) {
                int len = tmpSums[j].length();
                //注意如果当前组合数的长度已经大于从index到num.length()的长度了，跳过就好了，并且如果当前组合数是非法值，也要跳过
                if (len > num.length() - i || tmpSums[j].equals("-1")) continue;
                if (tmpSums[j].equals(num.substring(i, i + len))) {
                    //如果匹配了，就连续放入三个数
                    path.add(num.substring(0, j + 1));
                    path.add(num.substring(j + 1, i));
                    path.add(tmpSums[j]);
                    //如果递推成功，就返回true，如果失败需要清空path
                    if (isAdditive(i + len)) {
                        return true;
                    }else {
                        path = new ArrayList<>();
                    }
                }
            }
        }
        return false;
    }
	//递推
    public boolean isAdditive(int index) {
        if (index == num.length()) return true;
        String tmpSum = getSum(path.get(path.size() - 1), path.get(path.size() - 2));
        int len = tmpSum.length();
        //同样的，需要判断当前两数和的长度是不是太长了
        if (len <= (num.length() - index) && tmpSum.equals(num.substring(index, index + len))) {
            path.add(tmpSum);
            return isAdditive(index + len);
        }else {
            return false;
        }
    }
	//这里是根据前两个字符占用的位数获取所有的组合
    public String[] sums(int index) {
        String[] rst = new String[index];
        //-1表示非法值
        Arrays.fill(rst, "-1");
        for (int i = 0; i < index; i++) {
            String num1 = num.substring(0, i + 1);
            String num2 = num.substring(i + 1, index + 1);
            //要注意的是，数字不可以有01的形式，但是允许有0，即前两个数字可以是0和0，但不能是01和01
            if ((num1.length() == 1 || num1.charAt(0) != '0') && (num2.length() == 1 || num2.charAt(0) != '0')) {
                rst[i] = getSum(num1, num2);
            }
        }
        return rst;
    }
	//通过字符串的方式进行求和，因为怕前两位数字太长导致溢出，一位一位的求和，然后最后对StringBuilder取反
    public String getSum(String num1, String num2) {
        StringBuilder builder = new StringBuilder();
        int p1 = num1.length() - 1;
        int p2 = num2.length() - 1;
        int carry = 0;
        while (p1 >= 0 && p2 >= 0) {
            int sum = num1.charAt(p1) - '0' + num2.charAt(p2) - '0' + carry;
            carry = 0;
            if (sum >= 10) {
                carry = 1;
                sum -= 10;
            } 
            builder.append(sum);
            p1--;
            p2--;
        }
        while (p1 >= 0) {
            int sum = carry + num1.charAt(p1) - '0';
            carry = 0;
            if (sum >= 10) {
                carry = 1;
                sum -= 10;
            }
            builder.append(sum);
            p1--;
        }
        while (p2 >= 0) {
            int sum = carry + num2.charAt(p2) - '0';
            carry = 0;
            if (sum >= 10) {
                carry = 1;
                sum -= 10;
            }
            builder.append(sum);
            p2--;
        }
        //注意这里要加，防止丢失了进位
        if (carry > 0) { builder.append(1);}
        return builder.reverse().toString();
    }
}
```

上面可以优化的点在于我们其实不需要维护一个list，其实就只需要知道前面两个数就好了：

```java
class Solution {
    private String num;
    private String pre1;
    private String pre2;
    public boolean isAdditiveNumber(String num) {
        this.num = num;
        int n = num.length();
        for (int i = 2; i < n; i++) {
            String[] tmpSums = sums(i - 1);
            for (int j = 0; j < tmpSums.length; j++) {
                int len = tmpSums[j].length();
                if (len > num.length() - i || tmpSums[j].equals("-1")) continue;
                if (tmpSums[j].equals(num.substring(i, i + len))) {
                    pre1 = num.substring(j + 1, i);
                    pre2 = tmpSums[j];
                    if (isAdditive(i + len)) { return true;}
                }
            }
        }
        return false;
    }

    public boolean isAdditive(int index) {
        if (index == num.length()) return true;
        String tmpSum = getSum(pre1, pre2);
        int len = tmpSum.length();
        if (len <= (num.length() - index) && tmpSum.equals(num.substring(index, index + len))) {
            pre1 = pre2;
            pre2 = tmpSum;
            return isAdditive(index + len);
        }else { return false;}
    }

    public String[] sums(int index) {
        String[] rst = new String[index];
        Arrays.fill(rst, "-1");
        for (int i = 0; i < index; i++) {
            String num1 = num.substring(0, i + 1);
            String num2 = num.substring(i + 1, index + 1);
            if ((num1.length() == 1 || num1.charAt(0) != '0') && (num2.length() == 1 || num2.charAt(0) != '0')) {
                rst[i] = getSum(num1, num2);
            }
        }
        return rst;
    }

    public String getSum(String num1, String num2) {
        StringBuilder builder = new StringBuilder();
        int p1 = num1.length() - 1;
        int p2 = num2.length() - 1;
        int carry = 0;
        while (p1 >= 0 && p2 >= 0) {
            int sum = num1.charAt(p1) - '0' + num2.charAt(p2) - '0' + carry;
            carry = 0;
            if (sum >= 10) {
                carry = 1;
                sum -= 10;
            } 
            builder.append(sum);
            p1--;
            p2--;
        }
        while (p1 >= 0) {
            int sum = carry + num1.charAt(p1) - '0';
            carry = 0;
            if (sum >= 10) {
                carry = 1;
                sum -= 10;
            }
            builder.append(sum);
            p1--;
        }
        while (p2 >= 0) {
            int sum = carry + num2.charAt(p2) - '0';
            carry = 0;
            if (sum >= 10) {
                carry = 1;
                sum -= 10;
            }
            builder.append(sum);
            p2--;
        }
        if (carry > 0) { builder.append(1);}
        return builder.reverse().toString();
    }
}
```

# 1.11

## [1036-逃离大迷宫](https://leetcode-cn.com/problems/escape-a-large-maze/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1036.png)

这个题最开始我感觉是需要判断源点和目标点之间的关系，即二者是不是都被包围了，或者都没有被包围

总之，根据它给定的`blocked`数组可以确定一个被包围的区域，需要判断的是两个点和这个区域的关系，当然，有可能并不能实现真正意义上的包围

其实不应该是这种思路的

这种图的问题，要么是BFS，要么是DFS，这道题直观上，感觉就应该用BFS，问题在于我们如果确定迭代的终点

其实根据给定的`blocked`数组中元素的个数，可以确定一个可以包围的，最大的面积，如果我们从某一点进行BFS，走过的网格个数大于这个最大的面积，就说明当前这个点在包围外，否则就在这个包围内部

上述好像给了我们一个思路，从两个点，分别进行BFS

* 如果我们迭代的时候visited集合存在交叉，说明一定可以相遇
* 如果我们走过的方块的个数都大于`blocked`数组可以确定的最大的面积，那么说明我们都在包围外部，一定可以相遇；
* 剩下的情况，迭代的时候，集合不存在交叉，并且至少一个走过的个数小于最大面积（当BFS的队列为空的时候，说明不能再走了），此时说明，至少两个点不在一个包围内部

现在的关键是确定这个最大的面积

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1036_1.png)

从上面的图中可以看出来，斜边可以包围的面积，比竖边要大

所以我们在只知道个数，求最大包围面积的时候，尽量让其为斜边

而我们知道，除了`block`数组可以作为边界外，网格边界本身就有边界的作用

所以我们可以利用网格边界自身的特性得到最大的包围面积

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1036_2.png)

这个面积就是等差数列求和：$sum = \frac{n\times(n - 1)}{2}$

下面给出一个双端BFS的解法

```java
class Solution {
    private static final int[][] DIRECTIONS = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    private static final long LIMIT = (long)1e6;
    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {
        int n = blocked.length;
        int maxNum = n * (n - 1) / 2;
        Set<Long> block = new HashSet<>();
        for (int[] position : blocked) { block.add(getIndex(position[0], position[1]));}
        Set<Long> foreVisited = new HashSet<>();
        Set<Long> backVisited = new HashSet<>();
        Queue<Long> foreQueue = new LinkedList<>();
        Queue<Long> backQueue = new LinkedList<>();
        long fore = getIndex(source[0], source[1]);
        foreQueue.offer(fore);
        foreVisited.add(fore);
        long back = getIndex(target[0], target[1]);
        backQueue.offer(back);
        backVisited.add(back);
        while (!foreQueue.isEmpty() && !backQueue.isEmpty()) {
            if (foreVisited.size() > maxNum && backVisited.size() > maxNum) return true;
            int size = foreQueue.size();
            for (int i = 0; i < size; i++) {
                int[] tmp = getPosition(foreQueue.poll());
                for (int[] direction : DIRECTIONS) {
                    int mx = direction[0] + tmp[0];
                    int my = direction[1] + tmp[1];
                    long index = getIndex(mx, my);
                    if (backVisited.contains(index)) return true;
                    if (mx >= 0 && mx < LIMIT && my >= 0 && my < LIMIT && !foreVisited.contains(index) && !block.contains(index)) {
                        foreQueue.offer(index);
                        foreVisited.add(index);
                    }
                }
            }
            size = backQueue.size();
            for (int i = 0; i < size; i++) {
                int[] tmp = getPosition(backQueue.poll());
                for (int[] direction : DIRECTIONS) {
                    int mx = direction[0] + tmp[0];
                    int my = direction[1] + tmp[1];
                    long index = getIndex(mx, my);
                    if (foreVisited.contains(index)) return true;
                    if (mx >= 0 && mx < LIMIT && my >= 0 && my < LIMIT && !backVisited.contains(index) && !block.contains(index)) {
                        backQueue.offer(index);
                        backVisited.add(index);
                    }
                }
            }
        }
        return false;
    }

    private int[] getPosition(long index) {
        return new int[]{(int)(index / LIMIT), (int)(index % LIMIT)};
    }

    private long getIndex(int x, int y) {
        return x * LIMIT + y;
    }
}
```

上面这个解法存在优化的空间，比如当其中一个方向上走过的网格数已经大于最大的数目的时候就可以不走了，只走另一个

另一种思路是从源点到终点，和从终点到源点分开判断：

```java
class Solution {
    private static final int[][] DIRECTIONS = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    private static final long LIMIT = (long)1e6;
    private int maxNum;
    private Set<Long> block;
    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {
        int n = blocked.length;
        this.maxNum = n * (n - 1) / 2;
        this.block = new HashSet<>();
        for (int[] position : blocked) { block.add(getIndex(position[0], position[1]));}
        return bfs(source, target) && bfs(target, source);
    }

    private boolean bfs(int[] source, int[] target) {
        Set<Long> visited = new HashSet<>();
        Queue<Long> queue = new LinkedList<>();
        long index = getIndex(source[0], source[1]);
        queue.offer(index);
        visited.add(index);
        while (!queue.isEmpty() && visited.size() <= maxNum) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] tmp = getPosition(queue.poll());
                for (int[] direction : DIRECTIONS) {
                    int mx = direction[0] + tmp[0];
                    int my = direction[1] + tmp[1];
                    if (mx == target[0] && my == target[1]) return true;
                    index = getIndex(mx, my);
                    if (mx >= 0 && mx < LIMIT && my >= 0 && my < LIMIT && !visited.contains(index) && !block.contains(index)) {
                        queue.offer(index);
                        visited.add(index);
                    }
                }
            }
        }
        return visited.size() > maxNum;
    }

    private int[] getPosition(long index) {
        return new int[]{(int)(index / LIMIT), (int)(index % LIMIT)};
    }

    private long getIndex(int x, int y) {
        return x * LIMIT + y;
    }
}
```

> 其实这种更好

# 1.17

今天的题是关于矩阵快速幂的，先来两个铺垫

## [1137-第N个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1137.png)

白给题，属于了是

直观的想法是使用dp，显然：`dp[i] = dp[i - 1] + dp[i - 2] + dp[i -3]`

我们使用dp从时间上是线性的，但其实有一种更好的做法，就是矩阵快速幂的，它可以让时间复杂度降低为$O(\log n)$

是这样的，我们考虑一个矩阵：$\left[\begin{matrix}dp[i]\\dp[i - 1]\\dp[i - 2]\end{matrix}\right] = Matrix\times \left[ \begin{matrix}dp[i - 1]\\dp[i - 2]\\dp[i - 3]\end{matrix}\right]$

> 至于为什么这么设计，就是根据状态转移方程来的，因为：`dp[i] = dp[i - 1] + dp[i - 2] + dp[i -3]`，就是和前面三项有关

至于中间的矩阵，显然是一个$3\times 3$的，从凑数值的角度上：$Matrix = \left[\begin{matrix}1&1&1\\1&0&0\\0&1&0\end{matrix}\right]$

因为我们知道初始状态$\left[\begin{matrix}dp[2]\\dp[1]\\dp[0]\end{matrix}\right] = \left[\begin{matrix}1\\1\\0\end{matrix}\right]$，从而有：$\left[\begin{matrix}dp[i]\\dp[i - 1]\\dp[i - 2]\end{matrix}\right] = Matrix^{i - 2}\times \left[ \begin{matrix}dp[2]\\dp[1]\\dp[0]\end{matrix}\right]$

我们的时间复杂度主要体现在矩阵求幂次的根据快速幂的求法，时间复杂度为$O(\log n)$

```java
class Solution {
    //基数矩阵，从这里开始乘
    private static final int[][] mat = {{1, 1, 1}, {1, 0, 0}, {0, 1, 0}};
    //初始化的状态
    private static final int[][] ini = {{1}, {1}, {0}};
    //单位矩阵
    private static final int[][] matE = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
    public int tribonacci(int n) {
        if (n == 0) return 0;
        if (n == 2 || n == 1) return 1;
        int[][] factor = mat;
        int index = n - 2;
        int[][] tmp = matE;
        //矩阵快速幂
        while (index > 0) {
            if ((index & 1) == 1) tmp = multiMat(tmp, factor);
            factor = multiMat(factor, factor);
            index >>= 1;
        } 
        int[][] rst =  multiMat(tmp, ini);
        return rst[0][0];
    }
	//两个矩阵相乘的函数，通解
    private int[][] multiMat(int[][] matA, int[][] matB) {
        int row = matA.length;
        int col = matB[0].length;
        int[][] rst = new int[row][col];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                for (int k = 0; k < matA[0].length; k++) {
                    rst[i][j] += matA[i][k] * matB[k][j]; 
                }
            }
        }
        return rst;
    }
}
```

## [剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/%E5%89%91%E6%8C%87%20Offer%2010-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.png)

这个题其实和上面的没什么区别，主要是现在需要对答案取模，好吧，其实没什么区别，唯一的变化主要在于矩阵求乘积的时候，要取模

状态转移方程：`dp[i] = dp[i - 1] + dp[i - 2]`，同理得到的矩阵方程：$\left[\begin{matrix}dp[i]\\dp[i - 1]\end{matrix}\right] = Matrix\times\left[\begin{matrix}dp[i -1]\\dp[i - 2]\end{matrix}\right]$,至于这个矩阵：$Matrix = \left[\begin{matrix}1&1\\1&0\end{matrix}\right]$

初始化条件：$\left[\begin{matrix}dp[1]\\dp[0]\end{matrix}\right] = \left[\begin{matrix}1\\0\end{matrix}\right]$，所以：$\left[\begin{matrix}dp[i]\\dp[i - 1]\end{matrix}\right] = Matrix^{i - 1}\times\left[\begin{matrix}dp[1]\\dp[0]\end{matrix}\right]$

```java
class Solution {
    private static final long[][] mat = {{1, 1}, {1, 0}};
    private static final long[][] ini = {{1}, {0}};
    private static final long[][] matE = {{1, 0}, {0, 1}};
    private static final int mod = 1000000007;
    public int fib(int n) {
        if (n <= 1) return n;
        long[][] tmp = matE;
        long[][] factor = mat;
        int index = n - 1;
        while (index > 0) {
            if ((index & 1) == 1) tmp = multiMat(tmp, factor);
            index >>= 1;
            factor = multiMat(factor, factor);
        }
        long[][] rst = multiMat(tmp, ini);
        return (int)rst[0][0];
    }

    private long[][] multiMat(long[][] matA, long[][] matB) {
        int row = matA.length;
        int col = matB[0].length;
        long[][] rst = new long[row][col];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                for (int k = 0; k < matA[0].length; k++) {
                    rst[i][j] += matA[i][k] * matB[k][j];
                }
                //注意这里需要取模
                rst[i][j] %= mod;
            }
        }
        return rst;
    }
}
```

好吧这两个题都是用了矩阵，他们最明显的特点在于状态转移方程是不变的，不需要考虑最值，不需要考虑i，j的条件，所以才可以使用这种矩阵一乘到底

现在考虑今天的每日一题

## [1220. 统计元音字母序列的数目](https://leetcode-cn.com/problems/count-vowels-permutation/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1220.png)

这题一看就是dp

因为状态转移方程的是定死的，所以可以使用矩阵快速幂进行加速优化时间复杂度

dp\[i][j]，表示以 j 结尾的，长度为 i 的字符串的种类的个数，因为只有 5 种元音字母，所以一共有5 种结尾

为了简化编码，我们假设一个映射关系：$\text{a}\to0;\text{e}\to1;\text{i}\to2;\text{o}\to3;\text{u}\to4$

根据编码规则，显然有：$\begin{cases}dp[i][0] = dp[i - 1][1]+dp[i - 1][2] + dp[i - 1][4]\\dp[i][1] = dp[i - 1][0] + dp[i - 1][2]\\dp[i][2] = dp[i- 1][1] + dp[i - 1][3]\\dp[i][3] = dp[i - 1][2]\\dp[i][4] = dp[i - 1][2] + dp[i - 1][3]\end{cases}$

从而我们可以总结出矩阵：$\left[\begin{matrix}dp[i][0]\\dp[i][1]\\dp[i][2]\\dp[i][3]\\dp[i][4]\end{matrix}\right] = Matrix\times\left[\begin{matrix}dp[i -1][0]\\dp[i - 1][1]\\dp[i - 1][2]\\dp[i - 1][3]\\dp[i - 1][4]\end{matrix}\right]$，其中$Matrix = \left[\begin{matrix}0&1&1&0&1\\1&0&1&0&0\\0&1&0&1&0\\0&0&1&0&0\\0&0&1&1&0\end{matrix}\right]$

```java
class Solution {
    private static final int mod = 1000000007;
    private static final long[][] mat = {{0, 1, 1, 0, 1}, {1, 0, 1, 0, 0}, {0, 1, 0, 1, 0}, {0, 0, 1 ,0 ,0}, {0, 0, 1, 1 ,0}}; 
    private static final long[][] ini = {{1}, {1}, {1}, {1}, {1}};
    private static final long[][] matE = {{1, 0, 0, 0, 0}, {0, 1, 0, 0, 0}, {0, 0, 1, 0, 0}, {0, 0, 0, 1, 0}, {0, 0, 0, 0, 1}};
    public int countVowelPermutation(int n) {
        if (n == 1) {
            return 5;
        }
        int index = n - 1;
        long[][] factor = mat;
        long[][] tmp = matE;
        while (index > 0) {
            if ((index & 1) == 1) {
                tmp = multiMat(tmp, factor);
            }
            index >>= 1;
            factor = multiMat(factor, factor);
        }
        long[][] rst = multiMat(tmp, ini);
        long num = 0;
        //结果集应该是矩阵每行的相加
        for (int i = 0; i < rst.length; i++) {
            num += rst[i][0];
            num %= mod;
        }
        return (int)num;
    }

    private long[][] multiMat(long[][] matA, long[][] matB) {
        int row = matA.length;
        int col = matB[0].length;
        long[][] rst = new long[row][col];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                for (int k = 0; k < matA[0].length; k++) {
                    rst[i][j] += matA[i][k] * matB[k][j];
                }
                rst[i][j] %= mod;
            }
        }
        return rst;
    }
}
```

## [552. 学生出勤记录 II](https://leetcode-cn.com/problems/student-attendance-record-ii/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/552.png)

这个题一看看上去好像就是dp，不过我最开始考虑的是三维的即`dp[i][j][k]`表示了考虑前i天，缺勤次数为j次，今天是迟到的第k天的，可以得到出勤奖励的方案个数

显然状态转移方程：$\begin{cases}dp[i][0][0] = dp[i - 1][0][0] + dp[i - 1][0][1] + dp[i - 1][0][2]\\dp[i][1][0] = dp[i - 1][0][0] + dp[i - 1][0][1] + dp[i - 1][0][2] + dp[i - 1][1][0] + dp[i - 1][1][1] + dp[i - 1][1][2]\end{cases}$

解释一下：`dp[i][0][0]`，说明今天到勤了，且之前没有缺过考勤，所以昨天可以

* 到勤
* 迟到，而至于迟到，可以是迟到的第一天也可以是迟到的第二天

`dp[i][1][0]`，说明今天可能是缺勤了，或者今天到勤，但之前缺勤一次

* 考虑今天缺勤：则昨天可以
  * 到勤
  * 迟到，迟到可以是第一天也可以是连续迟到的第二天

* 考虑今天到勤：则昨天可以
  * 到勤，但是再之前缺过一次考勤
  * 缺勤
  * 迟到，且迟到的天数为第一天或第二天，且在本次连续迟到之前却过一次考勤

剩下的同理得到：$\begin{cases}dp[i][0][1] = dp[i - 1][0][0]\\dp[i][1][1] = dp[i - 1][1][0]\\dp[i][0][2] = dp[i - 1][0][0]\\dp[i][1][2] = dp[i - 1][1][1]\end{cases}$

随便那一对举例子：比如说：`dp[i][0][1]`和`dp[i][1][1]`

`dp[i][0][1]`说明今天迟到第一天，且没缺过考勤，所以昨天只能是到勤；而`dp[i][1][1]`说明今天迟到第一天，且之前缺过一次考勤，昨天可以是缺勤，可以也是到勤，不管那种情况，`dp[i - 1][1][0]`都包括了

现在看起来三个维度无法进行矩阵快速幂，但是因为缺勤作为变量，只有两种状态，而迟到作为变量也只有三种状态，所以其实第二个和第三个维度一共就能确定6种状态，所以其实可以进行降维

考虑编码为：`cnt = cntA * 3 + cntL`，现在我们的第二个维度就是`cnt`，举个例子：`dp[i][0]`就是说考虑今天到勤，且之前没有缺勤的情况，而`dp[i][3]`就是说今天缺勤或者到勤但之前缺勤过一次的情况（到今天为止出现过一次缺勤）

现在就可以使用矩阵快速幂了：$\left[\begin{matrix}dp[i][0]\\dp[i][1]\\dp[i][2]\\dp[i][3]\\dp[i][4]\end{matrix}\right] = Matrix\times\left[\begin{matrix}dp[i - 1][0]\\dp[i - 1][1]\\dp[i - 1][2]\\dp[i - 1][3]\\dp[i - 1][4]\end{matrix}\right]$

至于这个矩阵：$Martix = \left[\begin{matrix}1&1&1&0&0&0\\1&0&0&0&0&0\\0&1&0&0&0&0\\1&1&1&1&1&1\\0&0&0&1&0&0\\0&0&0&0&1&0\end{matrix}\right]$

剩下的步骤和之前的一样了

```java
class Solution {
    private static final long[][] mat = {{1, 1, 1, 0, 0, 0}, {1, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 0}, {1, 1, 1, 1, 1, 1}, {0, 0, 0, 1, 0, 0}, {0, 0, 0, 0, 1, 0}};
    private static final long[][] ini = {{1}, {1}, {0}, {1}, {0}, {0}};
    private static final long[][] matE = {{1, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 0}, {0, 0, 1, 0, 0, 0}, {0, 0, 0, 1, 0, 0}, {0, 0, 0, 0, 1, 0}, {0, 0, 0, 0, 0, 1}};
    private static final int mod = 1000000007;
    
    public int checkRecord(int n) {
        int index = n - 1;
        long[][] factor = mat;
        long[][] tmp = matE;
        while (index > 0) {
            if ((index & 1) == 1) {
                tmp = mutiMat(tmp, factor);
            }
            factor = mutiMat(factor, factor);
            index >>= 1;
        }
        long ret = 0;
        long[][] rst = mutiMat(tmp, ini);
        for (int i = 0; i < rst.length; i++) {
            ret += rst[i][0];
            ret %= mod;
        }
        return (int) ret;
    }

    private long[][] mutiMat(long[][] matA, long[][] matB) {
        int row = matA.length;
        int col = matB[0].length;
        long[][] rst = new long[row][col];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                for (int k = 0; k < matB.length; k++) {
                    rst[i][j] += matA[i][k] * matB[k][j];
                }
                rst[i][j] %= mod;
            }
        }
        return rst;
    }
}
```

# 1.18

## [539. 最小时间差](https://leetcode-cn.com/problems/minimum-time-difference/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/539.png)

一个很直观的感受就是排序，然后遍历一遍比较时间差；整体时间复杂度为$O(n\log n)$，主要体现在排序上

第一版代码：

```java
class Solution {
    public int findMinDifference(List<String> timePoints) {
        timePoints.sort((s1, s2) -> {
            int rstH = s1.substring(0, 2).compareTo(s2.substring(0, 2));
            if (rstH == 0) return s1.substring(3).compareTo(s2.substring(3));
            return rstH;
        });
        int n = timePoints.size();
        int rst = gap(timePoints.get(0), timePoints.get(n - 1));
        for (int i = 1; i < n; i++) {
            rst = Math.min(rst, gap(timePoints.get(i), timePoints.get(i - 1)));
        }
        return rst;
    }

    private int gap(String t1, String t2) {
        int t1H = Integer.parseInt(t1.substring(0, 2));
        int t1M = Integer.parseInt(t1.substring(3));
        int t2H = Integer.parseInt(t2.substring(0, 2));
        int t2M = Integer.parseInt(t2.substring(3));
        /*
        	注意，这里是为了比较第一个时间和最后一个时间之间的时间差
        	可能的输入：t1 = "00:00";t2 = "23:59",对于这种输入，我们可以直接对小时加24
        	但是还有一种可能的输入：t1 = "12:12";t2 = "12:13"
        	对于上面这种输入，如果不加后一个判断条件，我们的返回值为-1
        */
        if (t1H < t2H || (t1H == t2H && t1M < t2M)) {
            t1H += 24;    
        }
        if (t1M < t2M) {
            t1H -= 1;
            t1M += 60;
        }
        return (t1H - t2H) * 60 + t1M - t2M;
    }
}
```

上面主要是对字符串排序，通过比较字符串进行排序，所以慢了一点点

这种题，因为一天的时间按照分钟分配，一共有1440个不同的分钟，如果考虑隔天的情况，那也就2880个不同的分钟，对于这种数量级的排序，可以考虑桶排序

考虑一个桶`int[] time`表示当前时间相对于基础时间`00:00`的时间差，然后遍历这个桶，就可以得到最小的时间差

```java
class Solution {
    public int findMinDifference(List<String> timePoints) {
        int[] time = new int[1440 * 2];
        for (String s : timePoints) {
            int h = Integer.parseInt(s.substring(0, 2));
            int m = Integer.parseInt(s.substring(3));
            int tmp = h * 60 + m;
            time[tmp]++;
            time[tmp + 1440]++;
        }
        int pre = -1;
        int rst = 1440;
        for (int i = 0; i < time.length; i++) {
            if (time[i] == 0) continue;
            if (time[i] > 1) return 0;
            if (pre != -1) rst = Math.min(rst, i - pre);
            pre = i;
        }
        return rst;
    }
}
```

# 1.20

## [2029. 石子游戏 IX](https://leetcode-cn.com/problems/stone-game-ix/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/2029.png)

在题设的规律下，所有的石头可以分成三类，与3模0、与3模1、与3模2

考虑第一个人，已经移除的价值为0，此时选，假设移除模3余1的石子，那么第二个人需要移除价值也为模3余1的石子（此时不考虑模3余0的石子）

* 所以在不考虑模3余0的石子时，考虑移除的规律，除了第一回合外，移除的石子的余数和当前已经移除的价值的余数应该相同；而第一回合任意移除就好
* 除了第一回合外，当选择了和剩余价值相同的石子时，会改变剩余价值；比如剩余价值为2，现在选择了2，那么剩余价值变为了1

上面的规律说明，在不考虑模3余0的石子时，玩家出石子的价值时交替的，**每回合玩家选择的石子相同**（除了第一回合）

现在考虑存在模3余0的石子，选择这些石子可以认为进行了改变玩家选择石子的行为，将使得当前会和玩家选择的石子数和上回合不同，当然，使用了偶数个石子，相当于再改变一次每回合的石子，所以一个重要的结论：

* 偶数个模3余0的石子，相当于没有这类石子，因为玩家会通过两次改变每回合要出的石子使得最终和原始值相同；而如果时奇数个，那么相当于仅有一个石子，因为相当于玩家改变一次每回合打出的石子

现在分成两种情况考虑：

* 模3余0的石子为偶数个：此时相当于没有这类石子

  * 如果仅有模3余1的石子或者仅有模3余2的石子，那么先手玩家必输

  * 如果二者都存在，那么先手必赢，策略如下：考虑先手玩家第一回合选择数量偏少（二者数量相同时随便选）的石子，后手玩家在第一回合只能选择和其相同的石子；此后每回合先手玩家都会选择数量最多的石子，而后手玩家都会选择数量最少的石子

    举个例子：比如现在`cnt1 = n,cnt2 = n`，第一回合A选择1，B也只能选择1；此后

    `cnt1 = n - 2, cnt2 = n`，而A每回合选择的都是2，B每回合只能选择1，因为1的个数少，所以B到最后只能选择2，从而输掉

* 模3余0的石子为奇数个：此时相当于只有一个该类石子

  * 如果模3余1的石子或模3余2的石子数量差大于2，先手玩家必赢，策略如下：先手玩家选择数量最多的石子，此时不管后手玩家出不出模3余0的石子都会输掉

    举个例子：比如现在`cnt1 = n + 3, cnt2 = n`，第一回合A选择1

    * 如果B不选择0，此时B只能选择1，此时`cnt1 = n + 1, cnt2 = n`那么下一回合A选择0，此后B每回合都只能选择2，而A每回合只能选择1，因为剩下的1的个数大于2的个数，所以B最终必须选择1而输掉
    * 如果B选择0，此时`cnt1 = n + 2, cnt2 = n`，此后每回合A都选择1，而B都只能选择2，同样因为剩余的1的个数大于2的个数，B会输掉

  * 如果两种石子差值小于等于2，后手玩家必赢，策略如下，后手玩家在第二回合打出模3余0的石子

    举个例子：现在不需要考虑数量问题：假设第一回合A选择1，则后手的B只能选择1；到了第二回合A选择了2，但B使用了0，从而A在第三回合后的每一回合都只能使用1（和第一回合相同的石子），而B在第三回合后的每一个会和都只能使用2（和第一回合不同的石子）

    在上面的例子中如果1的个数少，显然A会输掉，而就算1的个数多，因为最多不会比2的数量多过2个，所以在第三回合后1的数量还是少数

```java
class Solution {
    public boolean stoneGameIX(int[] stones) {
        int[] cnt = new int[3];
        for (int num : stones) {
            cnt[num % 3]++;
        }
        if ((cnt[0] & 1) == 0) {
            return cnt[1] != 0 && cnt[2] != 0;
        }else {
            return Math.abs(cnt[1] - cnt[2]) > 2;
        }
    }
}
```

# 1.21

## [1345. 跳跃游戏 IV](https://leetcode-cn.com/problems/jump-game-iv/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1345.png)

在每一个节点可以选择向前跳，向后跳，向等值的下标位置跳

存储等值的下标，这个可以预处理，使用一个map存储键为arr[i]的值，值为一个集合，这个集合中是等值的所有下标

使用BFS，第一次访问到尾部节点的时候返回总迭代次数

这里面要注意的是，为了保证每个节点仅访问一次，再遍历到等值节点的时候，需要从map中删除对应的集合

```java
class Solution {
    public int minJumps(int[] arr) {
        int n = arr.length;
        if (n == 1) return 0;
        boolean[] visited = new boolean[n];
        Map<Integer, Set<Integer>> map = new HashMap<>();
        for (int i = 0; i < arr.length; i++) {
            Set<Integer> tmp;
            if (!map.containsKey(arr[i])) {
                tmp = new HashSet<>();
                map.put(arr[i], tmp);
            }else {
                tmp = map.get(arr[i]);
            }
            tmp.add(i);
        } 
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(0);
        visited[0] = true;
        int step = 0;
        while (!queue.isEmpty()) {
            step++;
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int tmp = queue.poll();
                if (tmp == n - 2) {
                    return step;
                }
                if (tmp > 0 && !visited[tmp - 1]) {
                    queue.offer(tmp - 1);
                    visited[tmp - 1] = true;
                }
                if (map.containsKey(arr[tmp])) {
                    for (int index : map.get(arr[tmp])) {
                        if (index == n - 1) return step;
                        if (!visited[index]) {
                            queue.offer(index);
                            visited[index] = true;
                        }
                    }
                    map.remove(arr[tmp]);
                }
                if (!visited[tmp + 1]) {
                    queue.offer(tmp + 1);
                    visited[tmp + 1] = true;
                }
            }
        }
        return 0;
    }
}
```

双端BFS优化

```java
class Solution {
    private Map<Integer, List<Integer>> map;
    private int[] arr;
    private int n;
    public int minJumps(int[] arr) {
        this.n = arr.length;
        if (n == 1) return 0;
        boolean[] foreVisited = new boolean[n];
        boolean[] backVisited = new boolean[n];
        this.arr = arr;
        this.map = new HashMap<>();
        for (int i = 0; i < arr.length; i++) {
            List<Integer> tmp = map.getOrDefault(arr[i], new ArrayList<>());
            tmp.add(i);
            map.put(arr[i], tmp);
        } 
        Queue<Integer> foreQueue = new LinkedList<>();
        Queue<Integer> backQueue = new LinkedList<>();
        foreQueue.offer(0);
        foreVisited[0] = true;
        backQueue.offer(n - 1);
        backVisited[n - 1] = true;
        int foreStep = 0;
        int backStep = 0;
        while (!foreQueue.isEmpty() && !backQueue.isEmpty()) {
            int rst;
            if (foreQueue.size() < backQueue.size()) {
                foreStep++;
                rst = updateGraph(foreQueue, foreVisited, backQueue, backVisited, foreStep + backStep);
            }else {
                backStep++;
                rst = updateGraph(backQueue, backVisited, foreQueue, foreVisited, foreStep + backStep);
            }
            if (rst > 0) return rst;
        }
        return -1;
    }
    private int updateGraph(Queue<Integer> q1, boolean[] v1, Queue<Integer> q2, boolean[] v2, int step) {
        int size = q1.size();
        for (int i = 0; i < size; i++) {
            int tmp = q1.poll();
            if (tmp > 0) {
                if (v2[tmp - 1]) return step;
                if (!v1[tmp - 1]) {
                    q1.offer(tmp - 1);
                    v1[tmp - 1] = true;
                }
            }
            if (map.containsKey(arr[tmp])) {
                for (int index : map.get(arr[tmp])) {
                    if (v2[index]) return step;
                    if (!v1[index]) {
                        q1.offer(index);
                        v1[index] = true;
                    }
                }
                map.remove(arr[tmp]);
            }
            if (tmp < n - 1) {
                if (v2[tmp + 1]) return step;
                if (!v1[tmp + 1]) {
                    q1.offer(tmp + 1);
                    v1[tmp + 1] = true;
                }
            }
        }
        return -1;
    }
}
```

# 1.22

## [1332. 删除回文子序列](https://leetcode-cn.com/problems/remove-palindromic-subsequences/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1332.png)

这个题关键点在于它仅包含两种字符：`a`和`b`，所以其实最多也就需要两次就可以完成删除

而如果这个字符串本身就是回文的，那么一次删除就好

所以判断是否回文：如果回文，返回1，否则返回2

```java
class Solution {
    public int removePalindromeSub(String s) {
        int left = 0;
        int right = s.length() - 1;
        while (left < right) {
            if (s.charAt(left) == s.charAt(right)) {
                left++;
                right--;
            }else {
                return 2;
            }
        }
        return 1;
    }   
}
```

> 这题，脑筋急转弯

# 1.26

## [2013. 检测正方形](https://leetcode-cn.com/problems/detect-squares/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/2013.png)

这个题最开始想着如何存储每个点，因为看到了重复的点视为不同的点，所以使用一个map进行存储，值为其出现的频率

这样的话键是通过x和y坐标共同确定的，所以使用了一个treemap

在查找方案数的方法中，先去找两个同一条边上的点，他们和已给坐标的横坐标或者纵坐标相同，但因为我们的键是一个数组表示的x和y坐标，这一点其实不好做

[题解](https://leetcode-cn.com/problems/detect-squares/solution/gong-shui-san-xie-jian-dan-ha-xi-biao-yu-748e/)的方法就很巧妙了，它使用的是一个map嵌套另一个map的形式，即x坐标作为键映射到y坐标的map，而y坐标下的map对应的值是这个坐标出现的频率

所以在查询方法中，先去查找和当前坐标横坐标相同的map集合，如果y坐标也相同，就跳过，否则就可以根据参数中的y和查询到的map中的y确定正方体的边的长度；而剩下的，就是继续查询这个map，查看剩余两个点是否存在了

```java
class DetectSquares {
    private Map<Integer, Map<Integer, Integer>> map;

    public DetectSquares() {
        this.map = new HashMap<>();
    }
    
    public void add(int[] point) {
        int x = point[0];
        int y = point[1];
        Map<Integer, Integer> tmp = map.getOrDefault(x, new HashMap<>());
        tmp.put(y, tmp.getOrDefault(y, 0) + 1);
        map.put(x, tmp);
    }
    
    public int count(int[] point) {
        int x = point[0];
        int y = point[1];
        int rst = 0;
        Map<Integer, Integer> tmp = map.getOrDefault(x, new HashMap<>());
        for (int tmpY : tmp.keySet()) {
            if (y == tmpY) continue;
            int len = y - tmpY;
            Map<Integer, Integer> pre = map.getOrDefault(x - len, new HashMap<>());
            int count = pre.getOrDefault(y, 0);
            if (count > 0) {
                rst += tmp.get(tmpY) * count * pre.getOrDefault(tmpY, 0);
            }
            Map<Integer, Integer> next = map.getOrDefault(x + len, new HashMap<>());
            count = next.getOrDefault(y, 0);
            if (count > 0) {
                rst += tmp.get(tmpY) * count * next.getOrDefault(tmpY, 0);
            }
        }
        return rst;
    }
}

/**
 * Your DetectSquares object will be instantiated and called as such:
 * DetectSquares obj = new DetectSquares();
 * obj.add(point);
 * int param_2 = obj.count(point);
 */
```

# 1.28

## [1996. 游戏中弱角色的数量](https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1996.png)

这个题要找的是弱角色，即攻防都比另一个角色小的角色

这个排序肯定是跑不了了，先按照攻击进行升序排列；那么前面的攻击肯定不比后面的攻击大

最开始对于攻击相同的角色，按照防御进行了升序排列，这样我们从后向前遍历的时候维护一个最大的防御力，和对应的攻击属性就好：

```java
	int n = properties.length;
    int maxDefence = -1;
    int assoAttact = -1;
    int rst = 0;
    for (int i = n - 1; i >= 0; i--) {
        if (properties[i][1] > maxDefence) {
            maxDefence = properties[i][1];
            assoAttact = properties[i][0];
        }else if (assoAttact > properties[i][0] && maxDefence > properties[i][1]) rst++;
    }
```

然而上面这个代码有很严重的问题，他在遇到了防御力更大的时候就选择了更新防御和关联的攻击：

所以如果有这样的输入：`[1, 2], [1, 10], [2, 5]`，那么在他看来就不存在一个弱角色

问题出现在了攻击相同时，防御最大的角色上；随后维护了一个可能成为备选高防御，高攻击的角色的数组：

```java
	List<int[]> max = new ArrayList<>();
    int maxDefence = -1;
    int rst = 0;
    for (int i = n - 1; i >= 0; i--) {
        if (properties[i][1] > maxDefence) {
            maxDefence = properties[i][1];
            max.add(properties[i]);
        }else {
            for (int j = 0; j < max.size() && max.get(j)[0] > properties[i][0]; j++) {
                if (max.get(j)[1] > properties[i][1]) {
                    rst++;
                    break;
                }
            }
        }
    }
```

我们还是从后向前取遍历，只不过这次如果遇到了大防御的角色，我们就让其加入一个备选的数组

上面的还是太麻烦了，其实这个问题只要稍微改变一下遍历的顺序就可以解决：

```java
class Solution {
    public int numberOfWeakCharacters(int[][] properties) {
        Arrays.sort(properties, (nums1, nums2) -> {
            if (nums1[0] == nums2[0]) return nums1[1] - nums2[1];
            return nums2[0] - nums1[0];
        });
        int maxDefence = -1;
        int rst = 0;
        for (int i = 0; i < properties.length; i++) {
            if (properties[i][1] >= maxDefence) {
                maxDefence = properties[i][1];
            }else {
                rst++;
            }
        }
        return rst;
    }
}
```

现在我们按照攻击力降序排列，并按照防御力升序排列；按照攻击力降序排列可以让我们的遍历从前向后

而按照防御力升序排列可以避免因为防御力太大而过早更新，比如上面的举例的输入，我们每次更新防御力的时候都保证了和其攻击相同的角色都已经完成了遍历

# 1.29

## [1765. 地图中的最高点](https://leetcode-cn.com/problems/map-of-highest-peak/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1765.png)

这个题就是BFS吧，没什么多说的

```java
class Solution {
    private static final int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    public int[][] highestPeak(int[][] isWater) {
        int row = isWater.length;
        int col = isWater[0].length;
        Queue<int[]> queue = new LinkedList<>();
        boolean[][] visited = new boolean[row][col];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (isWater[i][j] == 1) {
                    queue.offer(new int[]{i, j});
                    visited[i][j] = true;
                    isWater[i][j] = 0;
                }
            }
        }
        int step = 0;
        while(!queue.isEmpty()) {
            step++;
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] tmp = queue.poll();
                for (int[] direction : directions) {
                    int mx = tmp[0] + direction[0];
                    int my = tmp[1] + direction[1];
                    if (mx >= 0 && mx < row && my >= 0 && my < col && !visited[mx][my]) {
                        isWater[mx][my] = step;
                        queue.offer(new int[]{mx, my});
                        visited[mx][my] = true;
                    }
                }
            }
        }
        return isWater;
    }
}
```







