# 4.3

## [79. Word Search](https://leetcode.com/problems/word-search/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/word-search/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/04/03/10:40:53:79.png" />
	</a>
</div>

本题的输入矩阵大小是 6x6 的, 直接爆搜就好, 枚举每个位置作为搜索起点的情况, 从四个方向开始搜索

```java
class Solution {
    private static final int[][] DIR = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    private boolean[][] vis;
    private char[][] board;
    private char[] ws;
    public boolean exist(char[][] board, String word) {
        int m = board.length;
        int n = board[0].length;
        this.vis = new boolean[m][n];
        this.board = board;
        this.ws = word.toCharArray();
        
        for (int i = 0; i < m; i ++) {
            for (int j = 0; j < n; j ++) {
                if (board[i][j] == ws[0]) {
                    vis[i][j] = true;
                    if (dfs(i, j, 0)) return true;
                    vis[i][j] = false;
                }
            }
        }
        
        return false;
    }
    
    private boolean dfs(int i, int j, int idx) {
        idx ++;
        if (idx == ws.length) return true;
        
        for (int[] d : DIR) {
            int ni = i + d[0];
            int nj = j + d[1];
            if (ni >= 0 && ni < vis.length && nj >= 0 && nj < vis[0].length 
                && !vis[ni][nj] && board[ni][nj] == ws[idx]) {
                vis[ni][nj] = true;
                if (dfs(ni, nj, idx)) return true;
                vis[ni][nj] = false;
            }
        }
        
        return false;
    }
}
```

## [212. Word Search II](https://leetcode.com/problems/word-search-ii/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/word-search-ii/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img@latest/img/212.png" />
	</a>
</div>

和上一个题差不多, 区别在于现在需要搜索的单词个数变多了, 一种比较暴力的方法是采用上面那个题的逻辑, 针对每个单词对 board 进行一次搜索, 只要能在 board 中找到当前单词, 就将其加入到结果集: 实际就是本题不能爆搜

最开始的想法是: 用前面单词的搜索结果加速后面单词的搜索 -> 记录当前可达的最长前缀, 后续的搜索直接在前缀的基础上进行搜索; 但很快就发现了问题, 本题要求单词不能被重复, 因此不仅仅需要记录前缀的位置, 还需要记录前缀在 board 上的路径, 避免重复搜索 

本题之前也是做过的, 当时的优化思路是: 不再按照单词进行搜索, 而是按照前缀进行搜索 -> 先将待搜索的各个单词加入字典树, 后续在字典树上进行搜索, 从根节点出发, 根据 board 上的字符, 判断每个字符是否在字典树上出现, 如果出现了, 就从对应位置开始进行更深一层的字典树搜索; 如果当前深度的字典树已经搜索到了单词, 就将对应单词加入结果集, 为了进行结果去重, 这里还需要通过标记的方式将搜索到的单词从字典树中删除

```java
class Solution {
    private static final int[][] DIR = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    private char[][] board;
    private char[] ws;
    private Trie root;
    private List<String> rst;
    
    public List<String> findWords(char[][] board, String[] words) {
        this.root = new Trie();
        for (String w : words) insert(w);
        
        int m = board.length, n = board[0].length;
        this.board = board;
        this.rst = new ArrayList<>(words.length);
        
        for (int i = 0; i < m; i ++) {
            for (int j = 0; j < n; j ++) {
                int k = board[i][j] - 'a';
                if (root.children[k] != null && root.children[k].cnt != 0) {
                    // 原地修改 board 数组, 省去 vis 数组
                    char c = board[i][j];
                    board[i][j] = '#';
                    dfs(i, j, root.children[k]);
                    board[i][j] = c;
                }
            }
        }
        return rst;
    }
    
    private void dfs(int i, int j, Trie node) {
        if (!"".equals(node.word)) {
            // 搜索终点: 当前深度的字典树包含了一个备选单词
            rst.add(node.word);
            remove(node.word);
        }
        
        for (int[] d : DIR) {
            int ni = i + d[0];
            int nj = j + d[1];
            if (ni >= 0 && ni < board.length && nj >= 0 && nj < board[0].length) {
                int k = board[ni][nj] - 'a';
                if (k >= 0 && node.children[k] != null && node.children[k].cnt != 0) {
                    char c = board[ni][nj];
                    board[ni][nj] = '#';
                    dfs(ni, nj, node.children[k]);
                    board[ni][nj] = c;
                }
            }
        }
    }
    
    private void insert(String w) {
        Trie node = root;
        char[] ws = w.toCharArray();
        for (char c : ws) {
            int j = c - 'a';
            if (node.children[j] == null) node.children[j] = new Trie();
            node = node.children[j];
            node.cnt ++;
        }
        node.word = w;
    }
    
  	// 字典树删除字符串 (标记)
    private void remove(String w) {
        Trie node = root;
        char[] ws = w.toCharArray();
        for (char c : ws) {
            int j = c - 'a';
            node = node.children[j];
            node.cnt --;
        }
        node.word = "";
    }
}

class Trie {
    Trie[] children;
    String word;
    int cnt;
    
    public Trie() {
        this.children = new Trie[26];
        this.word = "";
        this.cnt = 0;
    }
}
```

# 4.6

## [1483. 树节点的第 K 个祖先 (Kth Ancestor of a Tree Node)](https://leetcode.cn/classic/problems/kth-ancestor-of-a-tree-node/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/kth-ancestor-of-a-tree-node/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/04/06/11:00:20:1483.png" />
	</a>
</div>

本题相当于对 LCA 求解最近公共祖先的简化版, 这里不需要求解两个节点的最近公共祖先, 而是直接返回距离当前节点距离为 k 的祖先; 整体的思路还是类似的, 先进行一次 dfs 搜索填充 dis 数组, 找到距离当前节点 n 距离为 $2^i$ 的祖先; 然后根据二进制的结果找到距离其为 k 的祖先

```java
class TreeAncestor {
    private static final int N = 20;
    private int[] h;
    private int[] e;
    private int[] ne;
    private int idx;
    private int[][] dis;
    
    public TreeAncestor(int n, int[] parent) {
        this.h = new int[n];
        Arrays.fill(h, -1);
        int m = parent.length;
        this.e = new int[m];
        this.ne = new int[m];
        this.idx = 0;
        for (int i = 0; i < m; i ++) add(parent[i], i);
        this.dis = new int[n][N];
        for (int i = 0; i < n; i ++) Arrays.fill(dis[i], -1);
        dfs(0);
    }
    
    public int getKthAncestor(int node, int k) {
        for (int i = 0; i < N; i ++, k >>= 1) {
            if ((k & 1) == 1) {
                node = dis[node][i];
                if (node == -1) return node;
            }
        }
        return node;
    }
    
    private void dfs(int node) {
        for (int i = h[node]; i != -1; i = ne[i]) {
            int j = e[i];
            dis[j][0] = node;
            for (int k = 1; k < N; k ++) {
                int fa = dis[j][k - 1];
                if (fa == -1) break;
                dis[j][k] = dis[fa][k - 1];
            }
            dfs(j);
        }
    }
    
    private void add(int a, int b) {
        if (a == -1) return;
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx ++;
    }
}
```

>   本题的输入 parent 本身已经是一棵树了, 建图的时候可以直接建立有向边, 因此 dfs 函数中没有父节点作为参数

## [1249. Minimum Remove to Make Valid Parentheses](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1249.png" />
	</a>
</div>

一般而言这种判断有效括号的题目都可以使用栈解决, 本题也是一样, 左括号入栈, 遇到右括号弹栈, 其中:

*   弹栈时, 如果栈为空, 则此时的右括号无效 (无左括号和其匹配)
*   遍历结束后, 栈中剩下的左括号无效 (无右括号和其匹配)

```java
class Solution {
    public String minRemoveToMakeValid(String s) {
        int n = s.length();
        char[] cs = s.toCharArray();
        Deque<Integer> stack = new ArrayDeque<>(n);
        for (int i = 0; i < n; i ++) {
            if (cs[i] == '(') stack.offerLast(i);
            else if (cs[i] == ')') {
                if (stack.isEmpty()) cs[i] = '.';
                else stack.pollLast();
            }
        }
        while (!stack.isEmpty()) cs[stack.pollLast()] = '.';
        int idx = 0;
        char[] rst = new char[n];
        for (int i = 0; i < n; i ++) {
            if (cs[i] == '.') continue;
            rst[idx ++] = cs[i];
        }
        return new String(rst, 0, idx);
    }
}
```

而这里要说的是本题的另一种做法, 即在从左向右遍历的时候, 搜索非法的右括号, 而在从右向左遍历的时候, 搜索非法的左括号; 

这个过程很容易, 对于从左向右而言, 可以记录其左括号的个数 (类比上面的入栈), 遇到右括号时, 让该计数自减 (类比上面的弹栈), 在计数为 0 时遇到的右括号均为非法右括号 (类比上面的标记)

```java
class Solution {
    public String minRemoveToMakeValid(String s) {
        int n = s.length();
        char[] cs = s.toCharArray();
        char[] rst = new char[n];
        int idx = 0;
        int cnt = 0;
        for (int i = n - 1; i >= 0; i --) {
            if (cs[i] == '(') {
                if (cnt == 0) continue;
                cnt --;
            } else if (cs[i] == ')') cnt ++;
            rst[idx ++] = cs[i];
        }
        
        for (int i = 0, j = idx - 1; i < j; i ++, j --) {
            char tmp = rst[i];
            rst[i] = rst[j];
            rst[j] = tmp;
        }
        
        cnt = 0;
        n = idx;
        idx = 0;
        for (int i = 0; i < n; i ++) {
            if (cs[i] == ')') {
                if (cnt == 0) continue;
                cnt --;
            } else if (cs[i] == '(') cnt ++;
            
            rst[idx ++] = rst[i];
        }
        return new String(rst, 0, idx);
    }
}
```

# 4.7

## [678. Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/valid-parenthesis-string/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/04/07/10:24:15:678.png" />
	</a>
</div>

采用和昨天类似的想法, 两轮遍历, 第一轮从左向右, 确保每个右括号都有一个对应的左括号匹配; 第二轮从右向左, 确保每个左括号都有一个对应的右括号

```java
class Solution {
    public boolean checkValidString(String s) {
        int n = s.length();
        char[] cs = s.toCharArray();
        // cnt 记录括号数目
        int cnt = 0;
        // re 记录星号数目
        int re = 0;
        for (int i = 0; i < n; i ++) {
            if (cs[i] == '(') cnt ++;
            else if (cs[i] == '*') re ++;
            else {
                if (cnt != 0) cnt --;
                else if (re != 0) re --;
                else return false;
            }
        }
        cnt = 0;
        re = 0;
        for (int i = n - 1; i >= 0; i --) {
            if (cs[i] == ')') cnt ++;    
            else if (cs[i] == '*') re ++;
            else {
                if (cnt != 0) cnt --;
                else if (re != 0) re --;
                else return false;
            }
        }
        return true;
    }
}
```

# 4.8

## [2009. 使数组连续的最少操作数 (Minimum Number of Operations to Make Array Continuous)](https://leetcode.cn/classic/problems/minimum-number-of-operations-to-make-array-continuous/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/minimum-number-of-operations-to-make-array-continuous/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/04/08/10:35:27:2009.png" />
	</a>
</div>

每次操作可以将一个数字变为其他任意的数字, 因此最终结果和区间两端无关, 这里考虑反向考虑当前数字在连续区间内已有的数字的个数

首先对数组进行排序, 然后去重 (WA 了一次才发现), 维护一个滑动窗口, 枚举窗口的右端点, 同时更新左端点, 这样窗口大小等价于当前数组在连续区间内已有数字的个数, 而需要修改的数字个数通过反向求解得到

```java
class Solution {
    public int minOperations(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        int m = unique(nums);
        int rst = n;
        for (int l = 0, r = 0; r < m; r ++) {
            int b = nums[r] - (n - 1);
            while (l < r && nums[l] < b) l ++;
            int len = r - l + 1;
            rst = Math.min(rst, n - len);
        }
        return rst;
    }

    private int unique(int[] nums) {
        int idx = 0;
        for (int i = 0; i < nums.length; i ++) {
            if (i == 0 || nums[i] != nums[i - 1]) nums[idx ++] = nums[i];
        }
        return idx;
    }
}
```

本题最关键的一个点在于, 枚举右端点, 这其实是假设了, 最终结果集的区间的右端点一定在原数组内, 下面进行证明:

对于当前枚举的位置 i, 其下一个位置为 i + 1, 如果最终结果集右端点不是 nums[i] 也不是 nums[i + 1], 而是 (nums[i], nums[i + 1]) 中的某个数字, 那么在滑动窗口从 i 向 i + 1 滑动的过程中, 在原数组中可能有数字从左边界划出, 但绝对不会有数字从右边界划入, 即窗口内原数组的数字个数只会变少不会增加, 直到右边界达到了 nums[i + 1]

# 4.9

## [2073. Time Needed to Buy Tickets](https://leetcode.com/problems/time-needed-to-buy-tickets/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/time-needed-to-buy-tickets/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/04/09/10:07:54:2073.png" />
	</a>
</div>

本题最暴力的想法是, 直接模拟买票过程, 整体时间复杂度为 $O(n\times m)$, 本题为 esay 的题, 输入范围仅仅 $10^4$ 模拟也是可以过的

而实际上, 买票的过程其实暗含了买票是存在顺序的, 即排在队列前的一定会先买票, 排在第 k 个位置前面的人, 在第 k 个人买完票之后, 要么也买了 tickets[k] 张票, 要么已经买完了直接离队; 而排在第 k 个位置后面的人, 在第 k 个人离队之前, 要么买了 tickets[k] - 1 张票, 要么已经买完了而离队

因此整个买票过程是可以通过遍历一次数组直接得到的

```java
class Solution {
    public int timeRequiredToBuy(int[] tickets, int k) {
        int n = tickets.length;
        int rst = 0;
        for (int i = 0; i < n; i ++) {
            if (i <= k) rst += Math.min(tickets[i], tickets[k]);
            else rst += Math.min(tickets[i], tickets[k] - 1);   
        }
        return rst;
    }
}
```

# 4.10

## [1702. 修改后的最大二进制字符串 (Maximum Binary String After Change)](https://leetcode.cn/classic/problems/maximum-binary-string-after-change/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/maximum-binary-string-after-change/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/04/10/09:33:13:1702.png" />
	</a>
</div>

本题返回的长度为 n 的字符串的结果中最多包含一个 0:

*   首先答案中不会包含 00: 因为显然 10 比 00 更大, 很容易替换
*   假设存在如下序列 0xxx0, 其中 xxx 表示若干个 1, 这里就假设有 3 个 1, 则可以通过如下方式不断让两个 0 相遇: 011**10** -> 011**01** -> 01**10**1 -> 01**01**1 -> 0**10**11 -> 0**01**11
*   一旦两个 0 相遇就可以通过操作 1 将 00 转化为 10 (变得更大)
*   注意到上述操作是针对任意的两个 0 而言的, 通过上述操作可以将 binary 中的所有的 0 集中到某一段内, 构成如下形式: 111 ... 000 ... 111, 即前缀是全 1, 中间全是 0, 后缀为全 1; 在该形式下不管是 1 还是 0 都是可选的, 比如可能没有前缀, 没有后缀, 或者没有 0 (此时直接返回就好了, 已经是最大的了)
*   对于一段连续的 0, 这里以长度 5 的段为例, 可以通过如下方式变为 11110: **00**000 -> **10**000 -> 1**00**00 -> 1**10**00 -> 11**00**0 -> 11**10**0 -> 111**00** -> 111**10**

对于任意的字符串, 可以通过题目中的两个操作, 将字符串修改为前后缀为 1, 中间为 0 的形式, 中间 0 的开始位置取决于原 binary 中从左向右出现的第一个 0, 中间 0 段的结束位置取决于原 binary 中后缀中 1 的个数

本题的关键在于找到原 binary 中后缀 1 的个数, 这样只要将其前一个位置修改为 0 即可

```java
class Solution {
    public String maximumBinaryString(String binary) {
        int n = binary.length();
        char[] cs = binary.toCharArray();
        char[] rst = new char[n];
        Arrays.fill(rst, '1');
        int flag = 0;
        int cnt = 0;
        for (int i = 0; i < n; i ++) {
            if (cs[i] == '0') flag = 1;
            else {
                if (flag == 1) cnt ++;
            }
        }
        // flag 为 0 表示 binary 中不存在任何的 0
        if (flag == 1) rst[n - 1 - cnt] = '0';
        return new String(rst);
    }
}
```

## [950. Reveal Cards In Increasing Order](https://leetcode.com/problems/reveal-cards-in-increasing-order/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/reveal-cards-in-increasing-order/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/04/10/09:54:37:950.png" />
	</a>
</div>

本题要求所有卡片的堆叠后, 每隔一个位置输出可以得到一个递增的顺序

以示例 1 为例: 一眼望过去, 前面的几个数字应该填成: [2, x, 3, x, 5, x, 7]; 反正是每隔一个位置递增, 第一轮填写的内容是很好确定的

因为被跨越过去的位置会被放到牌堆底, 因此这里可以考虑使用一个队列维护下一个需要填写数字的下标

```java
class Solution {
    public int[] deckRevealedIncreasing(int[] deck) {
        int n = deck.length;
        int[] rst = new int[n];
        Deque<Integer> q = new ArrayDeque<>(n);
        for (int i = 0; i < n; i ++) q.offerLast(i);
        // 先排好序
        Arrays.sort(deck);
        int idx = 0;
        while (!q.isEmpty()) {
            // 填写一个, 跨一个
            rst[q.pollFirst()] = deck[idx ++];
            if (!q.isEmpty()) q.offerLast(q.pollFirst());
        }
        return rst;
    }
}
```

>   模拟题, while 循环体内部每次会填写 rst 数组的一个位置, 因此整体时间复杂度为 $O(n)$

# 4.11

## [1766. 互质树 (Tree of Coprimes)](https://leetcode.cn/classic/problems/tree-of-coprimes/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/tree-of-coprimes/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/04/11/11:28:17:1766.png" />
	</a>
</div>

本题的突破口在于输入, 输入节点的范围达到了 $10^5$ 级别, 但是 nums[i] 的大小仅为 50, 因此当搜索到某个点时, 不应该回溯整条路径上的各个父节点是否和本节点互质, 而应该判断和当前节点互质的数字是否已经出现在路径上了, 同时还需要找到距离本节点最近的互质节点

采用 dfs 搜索到某个节点时, 其路径上每个点的深度都是不同的, 因此显然, 深度越深的距离当前节点越近, 因此这里在 dfs 函数中维护了一个大小为 50 x 2 的二维数组 map, map\[i][0] 表示数字 i 所在的最大深度, map\[i][1] 表示数字 i 所对应的最深节点

```java
class Solution {
    private static final int N = 60;
    private static final int[][] M = new int[N][N];

    // 批量预处理各个数字之间的最大公约数
    static {
        for (int i = 1; i < N; i ++) {
            for (int j = 1; j < N; j ++) {
                if (i == j) continue;
                M[i][j] = gcd(i, j);
            }
        }
        // 在本题的设定中 1 和任意数字都是互质关系
        M[1][1] = 1; 
    }

    private int[] h;
    private int[] e;
    private int[] ne;
    private int idx;
    private int[] w;
    private int[] rst;

    public int[] getCoprimes(int[] nums, int[][] edges) {
        int n = nums.length;
        this.h = new int[n];
        Arrays.fill(h, -1);
        int m = edges.length;
        this.e = new int[m << 1];
        this.ne = new int[m << 1];
        this.idx = 0;
        this.w = nums;
        for (int[] e : edges) {
            add(e[0], e[1]);
            add(e[1], e[0]);
        }
        this.rst = new int[n];
        Arrays.fill(rst, -1);
        int[][] map = new int[N][2];
        dfs(0, -1, map, 1);
        return rst;
    }

    private void dfs(int cur, int fa, int[][] m, int depth) {
        // 首先遍历 50 个数字, 看看是否存在互质的父节点
        int d = 0;
        for (int i = 1; i < N; i ++) {
            if (M[w[cur]][i] == 1 && m[i][0] > d) {
                d = m[i][0];
                rst[cur] = m[i][1];
            }
        }
        
        // dfs 从本节点开始继续向下搜索, 进行覆盖
        int ori_depth = m[w[cur]][0];
        int ori_node = m[w[cur]][1];
        m[w[cur]][0] = depth;
        m[w[cur]][1] = cur;

        for (int i = h[cur]; i != -1; i = ne[i]) {
            int j = e[i];
            if (j == fa) continue;
            dfs(j, cur, m, depth + 1);
        }

        m[w[cur]][0] = ori_depth;
        m[w[cur]][1] = ori_node;
    }

    private void add(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx ++;
    }

    private static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}
```

## [402. Remove K Digits](https://leetcode.com/problems/remove-k-digits/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/remove-k-digits/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/402.png" />
	</a>
</div>
数字顺序不能重排, 只能删除其中的部分数字, 显然如果希望数字尽可能小的话, 应该让数字中的各个位保持升序关系, 这其实就是在暗示使用单调栈 -> 维护一个单调递增的栈

```java
class Solution {
    public String removeKdigits(String num, int k) {
        int n = num.length();
        char[] stk = new char[n];
        int e = 0;
        char[] nums = num.toCharArray();
        for (int i = 0; i < n; i ++) {
            while (e > 0 && stk[e - 1] > nums[i] && k > 0) {
                e --;
                k --;
            }
            stk[e ++] = nums[i];
        }
        
        // 注意可能出现 k 很大的情况, 此时应该将栈中剩余递增的数字也弹栈
        while (k > 0 && e > 0) {
            k --;
            e --;
        }
        
        // 栈为空直接返回
        if (e == 0) return String.valueOf('0');
      	
        // 栈不空需要去除前导 0
        int i = 0;
        while (i < e && stk[i] == '0') i ++;
        if (i == e) i = e - 1;
        return new String(stk, i, e - i);
    }
}
```

