# 4.3

## [79. Word Search](https://leetcode.com/problems/word-search/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/word-search/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/04/03/10:40:53:79.png" />
	</a>
</div>

本题的输入矩阵大小是 6x6 的, 直接爆搜就好, 枚举每个位置作为搜索起点的情况, 从四个方向开始搜索

```java
class Solution {
    private static final int[][] DIR = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    private boolean[][] vis;
    private char[][] board;
    private char[] ws;
    public boolean exist(char[][] board, String word) {
        int m = board.length;
        int n = board[0].length;
        this.vis = new boolean[m][n];
        this.board = board;
        this.ws = word.toCharArray();
        
        for (int i = 0; i < m; i ++) {
            for (int j = 0; j < n; j ++) {
                if (board[i][j] == ws[0]) {
                    vis[i][j] = true;
                    if (dfs(i, j, 0)) return true;
                    vis[i][j] = false;
                }
            }
        }
        
        return false;
    }
    
    private boolean dfs(int i, int j, int idx) {
        idx ++;
        if (idx == ws.length) return true;
        
        for (int[] d : DIR) {
            int ni = i + d[0];
            int nj = j + d[1];
            if (ni >= 0 && ni < vis.length && nj >= 0 && nj < vis[0].length 
                && !vis[ni][nj] && board[ni][nj] == ws[idx]) {
                vis[ni][nj] = true;
                if (dfs(ni, nj, idx)) return true;
                vis[ni][nj] = false;
            }
        }
        
        return false;
    }
}
```

## [212. Word Search II](https://leetcode.com/problems/word-search-ii/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/word-search-ii/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img@latest/img/212.png" />
	</a>
</div>

和上一个题差不多, 区别在于现在需要搜索的单词个数变多了, 一种比较暴力的方法是采用上面那个题的逻辑, 针对每个单词对 board 进行一次搜索, 只要能在 board 中找到当前单词, 就将其加入到结果集: 实际就是本题不能爆搜

最开始的想法是: 用前面单词的搜索结果加速后面单词的搜索 -> 记录当前可达的最长前缀, 后续的搜索直接在前缀的基础上进行搜索; 但很快就发现了问题, 本题要求单词不能被重复, 因此不仅仅需要记录前缀的位置, 还需要记录前缀在 board 上的路径, 避免重复搜索 

本题之前也是做过的, 当时的优化思路是: 不再按照单词进行搜索, 而是按照前缀进行搜索 -> 先将待搜索的各个单词加入字典树, 后续在字典树上进行搜索, 从根节点出发, 根据 board 上的字符, 判断每个字符是否在字典树上出现, 如果出现了, 就从对应位置开始进行更深一层的字典树搜索; 如果当前深度的字典树已经搜索到了单词, 就将对应单词加入结果集, 为了进行结果去重, 这里还需要通过标记的方式将搜索到的单词从字典树中删除

```java
class Solution {
    private static final int[][] DIR = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    private char[][] board;
    private char[] ws;
    private Trie root;
    private List<String> rst;
    
    public List<String> findWords(char[][] board, String[] words) {
        this.root = new Trie();
        for (String w : words) insert(w);
        
        int m = board.length, n = board[0].length;
        this.board = board;
        this.rst = new ArrayList<>(words.length);
        
        for (int i = 0; i < m; i ++) {
            for (int j = 0; j < n; j ++) {
                int k = board[i][j] - 'a';
                if (root.children[k] != null && root.children[k].cnt != 0) {
                    // 原地修改 board 数组, 省去 vis 数组
                    char c = board[i][j];
                    board[i][j] = '#';
                    dfs(i, j, root.children[k]);
                    board[i][j] = c;
                }
            }
        }
        return rst;
    }
    
    private void dfs(int i, int j, Trie node) {
        if (!"".equals(node.word)) {
            // 搜索终点: 当前深度的字典树包含了一个备选单词
            rst.add(node.word);
            remove(node.word);
        }
        
        for (int[] d : DIR) {
            int ni = i + d[0];
            int nj = j + d[1];
            if (ni >= 0 && ni < board.length && nj >= 0 && nj < board[0].length) {
                int k = board[ni][nj] - 'a';
                if (k >= 0 && node.children[k] != null && node.children[k].cnt != 0) {
                    char c = board[ni][nj];
                    board[ni][nj] = '#';
                    dfs(ni, nj, node.children[k]);
                    board[ni][nj] = c;
                }
            }
        }
    }
    
    private void insert(String w) {
        Trie node = root;
        char[] ws = w.toCharArray();
        for (char c : ws) {
            int j = c - 'a';
            if (node.children[j] == null) node.children[j] = new Trie();
            node = node.children[j];
            node.cnt ++;
        }
        node.word = w;
    }
    
  	// 字典树删除字符串 (标记)
    private void remove(String w) {
        Trie node = root;
        char[] ws = w.toCharArray();
        for (char c : ws) {
            int j = c - 'a';
            node = node.children[j];
            node.cnt --;
        }
        node.word = "";
    }
}

class Trie {
    Trie[] children;
    String word;
    int cnt;
    
    public Trie() {
        this.children = new Trie[26];
        this.word = "";
        this.cnt = 0;
    }
}
```





