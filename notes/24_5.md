# 5.1

## [2997. Minimum Number of Operations to Make Array XOR Equal to K](https://leetcode.com/problems/minimum-number-of-operations-to-make-array-xor-equal-to-k/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/minimum-number-of-operations-to-make-array-xor-equal-to-k/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/05/01/14:11:01:2997.png" />
	</a>
</div>

先对 nums 整体作异或运算, 并将整个数组的运算结果和 k 按位比较, 只要存在一个 bit 不同, 就需要进行一次 flip bit

```java
class Solution {
    public int minOperations(int[] nums, int k) {
        int tmp = 0;
        for (int n : nums) tmp ^= n;
        int rst = 0;
        for (int i = 0; i < 32; i ++) {
            if (((tmp >> i) & 1) != ((k >> i) & 1)) rst ++;
        }
        return rst;
    }
}
```

当然还可以更进一步, 将整个数组的异或结果和 k 再进行一次异或, 计算最终结果的 bit count 即为需要反转的 bit

```java
class Solution {
    public int minOperations(int[] nums, int k) {
        int rst = k;
        for (int n : nums) rst ^= n;
        return Integer.bitCount(rst);
    }
}
```

## [1915. Number of Wonderful Substrings](https://leetcode.com/problems/number-of-wonderful-substrings/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/number-of-wonderful-substrings/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/05/01/14:18:28:1915.png" />
	</a>
</div>
本题的切入点是 word 中只包含了 10 种字符, 虽然输入范围大小为 $10^5$ 级别, 但只有 10 种字符, 一共也只有 $2^{10}$ 种字符奇偶性不同的子串 

本题的思路是记录当前前缀的字符奇偶性子串 (使用 bit mask 的方式表示), 对于当前前缀枚举最多只有一个字符奇偶性不同的 bit mask 作为前缀的前缀, 这样两个前缀之间的部分就是满足条件的子串

```java
class Solution {
    private static final int N = (int)1e4;
    public long wonderfulSubstrings(String word) {
        // 记录各种 bit mask 的出现频率
        int[] m = new int[N];
        m[0] ++;
        char[] cs = word.toCharArray();
        int n = cs.length;
        int mx = 0;
        long rst = 0;
        for (int i = 0; i < n; i ++) {
            int j = cs[i] - 'a';
            // 维护当前前缀
            mx ^= (1 << j);
            // 枚举各个和当前前缀奇偶性不同的 bit

            for (int k = 0; k < 10; k ++) {
                int x = mx ^ (1 << k);
                rst += m[x];
            }
            rst += m[mx];
            m[mx] ++;
        }
        return rst;
    }
}
```

