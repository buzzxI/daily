# 5.1

## [1305. 两棵二叉搜索树中的所有元素](https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1305.png)

这个题比较简单的做法是两次中序遍历，得到两个list，然后合并。不过这样做空间开销比较大。希望可以一边遍历一边进行比较的做法。

这个时候其实可以参考：[173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)，相当于对二叉搜索树封装了一层迭代器，这样每次调用`next()`函数时，只会找到下一个需要返回的节点。不过需要注意的是，在本题中，我们还需要实现`peek()`接口才能实现比较的功能。

我们通过两个根节点，获得两个迭代器，然后如果均`hasNext()`，就通过`peek()`的大小进行合并

```java
class Solution {
    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {
        BSTIterator iterator1 = new BSTIterator(root1);
        BSTIterator iterator2 = new BSTIterator(root2);
        List<Integer> rst = new ArrayList<>();
        while (iterator1.hasNext() && iterator2.hasNext()) {
            if (iterator1.peek() < iterator2.peek()) {
                rst.add(iterator1.next());
            } else {
                rst.add(iterator2.next());
            }
        }
        while (iterator1.hasNext()) {
            rst.add(iterator1.next());
        }
        while (iterator2.hasNext()) {
            rst.add(iterator2.next());
        }
        return rst;
    }
}

class BSTIterator {
    private TreeNode root;
    private int per;
    public BSTIterator(TreeNode root) {
        this.root = root;
        this.per = traverse();
    }
    
    private int traverse() {
        int rst = -1;
        while (root != null) {
            if (root.left == null) {
                rst = root.val;
                root = root.right;
                return rst;
            } else {
                TreeNode predecessor = root.left;
                while (predecessor.right != null && predecessor.right != root) {
                    predecessor = predecessor.right;
                }
                if (predecessor.right == null) {
                    predecessor.right = root;
                    root = root.left;
                } else {
                    predecessor.right = null;
                    rst = root.val;
                    root = root.right;
                    return rst;
                }
            }
        }
        return -1;
    }

    public int peek() {
        return per;
    }
    
    public int next() {
        int rst = per;
        this.per = traverse();
        return rst;
    }
    
    public boolean hasNext() {
        return per != -1;
    }
}
```

# 5.2

## [591. 标签验证器](https://leetcode-cn.com/problems/tag-validator/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/591.png)

相比于解析`xml`，这个还是简单了一点。

整体上没什么难的地方，就是需要注意的点比较多。

首先要注意示例：

```
输入:"<A></A><B></B>"
输出: False
```

也就是在最外层一定有一个标签，包围了所有的内容。

我们使用一个栈，来维护遇到的标签，解析的过程中，遇到：`<`时，可以根据后一位的情况，判断遇到的时`TAG`或者`CDATA`

* 如果后一位是大写字母，说明可能为`TAG`的开始标签；更为具体的，需要向后找到`>`，如果期间遇到了小写字母或者，长度不满足要求，那么说明标签非法。如果是合法值，就让标签入栈。

* 如果后一位是`/`，说明可能为`TAG`的结束标签；这里的要求和上一个一样，此外，还需要看看栈顶是不是和当前标签一直，如果不一致，说明当前也是非法值。如果一致，那么栈顶出栈。
* 如果后一位是`!`，说明可能为`CDATA`。需要分别判断`CDATA`的开头和结尾
  * 开头：此时需要保证后面的字符格式满足`CDATA`的要求，即如果遇到了`<!`那么后面必须是`[CDATA[`，不然都是非法值
  * 结尾：这里结尾的形式是固定的，即必须为`]]>`，那么可以从当前位置向后找`>`，一旦找到再看看和前面两位能不能组成一个`]]>`
* 其余的情况为非法值

```java
class Solution {
    private static final String CDATA_BEGIN = "[CDATA[";
    private static final int CDATA_BEGIN_LEN = 7;
    private static final String CDATA_END = "]]>";
    private static final int CDATA_END_LEN = 3;
    public boolean isValid(String code) {
        Deque<String> tagStack = new LinkedList<>();
        int len = code.length();
        for (int i = 0; i < len; i++) {
            char c = code.charAt(i);
            if (c != '<') {
                // 如果不是以<开头的，说明是标签体，那么就要求栈中一定有标签
                if (tagStack.isEmpty()) return false;
                continue;
            }
            // 根据<的后一位，判断是CDATA，还是普通标签
            int left = i + 1;
            // 如果没有后一位，那肯定是非法值，注意，一定不能有单独的<存在，但可以有单独的>存在
            if (left >= len) return false;
            char sign = code.charAt(left);
            // 如果后一位是!，就判断是不是CDATA
            if (sign == '!') {
                // 如果是CDATA，说明外层一定要有一个标签
                if (tagStack.isEmpty()) return false;
                // 这一步就是检查CDATA的开头，注意如果遇到了<!，且还不是CDATA格式的，就一定是非法值
                int right = left + 1;
                if (right + CDATA_BEGIN_LEN > len || 
                   !code.substring(right, right + CDATA_BEGIN_LEN).equals(CDATA_BEGIN)) return false;
                // 这一部分就是检查CDATA的结尾，先找>，然后再看看前两位
                right += 7;
                int j = right;
                for (; j < len; j++) {
                    char cdata = code.charAt(j);
                    if (cdata == '>' && j - right + 1 >= CDATA_END_LEN && 
                    code.substring(j - CDATA_END_LEN + 1, j + 1).equals(CDATA_END)) break;
                }
                // 如果找不到，也是非法值
                if (j == len) return false;
                i = j;
            } else {
                // 如果后一位不是!，说明是标签体，此时根据后一位是不是/，判断是标签的开头还是结尾
                if (sign == '/') left++;
                int right = left;
                // 这一步就是获取标签的内容，left到right夹着的就是标签的内容
                while (right < len) {
                    char tagName = code.charAt(right);
                    if (tagName == '>') break;
                    if (tagName < 'A' || tagName > 'Z') return false;
                    right++;
                }
                int tagLen = right - left;
                if (right == len || tagLen > 9 || tagLen == 0) return false;
                String tag = code.substring(left, right);
                // 如果是开头，直接入栈，如果是结尾，根据栈顶判断非法值或者出栈
                if (sign == '/') {
                    if (tagStack.isEmpty() || !tagStack.pollLast().equals(tag)) return false;
                    // 这里需要注意就是为了应对最开始提到的那个示例，没到结尾，但栈已经空了，这是不允许的
                    if (tagStack.isEmpty() && right < len - 1) return false;
                } else {
                    tagStack.offerLast(tag);
                }
                i = right;
            }
        }
        // 返回的时候必须值空栈，不然说明标签不闭合
        return tagStack.isEmpty();
    }
}
```

# 5.7

## [456. 132 模式](https://leetcode-cn.com/problems/132-pattern/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/456.png)

我的思路是对于`i < j < k`，枚举`k`

这样，从前向后遍历的时候需要在`k`之前，找到距离`k`最近的，且大于`nums[k]`的数字，作为`j`，而贪心的找到距离`k`最远的，且小于`nums[k]`的数字，作为`i`

> 注意到，上面的距离`k`最远的，并不需要严格保证，事实上，仅需要其比`j`更远就行，这里是一种贪心的做法

所以第一个思路是简单的上指针：即枚举每个位置作为`k`，然后`j`指针从`k - 1`开始，找到第一个比`nums[k]`更大的，`i`指针从`0`开始，找到第一个比`nums[k]`更小的。

```java
class Solution {
    public boolean find132pattern(int[] nums) {
        for (int k = 0; k < nums.length; k++) {
            int left = -1;
            int right = -1;
            for (int i = 0; i < k; i++) {
                if (nums[i] < nums[k]) {
                    left = i;
                    break;
                }
            }
            for (int j = k - 1; j >= 0; j--) {
                if (nums[j] > nums[k]) {
                    right = j;
                    break;
                }
            }
            if (left != -1 && right > left) return true;
        }
        return false;
    }
}
```

显然，这么做的时间复杂度为$O(n^2)$，因为输入数据的范围为$2\times 10^5$，必然超时

所以现在需要进行优化，优化的点就是，在枚举`k`时，找到`j`和`i`的过程。

首先是找`j`的过程，因为要找到比当前位置更大的距离最近的元素，很容易联想到单调栈。这里维护一个单调递减的栈即可，栈顶位置即为比当前位置更大，且最近的元素。

然后是找`i`的过程，因为要找到，距离当前位置最远，且小于当前位置的元素，这里确实没有什么好的办法，主要是根据题目标签，看到了一个二分。然后可以维护一个单调递减的`list`，然后每次通过二分的方式，从这个`list`中找到比当前位置小的，最远的位置。

所以整体思路如下：

```java
class Solution {
	public boolean find132pattern(int[] nums) {
		// 单调减的栈和list
		Deque<Integer> stack = new LinkedList<>();
		List<Integer> list = new ArrayList<>();
		for (int k = 0; k < nums.length; k++) {
			int larger = -1;
			int smaller = -1;
            // 这里注意nums[k]等于栈顶的时候也出栈，因为是从前向后遍历的，对于下一个位置而言，当前位置距离它更近
            // 如果为了找到比下一个位置更大的位置，那么应该从当前位置开始考虑
			while (!stack.isEmpty() && nums[stack.peekLast()] <= nums[k]) stack.pollLast();
            // 经过若干次出栈后，栈顶就是比当前位置大，而距离当前位置最近的位置
			if (!stack.isEmpty()) larger = stack.peekLast();
            // 单调栈的老问题了，单调栈遍历到的每个位置都需要入栈，区别在于入栈前是不是需要出栈
			stack.offerLast(k);
            // 下面开始找i
			if (!list.isEmpty() && nums[list.get(list.size() -1)] < nums[k]) {
				int left = 0;
				int right = list.size() - 1;
				while(left < right) {
					int mid = left + ((right - left) >> 1);
					if (nums[list.get(mid)] >= nums[k]) {
						left = mid + 1;
					} else {
						right = mid;
					}
				}
				smaller = list.get(left);
			} else list.add(k);
			if (smaller != -1 && larger > smaller) return true;
		}
		return false;
	}
}
```

这样做的时间复杂度为$O(n\log n)$，能过，但是不是很好看

一个更好的方法可以做到$O(n)$的时间复杂度，主要参考[【宫水三叶の相信科学系列】详解为何使用「单调栈」来找最大的 K 是正确的](https://leetcode-cn.com/problems/132-pattern/solution/xiang-xin-ke-xue-xi-lie-xiang-jie-wei-he-95gt/)

它枚举的是`i`，从后向前遍历，仅仅维护了一个单调递减的栈。此外还维护了所有出栈的元素中的最大值作为`k`。

这里面比较关键的点在于，`k`一定比“栈顶”更大。因为只有出栈了，才有可能成为`k`，而出栈意味着必然存在入栈的位置比`k`更大

> 注意到这里的栈顶并不是严格意义上的栈顶。
>
> 一种可能的情况：栈为`[1, 2, 3, 4]`，`k`为`3`，此时栈顶为`1`，栈顶比`k`更小。
>
> 但是如果出现了这种情况，我可以保证，这个`k`的位置，一定比栈底的`4`更靠后。
>
> 即原来的数组可能为：`[1, 2, 3, 4, 3]`

这样，可以通过比较`nums[i]`和`k`的关系，确定`i,j,k`的三元组是否存在

> 因为只要满足了`i < k`，那么`j > k`的关系是单调栈自动就维护了的

```java
class Solution {
    public boolean find132pattern(int[] nums) {
        Deque<Integer> stack = new LinkedList<>();
        // 初始的k为非法值，这里就取无穷小即可
        int k = Integer.MIN_VALUE;
        for (int i = nums.length - 1; i >= 0; i--) {
            if (nums[i] < k) return true;
            while (!stack.isEmpty() && stack.peekLast() < nums[i]) {
                k = Math.max(k, stack.pollLast());
            }
            stack.offerLast(nums[i]);
        }
        return false;
    }
}
```

# 5.10

## [1728. 猫和老鼠 II](https://leetcode.cn/problems/cat-and-mouse-ii/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1728.png)

这个是[913-猫和老鼠](https://leetcode-cn.com/problems/cat-and-mouse/)的超级加倍，不过作为博弈论类型的题目是具有共性的，比如都适用dp或记忆化搜索的方式进行求解（这里的求解思路和913相同，采用了记忆化搜索），在比如都遵守了必胜和必输状态的规律

可以先看一下前题[913](./22_1.md#913-猫和老鼠)

首先，任何一个给定的初始状态（在双方都朝着利好自己的方向前进的情况下），谁可以获胜已经是定死的了。

然后，这里假设每个玩家移动一次称为一轮（注意不是两个玩家都移动才算一轮）

此外，还要注意在本题中和前题不太一样的点在于，本题不存在和局的情况，即一定有一个玩家可以获胜。

还有，以当前的两个玩家的位置和移动轮次三个维度可以确定游戏的状态，每一个状态有且仅有两个取值，即老鼠必胜或猫必胜。

朝着利好的方向移动，可以认为进行如下策略：在当前玩家可以移动的所有的下一个状态中

* 如果存在一个可以使得当前玩家必胜的状态，那么当前状态为当前玩家必胜
* 如果均为当前玩家必输的状态，那么当前状态为当前玩家必输

特别的，对于猫而言，其确定的必胜状态如下：

* 和老鼠在同一个格子
* 移动到食物格子
* 当前轮次超过了2000（注意，题目说了，如果老鼠不能在1000移动中到达终点，说时最多可以进行2000轮移动）

对于老鼠而言，其确定的必胜状态如下：

* 移动到食物格子

```java
class Solution {
    // 常量，四个移动方向
    private static final int[][] DIRECTIONS = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; 
    // 常量，最多进行2000轮移动
    private static final int maxTurns = 2000;
    // 自定义的常量，老鼠获胜状态为2，猫获胜状态为1
    private static final int CAT_WIN = 1;
    private static final int MOUSE_WIN = 2;
    private int row;
    private int col;
    private String[] grid;
    // 根据老鼠和猫的位置，以及当前轮次，三个维度确定的状态
    private int[][][] buffer;
    private int catJump;
    private int mouseJump;
    private int food;
    public boolean canMouseWin(String[] grid, int catJump, int mouseJump) {
        this.row = grid.length;
        this.col = grid[0].length();
        this.grid = grid;
        int total = row * col;
        this.buffer = new int[total][total][maxTurns + 1];
        this.catJump = catJump;
        this.mouseJump = mouseJump;
        int mouse = 0;
        int cat = 0;
        // 首先遍历一遍，找到老鼠、猫和食物的位置
        for (int i = 0; i < row; i++) {
            String rowString = grid[i];
            for (int j = 0; j < col; j++) {
                char block = rowString.charAt(j);
                if (block == 'C') {
                    cat = i * col + j;
                } else if (block == 'M') {
                    mouse = i * col + j;
                } else if (block == 'F') {
                    this.food = i * col + j;
                }
            }
        }
        // 记忆化搜索
        return dfs(mouse, cat, 1) == MOUSE_WIN;
    }

    private int dfs(int mouse, int cat, int turns) {
        // 如果当前状态已知，那么直接返回
        if (buffer[mouse][cat][turns] != 0) return buffer[mouse][cat][turns];
        // 如果满足了三个条件中的一个，那么当前状态为猫获胜
        if (turns == maxTurns || mouse == cat || cat == food) {
            buffer[mouse][cat][turns] = CAT_WIN;
            return CAT_WIN;
        }
        // 如果老鼠移动到食物格子，那么老鼠获胜
        if (mouse == food) {
            buffer[mouse][cat][turns] = MOUSE_WIN;
            return MOUSE_WIN;
        }
        // 如果当前轮次为奇数，说明是老鼠移动的轮次，否则是猫移动的轮次
        if ((turns & 1) == 1) {
            // 这里默认先假设当前状态为猫必胜
            buffer[mouse][cat][turns] = CAT_WIN;
            // 这里判断当前老鼠不移动，有没有可能获胜
            if (dfs(mouse, cat, turns + 1) == MOUSE_WIN) {
                buffer[mouse][cat][turns] = MOUSE_WIN;
                return buffer[mouse][cat][turns];
            }
            // 获取老鼠的坐标
            int[] position = getPos(mouse);
            for (int[] direction : DIRECTIONS) {
                int mx = position[0];
                int my = position[1];
                // 老鼠可以朝着一个方向移动最多mouseJump步
                for (int i = 0; i < mouseJump; i++) {
                    mx += direction[0];
                    my += direction[1];
                    if (mx >= 0 && mx < row && my >= 0 && my < col && grid[mx].charAt(my) != '#') {
                        int state = dfs(mx * col + my, cat, turns + 1);
                        if (state == MOUSE_WIN) {
                            buffer[mouse][cat][turns] = MOUSE_WIN;
                            return buffer[mouse][cat][turns];
                        }
                      // 注意这个else用来剪枝
                    } else break;
                }
            }
        } else {
            buffer[mouse][cat][turns] = MOUSE_WIN;
            if (dfs(mouse, cat, turns + 1) == CAT_WIN) {
                buffer[mouse][cat][turns] = CAT_WIN;
                return buffer[mouse][cat][turns];
            }
            int[] position = getPos(cat);
            for (int[] direction : DIRECTIONS) {
                int mx = position[0];
                int my = position[1];
                for (int i = 0; i < catJump; i++) {
                    mx += direction[0];
                    my += direction[1];
                    if (mx >= 0 && mx < row && my >= 0 && my < col && grid[mx].charAt(my) != '#') {
                        int state = dfs(mouse, mx * col + my, turns + 1);
                        if (state == CAT_WIN) {
                            buffer[mouse][cat][turns] = CAT_WIN;
                            return buffer[mouse][cat][turns];
                        }
                    } else break;
                }
            }
        }
        return buffer[mouse][cat][turns];
    }
    private int[] getPos(int total) {
        return new int[]{total / col, total % col};
    }
}
```

# 5.14

## [691. 贴纸拼词](https://leetcode.cn/problems/stickers-to-spell-word/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/691.png)

从数据范围的大小：`1 <= target <= 15、1 <= sticker.length <= 50、1 <= sticker[i].length <= 10`，基本上就可以确定，这个应该是爆搜，优化的话，就是记忆化搜索

一种可行的方案：因为`target`长度最大为15，考虑状态压缩，设掩码为`i`，那么`dp[i]`表示使用`stickers`，构造掩码为`i`时，使用的最小的数量，其中`i`的低`target.length`位有效。

假设`target`长度为`length`，那么代求量为$dp[2 ^{length} -  1]$

> 要注意的是`dp`和记忆化搜索并不矛盾，只是一个是自底向上搜索，而一个是自顶向下搜索

这里使用的方案是记忆化搜索：

```java
class Solution {
	private int[] buffer;
	private String target;
	private String[] stickers;
	public int minStickers(String[] stickers, String target) {
        int len = 1 << target.length();
		this.buffer = new int[len];
		Arrays.fill(buffer, -1);
		this.target = target;
		this.stickers = stickers;
		buffer[0] = 0;
        int rst = dfs(len - 1);
        // 如果返回的rst值很大，那么显然误解
		return rst > target.length() ? -1 : rst;
	}

	private int dfs(int mask) {
		if (buffer[mask] != -1) return buffer[mask];
        // 如果有解，那么rst最大值为target.length()，这里先是假设无解
		int rst = target.length() + 1;
		for (String sticker : stickers) {
            // 变量match表示stickers[i]和mask的交集(match本身也是掩码)
			int match = 0;
            // 计算词频，这里本d使用map加速查找，但是居然变慢了
            int[] freq = new int[26];
            for (int i = 0; i < sticker.length(); i++) freq[sticker.charAt(i) - 'a']++;
            for (int i = 0; i < target.length(); i++) {
                int c = target.charAt(i) - 'a';
                if (((mask >> i) & 1) == 1 && freq[c] > 0) {
                    freq[c]--;
                    match += 1 << i;
                }
            }
			if (match == 0) continue;
			rst = Math.min(rst, 1 + dfs(mask - match));
		}
		buffer[mask] = rst;
		return buffer[mask];
	}
}
```

# 5.15

## [812. 最大三角形面积](https://leetcode.cn/problems/largest-triangle-area/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/812.png)

从数据范围来看，其实可以枚举，最多50个点，枚举三次，时间复杂度也不过$10^5$级别

最关键的在于给定坐标，求出三角形面积，假设三角形坐标为：$(x_1, y_1)、(x_2, y_2)、(x_3, y_3)$，那么围成的面积可以表示为：$S_{\Delta} = \frac{1}{2}\begin{Vmatrix}x_1&y_1&1\\x_2&y_2&1\\x_3&y_3&1\end{Vmatrix}$

> 行列式的绝对值

编码的话其实很好写：

```java
class Solution {
    public double largestTriangleArea(int[][] points) {
        int n = points.length;
        double ret = 0.0;
        for (int i = 0; i < n - 2; i++) {
            for (int j = i + 1; j < n - 1; j++) {
                for (int k = j + 1; k < n; k++) {
                    ret = Math.max(ret, square(points[i], points[j], points[k]));
                }
            }
        }
        return ret;
    }

    private double square(int[] a, int[] b, int[] c) {
        return Math.abs(a[0] * b[1] + b[0] * c[1] + a[1] * c[0] - b[1] * c[0] - a[0] * c[1] - a[1] * b[0]) / 2;
    }
}
```

# 5.18

## tarjan

一个用来找割点集和桥的算法，有两个关键的数组：`dfn`和`low`

其中`dfn`表示第一次访问到某节点的时间；`low`表示从该点开始可以到达的最早的点。默认的情况下`dfn[i] == low[i] == idx`

> 这里的`idx`是一个全局变量

今天的`1192`就是一个模板题，是来求桥的

## [1192. 查找集群内的「关键连接」](https://leetcode.cn/problems/critical-connections-in-a-network/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1192.png)

这里面的判断逻辑都是定死的，进行`dfs`遍历的时候，因为这里是无向图，需要明确，无向图中两个相邻的节点是不能构成环路的，所以为了排除这种情况，`dfs`的参数中存在一个父节点。

即根据`dfn`是否为`-1`判断当前边的终点是否已经访问过

如果没有访问过：需要进行`dfs`遍历，并通过`low[u]`和`low[v]`来更新`low[u]`

如果已经访问过：通过`low[u]`和`dfn[v]`来更新`low[u]`

> 参考：[史上最清晰的Tarjan算法详解](https://segmentfault.com/a/1190000039149539)
>
> 不过目前看到的，并没有用上栈

```java
class Solution {
    private int[] head;
    private int[] edges;
    private int[] next;
    private int[] dfn;
    private int[] low;
    private List<List<Integer>> rst;
    private int index;
    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {
        int len = connections.size() * 2;
        this.head = new int[n];
        this.edges = new int[len];
        this.next = new int[len];
        Arrays.fill(head, -1);
        int idx = 0;
        for (List<Integer> connection : connections) {
            edges[idx] = connection.get(1);
            next[idx] = head[connection.get(0)];
            head[connection.get(0)] = idx++;

            edges[idx] = connection.get(0);
            next[idx] = head[connection.get(1)];
            head[connection.get(1)] = idx++;
        }
        this.dfn = new int[n];
        this.low = new int[n];
        this.index = 0;
        // 初始化dfn数组，默认均为-1，表示未访问过
        Arrays.fill(dfn, -1);
        this.rst = new ArrayList<>();
        dfs(0, -1);
        return rst;
    }

    private void dfs(int per, int parent) {
        dfn[per] = index;
        low[per] = index;
        index++;
        for (int edge = head[per]; edge != -1; edge = next[edge]) {
            int end = edges[edge];
            // 排除邻节点
            if (end == parent) continue;
            if (dfn[end] == -1) {
                dfs(end, per);
                low[per] = Math.min(low[per], low[end]);
                // 只要在dfs之后，还有low[end] > dfn[per]就可以说明存在b
                if (low[end] > dfn[per]) {
                   List<Integer> connection = new ArrayList<>();
                   connection.add(per);
                   connection.add(end);
                   rst.add(connection); 
                }
            } else low[per] = Math.min(low[per], dfn[end]);
        }
    }
}
```

# 5.19

## [453. 最小操作次数使数组元素相等](https://leetcode.cn/problems/minimum-moves-to-equal-array-elements/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/453.png)

这个题正向考虑有点麻烦，可以反向考虑，即让`n - 1`个元素增加`1`，等效为让`1`个元素减去`1`

这样，我们发现所有可以进行的操作只有减法，在这种情况下，如果希望可以让数组中的元素都相等，最少的操作次数就是让所有元素都等于数组中最小的元素。

```java
class Solution {
    public int minMoves(int[] nums) {
        int min = Integer.MAX_VALUE;
        for (int num : nums) min = Math.min(min, num);
        int rst = 0;
        for (int num : nums) rst += num - min;
        return rst;
    }
}
```

## [462. 最少移动次数使数组元素相等 II](https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/462.png)

这个题相比于上个题，存在加和减两种操作。

这个题目，不需要具体确认到底最终相等的取值，具体的可以参考[官方题解](https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/solution/zui-shao-yi-dong-ci-shu-shi-shu-zu-yuan-xt3r2/)，证明很详细。

首先将数组排序，然后令元素首尾相接构成区间，考虑偶数长度数组(假设长度为`2n`)，首尾匹配形成`n`个区间，具体的区间为：`(nums[0], nums[2n - 1])`、`(nums[1], nums[2n - 2])`...`(nums[n - 1], nums[n])`，那么**当最终取值为包含在所有区间内部时，可以保证变化的次数最小**，且变化次数为所有区间的区间长度和

```java
class Solution {
    public int minMoves2(int[] nums) {
        Arrays.sort(nums);
        int i = 0;
        int j = nums.length - 1;
        int rst = 0;
        while (i < j) rst += nums[j--] - nums[i++];
        return rst;
    }
}
```

# 5.20

## [436. 寻找右区间](https://leetcode.cn/problems/find-right-interval/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/436.png)

排序，之后二分查找即可

> 因为需要获取的是坐标，所以使用map建立`start`到`index`的映射关系
>
> 因为题目说了`start`各不相同，所以键就直接使用`intarval[0]`表示即可

```java
class Solution {
    public int[] findRightInterval(int[][] intervals) {
        int len = intervals.length;
        int[] rst = new int[len];
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < len; i++) map.put(intervals[i][0], i);
        int[][] buff = new int[len][2];
        for (int i = 0; i < len; i++) {
            buff[i][0] = intervals[i][0];
            buff[i][1] = intervals[i][1];
        } 
        Arrays.sort(buff, (nums1, nums2) -> nums1[0] - nums2[0]);
        for (int i = 0; i < len; i++) {
            int target = intervals[i][1];
            int left = 0;
            int right = len - 1;
            while (left < right) {
                int mid = left + ((right - left) >> 1);
                if (buff[mid][0] < target) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            if (buff[left][0] >= target) {
                rst[i] = map.get(buff[left][0]);
            } else rst[i] = -1;
        }
        return rst;
    }
}
```

## [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/406.png)

先不考虑身高重复的情况，那么对于最矮的那个人（假设为`people[i]`），它的位置一定是数组中的`people[i][1]`位置，因为不管其他人怎么排，都比他高，所以最矮的人可以按照自身`people[i][1]`在整个数组中进行排序

排除掉最矮的人，次矮的人需要根据其`people[i][1]`在所有未被选择的位置中选择一个，具体的操作和上面一样，只不过需要排除被最矮的人已经占用的位置

后面的依次类推

然后考虑一下，如果出现了身高重复的情况应该怎么办，假设最矮的人有两个，分别为`people[i]`和`peolpe[j]`，且满足`people[i][1] > people[j][1]`；这个时候应该先排`people[i]`，因为它前面的人更多，先排`people[i]`完全不会影响`people[j]`的排序；但如果反过来，先排`people[j]`会导致其占用一个位置，而后排序`people[i]`的时候就需要同时考虑空位置和已占用位置中和自己同身高的影响，相对比较麻烦

所以现在我们可以对所有的`people`先按照身高从小到大排序，身高相同时，按照前面的人数，从大到小排序

然后在所有空位中，按照`people`数组中第二个维度进行排位

```java
class Solution {
	public int[][] reconstructQueue(int[][] people) {
		int len = people.length;
		int[][] rst = new int[len][2];
		for (int i = 0; i < len; i++) Arrays.fill(rst[i], -1);
		Arrays.sort(people, (nums1, nums2) -> {
            if (nums1[0] == nums2[0]) return nums2[1] - nums1[1];
            return nums1[0] - nums2[0];
        });
		for (int[] person : people) {
            int count = 0;
			for (int j = 0; j < len; j++) {
				if (rst[j][0] == -1) {
					if (count == person[1]) {
						rst[j][0] = person[0];
						rst[j][1] = person[1];
						break;
					}
					count++;
                }
			}
		}
		return rst;
	}
}
```

可以看到上述的时间复杂度主要集中在找位置上，因为是通过遍历找的位置，所以找位置的时间复杂度为$O(n^2)$

这种单调的找位置其实是可以通过二分查找将时间优化为$O(n\log n)$

简言之，找位置是找到所有空闲位置中的第`i`个；那么可以这么考虑：假设现在有一个数组长度和`people`一样，所有已经占用的位置为`1`，未占用的位置为`0`，那么此时考虑数组的前缀和，他将具有单调性，有了单调性，就说明了二段性，从而可以进行二分。而后我们安排人的时候需要改写这个数组，所以我们现在的需求是，前缀和数组，单点修改，求出前缀和，并利用这个前缀和进行二分。

所以答案已经呼之欲出了，使用树状数组和二分加速查找

因为树状数组下标的特性，我们让其有效下标从1开始，到`people.length`结束

举一个简单的例子，比如说对于`people[i] = {4, 4}`，需要明确的是初始化二分查找的左边界为`1`，右边界为`people.length`，我们要找一个位置`mid`，在`[1, mid]`中一共存在`5`个0，其中`mid`位置为第`5`个0，那么一共具有`mid - 5`个1，我们计算`mid`的前缀和，如果大于`mid - 5`，说明`0`的个数不足，此时需要扩展左边界

```java
class Solution {
	public int[][] reconstructQueue(int[][] people) {
		int len = people.length;
		int[][] rst = new int[len][2];
		int[] order = new int[len + 1];
		for (int i = 0; i < len; i++) Arrays.fill(rst[i], -1);
		Arrays.sort(people, (nums1, nums2) -> {
			if (nums1[0] == nums2[0]) return nums2[1] - nums1[1];
			return nums1[0] - nums2[0];
		});
		for (int[] person : people) {
			int left = 1;
			int right = len;
			while (left < right) {
				int mid = left + ((right - left) >> 1);
				if (mid -getSum(order, mid) > mid - (person[1] + 1)) {
					left = mid + 1;
				} else {
					right = mid;
				}
			}
			rst[left - 1][0] = person[0];
			rst[left - 1][1] = person[1];
			add(order, left);
		}
		return rst;
	}

	private void add(int[] order, int index) {
		int limit = order.length;
		while (index < limit) {
			order[index] += 1;
			index += lowbit(index);
		}
	}

	private int getSum(int[] order, int index) {
		int rst = 0;
		while (index > 0) {
			rst += order[index];
			index -= lowbit(index);
		}
		return rst;
	}

	private int lowbit(int index) {
		return index & (-index);
	}
}
```

## [1371. 每个元音包含偶数次的最长子字符串](https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1371.png)

一开始可以说是一点思路没有，只有暴力枚举，看了一眼提示，说可以适用bitmask统计元音字母出现了偶数次还是奇数次，还看到了preSum关键字

顿时想到了，可以这么做：从前向后遍历，计算bitmask的前缀和（通过异或运算，因为我们只需要分清是奇数还是偶数，所以1位就够了），当bitmask为0时表示从开头到当前位置这么长的字符串中元音字符出现了偶数次，更进一步的，对于区间`[i, j]`可以适用容斥原理获得这个区间的bitmask，然后使用一个`map`存储第一次出现了`bitmask`的位置，如果再次计算到相同的`bitmask`，让`rst`更新值

```java
class Solution {
    private static final Map<Character, Integer> map;
    static {
        // a,e,i,o,u分别表示了bitmask中的第1-5位
        map = new HashMap<>();
        map.put('a', 0);
        map.put('e', 1);
        map.put('i', 2);
        map.put('o', 3);
        map.put('u', 4);
    }
    public int findTheLongestSubstring(String s) {
        int len = s.length();
        // bitmask的前缀和数组
        int[] preSum = new int[len + 1];
        int rst = 0;
        // 记录bitmask第一次出现位置的map
        Map<Integer, Integer> bitMap = new HashMap<>();
        // 前0个字符，显然bitmask为0
        bitMap.put(0, 0);
        for (int i = 1; i <= len; i++) {
            int bit = map.getOrDefault(s.charAt(i - 1), -1);
            preSum[i] = preSum[i - 1];
            if (bit != -1) {
                preSum[i] = preSum[i - 1] ^ (1 << bit);
            }
            if (bitMap.containsKey(preSum[i])) {
                rst = Math.max(rst, i - bitMap.get(preSum[i]));
            } else {
                bitMap.put(preSum[i], i);
            }
        } 
        return rst;
    }
}
```

显然上述可以进行优化，首先是`preSum`数组，这个数组好像确实没什么用，因为每次只取前一位的值，然后运算，所以降维

```java
class Solution {
    private static final Map<Character, Integer> map;
    static {
        map = new HashMap<>();
        map.put('a', 0);
        map.put('e', 1);
        map.put('i', 2);
        map.put('o', 3);
        map.put('u', 4);
    }
    public int findTheLongestSubstring(String s) {
        int len = s.length();
        int mask = 0;
        int rst = 0;
        Map<Integer, Integer> bitMap = new HashMap<>();
        bitMap.put(0, 0);
        for (int i = 1; i <= len; i++) {
            int bit = map.getOrDefault(s.charAt(i - 1), -1);
            if (bit != -1) mask ^= (1 << bit);
            if (bitMap.containsKey(mask)) {
                rst = Math.max(rst, i - bitMap.get(mask));
            } else bitMap.put(mask, i);
        } 
        return rst;
    }
}
```

然后是`map`，这个用来记录`bitmask`的表，很多的优化都是把`map`变为了数组，这里也是一样，因为`5`位的`bitmask`，所以最多也就`32`个数组，完全可以使用一个数组记录`bitmask`第一次出现的位置

```java
class Solution {
    private static final Map<Character, Integer> map;
    static {
        map = new HashMap<>();
        map.put('a', 0);
        map.put('e', 1);
        map.put('i', 2);
        map.put('o', 3);
        map.put('u', 4);
    }
    public int findTheLongestSubstring(String s) {
        int len = s.length();
        int mask = 0;
        int rst = 0;
        int[] bitMap = new int[1 << 5];
        Arrays.fill(bitMap, -1);
        bitMap[0] = 0;
        for (int i = 1; i <= len; i++) {
            int bit = map.getOrDefault(s.charAt(i - 1), -1);
            if (bit != -1) mask ^= (1 << bit);
            if (bitMap[mask] != -1) {
                rst = Math.max(rst, i - bitMap[mask]);
            } else bitMap[mask] = i;
        } 
        return rst;
    }
}
```

# 5.21

## [1248. 统计「优美子数组」](https://leetcode.cn/problems/count-number-of-nice-subarrays/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1248.png)

这个题的解题思路其实来自于实例`3`，看他这个输入，只有两个奇数，所以不管子数组是怎么样的，都必须包括：`[1,2,2,1]`

而左侧的三个`2`可选的个数为`0~3`，右侧的三个`2`可选的个数为`0~3`，所以一共可选的数组为：`4 x 4 = 16`种

我就想着，是不是可以使用一个数组保存所有奇数位置的下标，然后使用滑动串口，保证窗口大小为`k`，窗口的左右边界其实是结果集中的最左和最右边界，然后看一下左边界向左可以扩展的最远位置和向右可以扩展的最远位置，然后通过上面乘积的形式更新结果集

```java
class Solution {
    public int numberOfSubarrays(int[] nums, int k) {
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            if ((nums[i] & 1) == 1) list.add(i);
        }
        int rst = 0;
        // left 和 right 确定了一个大小为 k 的窗口
        int left = 0;
        int right = k - 1;
        while (right < list.size()) {
            // 找到子数组的最左边界
            int l = list.get(left) - (left > 0 ? list.get(left - 1) : -1);
            // 找到子数组的最y边界
            int r = (right < list.size() - 1 ? list.get(right + 1) : nums.length) - list.get(right);
            rst += l * r;
            right++;
            left++;
        }
        return rst;
    }
}
```



# 5.25

## [467. 环绕字符串中唯一的子字符串](https://leetcode.cn/problems/unique-substrings-in-wraparound-string/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/467.png)

可以使用一个数组`dp`统计以`p`中每个位置`p[i]`结尾的最长的字串的长度，最大的问题在于重复

提示中一个比较关键的地方：使用一个`26`大小的数组进行统计

所以结论是：使用`dp`和`rst`两个数组进行统计，其中`dp`长度为`p.length()`，而`rst`长度为`26`

更为具体的，当`dp`统计好`p[i]`的最长长度后，在`rst`中对应的字母处进行更新：`rst[i] = Math.max(rst[i], dp[p[i]])`

通过更新以某个字母结尾的最大长度的方式进行去重

在具体的实现上，其实并不需要更新`dp`数组，使用$O(1)$的空间维护一个变量`length`即可

```java
class Solution {
	public int findSubstringInWraproundString(String p) {
		int[] rst = new int[26];
		int len = p.length();
		int length = 1;
		rst[p.charAt(0) - 'a'] = 1;
		for (int i = 1; i < len; i++) {
			int per = p.charAt(i) - 'a';
			int pre = p.charAt(i - 1) - 'a';
			if ((pre + 1) % 26 == per) {
                length++;
            } else {
                length = 1;
            }
			rst[per] = Math.max(rst[per], length);
		}
		return Arrays.stream(rst).sum();
	}
}
```

## LIS问题

这个问题的一般性解法为`dp`，并设`dp[i]`表示以`nums[i]`结尾的最长上升子序列的长度，时间复杂度为$O(n^2)$

更好的解法是贪心的解法，设`dp[i]`表示长度为`i`的子序列中，最小的结尾，时间复杂度为$O(n\log n)$

母题为[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/300.png)

最直观的思路是，进行`dp`，`dp[i]`表示以`i`结尾的最长递增子序列，然后对于每个位置，向前找到可以承接的最长的子序列：

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        int[] dp = new int[len];
        int rst = 0;
        for (int i = 0; i < len; i++) {
            dp[i] = 1;
            int pre = 0;
            for (int j = i - 1; j >= 0; j--) {
                if (nums[j] < nums[i]) {
                    pre = Math.max(pre, dp[j]);
                }              
            }
            dp[i] += pre;
            rst = Math.max(rst, dp[i]);
        }
        return rst;
    }
}
```

这样做下来时间复杂度为$O(n^2)$

`LIS`问题，简单思路的解法都是$O(n^2)$，不过对于这类问题，存在一种贪心的解法，可以让时间复杂度降低为$O(n\log n)$

贪心的想法是在满足后一个数大于前一个数后，让后一个数尽可能小，因为只有这样才可以实现最长

还是维护一个长度为`nums.length`的数组，只不过，现在`dp[i]`表示的不在是某个位置结尾的长度了，而是长度为为`i + 1`的递增子序列中结尾的最小值，比如`dp[0]`表示所有长度为1的递增子序列，其尾部的最小值

> 这个数组一定是单调递增的，即对于任意的下标`i < j`，一定有`dp[i] < dp[j]`
>
> 反证法证明：假设存在下标`i < j`，使得有：$dp[i] \geq dp[j]$，那么一定有一个长为`i + 1`的递增子序列，假如说为：$a_0, a_1,...,a_i$，还一定有一个长为`j + 1`的递增子序列，假如说为$b_0, b_1,...,b_j$，且一定有$a_i \geq b_j$
>
> 因为`i < j`，所以在`b`序列中一定存在$b_i$，且一定有：$b_i < b_j\leq a_i$
>
> 因为`dp[i]`的定义为长度为`i`的递增子序列中尾部的最小值，但此时$b_i < a_i$，和定义矛盾
>
> 所以假设不成立，这个数组一定是一个严格单调增的数组

要注意的是最后得到的`dp`数组仅表示状态，`dp[i]`表示了长度为`i + 1`的`LIS`的结尾的最小值，而整体的`dp`数组并不是需要求得的`LIS`

实际中使用一个`end`维护`dp`数组真正的长度，然后对于新的位置，如果比`dp[end]`大，那么就更新结尾，否则，二分的形式找到`dp`中第一个比`nums[i]`更大的地方进行更新

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        // end 表示最后一个有效下标，默认的话让dp[0]为nums[0]，因此end为0
        int end = 0;
        int len = nums.length;
        int[] dp = new int[len];
        dp[0] = nums[0];
        for (int i = 1; i < len; i++) {
            // 根据nums[i]和dp[end]的关系进行更新或差值
            if (nums[i] == dp[end]) continue;
            if (nums[i] > dp[end]) {
                dp[++end] = nums[i];
            } else {
                int left = 0;
                int right = end;
                while (left < right) {
                    int mid = left + ((right - left) >> 1);
                    if (dp[mid] < nums[i]) {
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
                dp[left] = nums[i];
            }
        }
        return end + 1;
    }
}
```

### [334. 递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/334.png)

解法和上面完全一样，且更简单，数组大小开到3即可

```java
class Solution {
    public boolean increasingTriplet(int[] nums) {
        int len = nums.length;
        int[] dp = new int[3];
        int end = 0;
        dp[0] = nums[0];
        for (int i = 1; i < len; i++) {
            if (nums[i] == dp[end]) continue;
            if (nums[i] > dp[end]) {
                dp[++end] = nums[i];
                if (end == 2) return true;
            } else {
                int left = 0;
                int right = end;
                while (left < right) {
                    int mid = left + ((right - left) >> 1);
                    if (dp[mid] < nums[i]) {
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
                dp[left] = nums[i];
            }
        }
        return false;
    }
}
```

### [354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/354.png)

主要参考：[官方题解](https://leetcode.cn/problems/russian-doll-envelopes/solution/e-luo-si-tao-wa-xin-feng-wen-ti-by-leetc-wj68/)

这个题，因为同时需要考虑两个维度上的大小关系，比较麻烦，比较直观的做法是排序，这里假设按照`envelopes`中的第一个维度进行排序(假设有：`envelopes[i] = {a, b}`)，那么排序之后满足了：$a_0 \leq a_1\leq a_2\leq ... \leq a_n$

注意这里可能出现`a`大小重复的信封，如果题目可以保证`a`是唯一的，即如果有：$a_0 < a_1 < a_2 < ... < a_n$那么此时对`b`求`LIS`得到的就是最多可以嵌套的信封个数

然而题目并不能保证`a`的唯一性，典型的输入：`{{1, 1}, {1, 2}, {1, 3}, {1, 4}}`，如果按照上面的方式求解得到的包裹的信封数为4，而实际的信封数仅为`1`；问题就出现在了实际信封的第一个维度可能重复，不过这也引出了：**实际第一个维度`a`相同的信封最多仅可能取1个**

题解的做法是，在第一个维度相同的情况下，根据第二个维度降序排序，这种做法保证了，不会出现第一个维度相同的在计算`LIS`的时候被多次计数

注意此时`LIS`的求法和上面贪心的写法完全一致，不过此时`dp[i]`仅表示在长度为`i + 1`的子序列中，第二个维度最小的大小

```java
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        Arrays.sort(envelopes, (nums1, nums2) -> {
            if (nums1[0] == nums2[0]) return nums2[1] - nums1[1];
            return nums1[0] - nums2[0];
        });
        int len = envelopes.length;
        int[] dp = new int[len];
        dp[0] = envelopes[0][1];
        int end = 0;
        for (int i = 1; i < len; i++) {
            if (envelopes[i][1] == dp[end]) continue;
            if (envelopes[i][1] > dp[end]) {
                dp[++end] = envelopes[i][1];
            } else {
                int left = 0;
                int right = end;
                while (left < right) {
                    int mid = left + ((right - left) >> 1);
                    if (dp[mid] < envelopes[i][1]) {
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
                dp[left] = envelopes[i][1];
            }
        }
        return end + 1;
    }
}
```

### 将 LCS 问题转化为 LIS 问题

这里说的是[1713. 得到子序列的最少操作次数](https://leetcode.cn/problems/minimum-operations-to-make-a-subsequence/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1713.png)

直观上来看，应该是 LCS 问题，找到两个子序列的最大公共长度就行了，一般的 LCS 问题，做法是 构造一个二维的 dp 数组，时间复杂度和空间复杂度都是 O(m x n)，但这个题输入范围为 $10^5$，一试就发现会报 MLE

参考[LCS 问题与 LIS 问题的相互关系](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247487814&idx=1&sn=e33023c2d474ff75af83eda1c4d01892&chksm=fd9cba59caeb334f1fbfa1aefd3d9b2ab6abfccfcab8cb1dbff93191ae9b787e1b4681bbbde3&token=252055586&lang=zh_CN#rd)，可以发现对于 LCS 问题，如果可以保证两个输入序列中的一个的字符是不重复的，可以将 LCS 问题变为 LIS 问题，LIS 问题的一般性解法时间复杂度还是 $O(n^2)$，还是过不了，但是在他还有一个贪心的做法，可以在 $O(n\log n)$ 的时间内解决

这里主要说一下，为什么当两个序列中的一个，只要满足了字符不重复，就可以将 LCS 问题转化为 LIS 问题；以上题中的 target 和 arr 说明，target 中的元素不重复，那么可以建立 target[i] 和 i 的一一映射，而对于数组而言 i 是单调递增的；那么任何一个 target 和 arr 的公共子序列就可以等效为 target 的下标索引上升子序列

```java
class Solution {
    public int minOperations(int[] target, int[] arr) {
        int len1 = target.length;
        int len2 = arr.length;
        int[] dp = new int[len1];
        // 建立映射关系
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < len1; i++) map.put(target[i], i);
        // LIS 贪心解法
        int end = -1;
        for (int i = 0; i < len2; i++) {
            if (map.containsKey(arr[i])) {
                int val = map.get(arr[i]);
                if (end == -1 || dp[end] < val) {
                    dp[++end] = val;
                } else {
                    int left = 0;
                    int right = end;
                    while (left < right) {
                        int mid = left + ((right - left) >> 1);
                        if (dp[mid] < val) {
                            left = mid + 1;
                        } else {
                            right = mid;
                        }
                    }
                    dp[right] = val;
                }
            }
        }
        return len1 - (end + 1);
    }
}
```

# 5.26

## 值域爆炸，查询区间有限

对应查的是：[【线段树专题】求解常见「值域爆炸，查询有限」区间问题的几种方式](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247491187&idx=2&sn=bb2d8b7e89c535914da8107387e951a2)

简单来说，这类题目的共性是数组的取值范围很大，而实际查询的次数很小

首先来一个单点更新的

### [933. 最近的请求次数](https://leetcode.cn/problems/number-of-recent-calls/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/933.png)

这个题的输入范围如下

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/933_1.png)

首先这个题比较好的解法其实是使用一个队列，这个题限定的很死，限制了单点更新中的时间 t 为单调递增的，且查询区间的长度也是固定的 3000

先来一个队列的：

```java
class RecentCounter {
    private Queue<Integer> queue;
    private static final int GAP = 3000;

    public RecentCounter() {
        this.queue = new LinkedList<>();
    }
    
    public int ping(int t) {
        queue.offer(t);
        int top = t - GAP;
        while (queue.peek() < top) queue.poll();
        return queue.size();
    }
}

/**
 * Your RecentCounter object will be instantiated and called as such:
 * RecentCounter obj = new RecentCounter();
 * int param_1 = obj.ping(t);
 */
```

这个解法不仅代码量少，而且快，不过这里为了说明下面还是讨论线段树的写法，虽说单点更新区间求和使用树状数组比较方便，但是树状数组并不知道有什么动态开点的写法，所以这里使用的是线段树，因为是单点更新，就不需要使用 lazy 标记了

```java
class RecentCounter {
    // 输入上限
    private static final int N = 1000000000;
    // 节点数量上限
    private static final int M = 1000000;
    // 查询的区间大小
    private static final int GAP = 3000;
    private Node[] tree;
    private int count;

    public RecentCounter() {
        this.count = 1;
        this.tree = new Node[M];
        // 初始化根节点
        tree[1] = new Node();
    }
    
    private void update(int idx, int left, int right, int target, int val) {
        if (left == target && right == target) {
            // 因为保证了 t 是单调递增的，甚至不需要写成 val += val，直接赋值就行
            tree[idx].val = val;
            return;
        }

        createNode(idx);

        int mid = left + ((right - left) >> 1);
        if (target <= mid) update(tree[idx].left, left, mid, target, val);
        if (target > mid) update(tree[idx].right, mid + 1, right, target, val);

        tree[idx].val = tree[tree[idx].left].val + tree[tree[idx].right].val;
    }

    private int query(int idx, int left, int right, int begin, int end) {
        if (left >= begin && right <= end) return tree[idx].val;

        createNode(idx);

        int mid = left + ((right - left) >> 1);
        int rst = 0;
        if (begin <= mid) rst += query(tree[idx].left, left, mid, begin, end);
        if (end > mid) rst += query(tree[idx].right, mid + 1, right, begin, end); 
        return rst;
    }

    private void createNode(int idx) {
        
        if (tree[idx].left == 0) {
            tree[idx].left = ++count;
            tree[tree[idx].left] = new Node();
        }

        if (tree[idx].right == 0) {
            tree[idx].right = ++count;
            tree[tree[idx].right] = new Node();
        }
    }

    public int ping(int t) {
        update(1, 1, N, t, 1);
        return query(1, 1, N, Math.max(1, t - GAP), t);
    }
}

class Node {
    int left;
    int right;
    int val;
}

/**
 * Your RecentCounter object will be instantiated and called as such:
 * RecentCounter obj = new RecentCounter();
 * int param_1 = obj.ping(t);
 */
```

下面给出一个正经的区间更新的例子

### [729. 我的日程安排表 I](https://leetcode.cn/problems/my-calendar-i/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/729.png)

简单的理解为区间更新，区间查询，值得注意的是它的输入范围

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/729_1.png)

可以看到输入的范围大小达到了$10^9$，如果使用简单的树状数组或者线段树实现区间更新，显然是会 OOM 的

不过好在它的方法调用次数为 1000 次，很少所以我们可以采用完全模拟的方法统计

```java
class MyCalendar {
    private List<int[]> list;
    
    public MyCalendar() {
        this.list = new ArrayList<>();
    }
    
    public boolean book(int start, int end) {
        for(int i = 0; i < list.size(); i++){
            int[] tmp = list.get(i);
            // 注意存储的区间是左闭右开
            if (start >= end || end <= l) continue;
            return false;
        }
       	list.add(new int[]{start, end});
        return true;
    }
}

/**
 * Your MyCalendar object will be instantiated and called as such:
 * MyCalendar obj = new MyCalendar();
 * boolean param_1 = obj.book(start,end);
 */
```

这种解法的时间复杂度为$O(n^2)$

这种暴力枚举太费时间了，事实上我们只需要知道距离当前插入的安排最近的有没有冲突，就可以知道实际冲突情况了，这里使用红黑树加速查找

> 本质上是利用了有序集合的性质

```java
class MyCalendar {
    private TreeMap<Integer, Integer> map;
    public MyCalendar() {
        this.map = new TreeMap<>();
    }
    
    public boolean book(int start, int end) {
        // 找到所有比 start 小的键中最大的那个
        Integer pre = map.floorKey(start);
        // 找到所有比 start 大的键中最大的那个
        Integer next = map.ceilingKey(start);
        if ((pre != null && map.get(pre) > start) || (next != null && end > next)) return false;
        map.put(start, end);
        return true;
    }
}

/**
 * Your MyCalendar object will be instantiated and called as such:
 * MyCalendar obj = new MyCalendar();
 * boolean param_1 = obj.book(start,end);
 */
```

其实这个题最快的解法也是使用红黑树，不过为了说明，这里使用了线段树，具体的解法可以看[动态开点](./基础不牢地动山摇#动态开点)

### [699. 掉落的方块](https://leetcode.cn/problems/falling-squares/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/699.png)

这个题的解法主要看[链表形式的线段树](./基础不牢地动山摇.md#其他重要)

# 5.27

先来两道简单的

## [1342. 将数字变成 0 的操作次数](https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-to-zero/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1342.png)

就是模拟，也不是求最小值，这个题不是重点

```java
class Solution {
    public int numberOfSteps(int num) {
        int rst = 0;
        while (num != 0) {
            rst++;
            if ((num & 1) == 0) {
                num >>= 1;
            } else {
                num -= 1;
            }
        }
        return rst;
    }
}
```

## [2139. 得到目标值的最少行动次数](https://leetcode.cn/problems/minimum-moves-to-reach-target-score/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/2139.png)

有了上一个题的基础，这个题就好说了，反向思路即可

要注意的是，当 target 为奇数的时候，此时不能进行除法，而只能减法，因为 int 类型的奇数除法有损失，是不可逆的

此外，我们的原则是能除就除，因为最开始 target 很大，所以除法的方式使得 target 变小是很有效率的；

额外注意一下，如果 maxDoubles 已经变为 0 了，那么就不需要循环了，因为我们剩下的操作无论奇偶数，都只是减法，所以此时剩下的步骤就是 target - 1

```java
class Solution {
    public int minMoves(int target, int maxDoubles) {
        int rst = 0;
        while (target != 1) {
            if (maxDoubles == 0) return target - 1 + rst;
            if ((target & 1) == 0) {
                target >>= 1;
                maxDoubles--;
            } else {
                target--;
            }
            rst++;
        }
        return rst;
    }
}
```

# 5.31

今天这个题本来是锁题，不过因为是剑指 offer 系列的，所以白嫖了，血赚

用到了拓扑排序，这里先说一下前置题目

## 拓扑排序

这里是利用拓扑排序检查图中是否有环

这里使用的是 BFS 进行拓扑排序，入队列的标准为入度为 0，和 DFS 不同，不需要额外的 stack 存储遍历路径上的节点

简言之，入度为 0 才入队，如果有环，最终不会遍历到环内的节点，可以根据最终遍历的节点数量判断是否有环

首先是经典的[207. 课程表](https://leetcode.cn/problems/course-schedule/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/207.png)

使用链式前向星建图，借助 inDegree 数组判断入队条件，同时执行 BFS

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] head = new int[numCourses];
        int[] edges = new int[prerequisites.length];
        int[] next = new int[prerequisites.length];
        Arrays.fill(head, -1);
        int[] inDegree = new int[numCourses];
        int idx = 0;
        // 建图
        for (int[] prerequisite : prerequisites) {
            edges[idx] = prerequisite[0];
            next[idx] = head[prerequisite[1]];
            head[prerequisite[1]] = idx++;
            inDegree[prerequisite[0]]++;
        }
        Deque<Integer> queue = new LinkedList<>();
        int count = 0;
        // 入队
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) queue.offerLast(i);
        }
		// BFS
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int tmp = queue.pollFirst();
                count++;
                for (int edge = head[tmp]; edge != -1; edge = next[edge]) {
                    int end = edges[edge];
                    if (--inDegree[end] == 0) queue.offerLast(end);
                }
            }
        }
        return count == numCourses;
    }
}
```

还有一个姊妹题，[210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/210.png)

除了需要存储遍历的节点外和上面的题没有任何区别

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        int[] head = new int[numCourses];
        int[] edges = new int[prerequisites.length];
        int[] next = new int[prerequisites.length];
        Arrays.fill(head, -1);
        int[] inDegree = new int[numCourses];
        int idx = 0;
        // 建图
        for (int[] prerequisite : prerequisites) {
            edges[idx] = prerequisite[0];
            next[idx] = head[prerequisite[1]];
            head[prerequisite[1]] = idx++;
            inDegree[prerequisite[0]]++;
        }
        int[] rst = new int[numCourses];
        idx = 0;
        Deque<Integer> queue = new LinkedList<>();
        // 入队
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) queue.offerLast(i);
        }
        // BFS
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int tmp = queue.pollFirst();
                rst[idx++] = tmp;
                for (int edge = head[tmp]; edge != -1; edge = next[edge]) {
                    int end = edges[edge];
                    if (--inDegree[end] == 0) queue.offerLast(end);
                }
            }
        }
        return idx == numCourses ? rst : new int[0];
    }
}
```

然后就是白嫖的题了

### [剑指 Offer II 114. 外星文字典](https://leetcode.cn/problems/Jf1JuT/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/%E5%89%91%E6%8C%87II-114.png)

如果有了上面两个的铺垫，这个题的思路显然就是拓扑排序了，这里的节点其实就是出现的字符，这里的边并没有直接给出，需要根据单词的先后顺序进行推导

因为一对单词可以确定一组顺序，所以可以通过两层 for 循环充分利用 words 中包含的顺序信息

这里需要注意的是，words 本身可能就是非法的，比如 abcd 排在了 abc 的前面，这种，所以在提取一对字符串顺序信息的时候需要注意到这这种情况，按照题意此时直接返回空字符串即可

此外如果 words 中提供的顺序信息导致了环路的出现，同样的需要返回空字符串，所以在进行拓扑排序时，需要记录已经排序的节点的个数，并将其和之前遍历到的节点个数进行比较

```java
class Solution {
    // 最多具有 26 个节点(对应了 26 个字符)
	private static final int N = 26;
    // 最多具有 26 x 26 条边
	private static final int M = N * N;
    // 使用链式前向星建图
	private int[] head;
	private int[] edges;
	private int[] next;
    // 保存入度信息用于 BFS 拓扑排序
	private int[] inDegree;
	public String alienOrder(String[] words) {
		this.head = new int[N];
		Arrays.fill(head, -1);
		this.edges = new int[M];
		this.next = new int[M];
		this.inDegree = new int[M];
		int idx = 0;
        // 使用位运算记录遇到的字符的情况
		int mask = 0;
        // 记录遇到的字符，并建图
		for (int i = 0; i < words.length; i++) {
			for (int j = 0; j < words[i].length(); j++) mask |= 1 << words[i].charAt(j) - 'a';
			for (int j = i - 1; j >= 0; j--) {
				if (!createEdge(words[j], words[i], idx++)) return "";
			}
		}
 
		Deque<Integer> deque = new LinkedList<>();
		for (int i = 0; i < N; i++) {
			if (inDegree[i] == 0 && ((mask >> i) & 1) == 1) deque.offerLast(i);
		}
		StringBuilder builder = new StringBuilder();
		// BFS 拓扑排序
        while (!deque.isEmpty()) {
			int size = deque.size();
			for (int i = 0; i < size; i++) {
				int tmp = deque.pollFirst();
				builder.append((char)(tmp + 'a'));
				for (int edge = head[tmp]; edge != -1; edge = next[edge]) {
					int end = edges[edge];
					if (--inDegree[end] == 0) deque.offerLast(end);
				}
			}
		}
        // 根据数量关系确定图中是否ha
		return builder.length() == bitCount(mask) ? builder.toString() : "";
	}
    
	/**
     * 根据一对字符串的顺序信息确定一条边
	 */
	private boolean createEdge(String fore, String back, int idx) {
		int len = Math.min(fore.length(), back.length());
		for (int i = 0; i < len; i++) {
			if (fore.charAt(i) != back.charAt(i)) {
				addEdge(fore.charAt(i) - 'a', back.charAt(i) - 'a', idx);
				return true;
			}
		}
        // 如果出循环，意味着出现了其中一个字符串是另外一个字符串前缀的情况
		return fore.length() <= back.length();
	}

	private void addEdge(int from, int to, int idx) {
		edges[idx] = to;
		next[idx] = head[from];
		head[from] = idx++;
		inDegree[to]++;
	}
	
    /**
     * 获取 mask 中关于出现字符种类的信息
     */
	private int bitCount(int num) {
		num = (num & 0x55555555) + ((num >> 1) & 0x55555555);
		num = (num & 0x33333333) + ((num >> 2) & 0x33333333);
		num = (num & 0x0f0f0f0f) + ((num >> 4) & 0x0f0f0f0f);
		num = (num & 0x00ff00ff) + ((num >> 8) & 0x00ff00ff);
		num = (num & 0x0000ffff) + ((num >> 16) & 0x0000ffff);
		return num;
	}
}
```





