# 3.1

## [2369. 检查数组是否存在有效划分 (Check if There is a Valid Partition For The Array)](https://leetcode.cn/classic/problems/check-if-there-is-a-valid-partition-for-the-array/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/check-if-there-is-a-valid-partition-for-the-array/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/02/11:11:26:2369.png" />
	</a>
</div>

需要将一个数组划分为若干子数组, 而不是若干子序列 !

本题可以通过定义状态 (dp/记忆化搜索) 解决, 状态 f[i] 表示前 i 个数字是否可以构成一个有效的划分

如果使用记忆化搜索, 显然把 f[i] 作为结尾考虑时, f[i] 一定属于最后的两个/三个数字的子数组

即要么有 f[i] = f\[i - 1]( = f[i - 2]), 要么有 f[i] = f[i - 1] + 1 = f[i - 2] + 2; 在满足该条件的基础上, 再记忆化搜索前一个子数组 (i - 2 或 i - 3)

```java
class Solution {
    private int[] nums;
    private int[] buff;
    public boolean validPartition(int[] nums) {
        this.nums = nums;
        int n = nums.length;
        this.buff = new int[n];
        Arrays.fill(buff, -1);
        return dfs(n - 1);
    }
    
    private boolean dfs(int idx) {
        if (idx < 0) return true;
        if (buff[idx] != -1) return buff[idx] == 1;
        
        if (idx == 0) {
            buff[idx] = 0;
            return false;
        }
        
        buff[idx] = 0;
        
        if (nums[idx] == nums[idx - 1] && dfs(idx - 2)) buff[idx] = 1;
        else if (idx > 1) {
            if (nums[idx] == nums[idx - 1] && nums[idx] == nums[idx - 2] && dfs(idx - 3)) buff[idx] = 1;
            if (nums[idx] == nums[idx - 1] + 1 && nums[idx] == nums[idx - 2] + 2 && dfs(idx - 3)) buff[idx] = 1;
        }
        
        return buff[idx] == 1;
    }
}
```

# 3.4

## [948. Bag of Tokens](https://leetcode.com/problems/bag-of-tokens/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/bag-of-tokens/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/04/10:50:12:948.png" />
	</a>
</div>

不管是什么 token 都价值一个 score, 那么显然, 最开始使用 power 换 score 的时候, 应该从 token 小的开始; 

当出现 power 不足时, 考虑使用规则 2, 此时牺牲一个 score 换取目前剩余的最大的 token, 这样一定可以换取当前 token 中最小的那个 -> 本质上就是使用大 token 和小 token 抵消, 并让 power 增加这两者的插值, 对 score 本身不受影响

所以在规则 1 下, 随着 power 不断减少, score 会不断增加; 而在规则 2 下, score 不会变化, 而 power 一定不会减少; 从贪心的角度出发, 肯定是优先执行规则 1, 不满足条件时执行规则 2

```java
class Solution {
    public int bagOfTokensScore(int[] tokens, int power) {
        Arrays.sort(tokens);
        int rst = 0;
        int n = tokens.length;
        int i = 0, j = n - 1;
        while (i <= j) {
            if (power >= tokens[i]) {
                rst ++;
                power -= tokens[i];
                i ++;
            } else {
                if (rst == 0) break;
                power = power + tokens[j] - tokens[i];
                i ++;
                j --;
            }
        }
        return rst;
    }
}
```

# 3.5

## [1976. 到达目的地的方案数 (Number of Ways to Arrive at Destination)](https://leetcode.cn/classic/problems/number-of-ways-to-arrive-at-destination/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/number-of-ways-to-arrive-at-destination/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/05/10:53:11:1976.png" />
	</a>
</div>

本题可以看成是求解最短路的一个升级版, 现在求解的不再是最短路到底有多短, 而是求解最短路的个数

>   很多题目都是这样, 最开始求解一个最值, 后面求解的就是个数

因为本题不存在负环, 因此最短路通过 dijkstra 即可求解, 在此基础上, 对最短路进行计数, 具体的计数规则如下:

*   在最短距离数组 dis 之外额外开辟一个计数数组 cnt
*   如果当前节点 i 更新了节点 j 的最短路径, 即 dis[j] = dis[i] + w[i -> j], 则有 cnt[j] = cnt[i], 表示所有到达 i 的最短路个数, 都可以通过相同的方式到达节点 j
*   如果当前节点 i 到达节点 j 的路径碰巧和节点 j 当前的最短路径一致, 则有 cnt[j] += cnt[i], 表示所有到达 i 的最短路个数, 都可以通过相同的方式到达节点 j

```java
class Solution {
    private static final long INF = 0x3f3f3f3f3f3f3f3fL;
    private static final int MOD = (int)1e9 + 7;
    private int[] h;
    private int[] e;
    private int[] ne;
    private int[] w;
    private int idx;
    public int countPaths(int n, int[][] roads) {
        this.h = new int[n];
        Arrays.fill(this.h, -1);
        int m = roads.length;
        this.e = new int[m << 1];
        this.ne = new int[m << 1];
        this.w = new int[m << 1];
        this.idx = 0;
        long[] dis = new long[n];
        Arrays.fill(dis, INF);
        int[] cnt = new int[n];
        int[] vis = new int[n];
        for (int[] rs : roads) {
            add(rs[0], rs[1], rs[2]);
            add(rs[1], rs[0], rs[2]);
        }
        // 第一个维度表示距离, 第二个维度表示节点 id
        Queue<long[]> q = new PriorityQueue<>(Comparator.comparingLong(b -> b[0]));
        dis[0] = 0;
        cnt[0] = 1;
        q.offer(new long[]{0, 0});
        while (!q.isEmpty()) {
            long[] b = q.poll();
            int node = (int) b[1];
            if (vis[node] == 1) continue;
            vis[node] = 1;
            for (int i = h[node]; i != -1; i = ne[i]) {
                int j = e[i];
                long cur = dis[node] + w[i];
                if (cur < dis[j]) {
                    cnt[j] = cnt[node];
                    dis[j] = cur;
                    q.offer(new long[]{dis[j], j});
                } else if (cur == dis[j]) cnt[j] = (cnt[j] + cnt[node]) % MOD;
            }
        }
        return cnt[n - 1];
    }

    private void add(int a, int b, int c) {
        e[idx] = b;
        ne[idx] = h[a];
        w[idx] = c;
        h[a] = idx++;
    }
}
```

写一个正确的 dijkstra 并没有看起来那么简单, 就算使用了堆进行优化, 堆中的节点也可能出现重复的情况, 因此必须使用一个 vis 数组用来标识当前找到的最近的节点

此外堆排序本身只有在入堆和出堆时进行重新排序, 因此不要使用会动态变化的数值维护堆, 比如千万不要使用 dis 数组维护堆中元素的顺序, 因为每次对 dis 的修改并不会重构堆

因此堆优化的 dijkstra 需要依赖 pair 进行排序, 在 java 中使用一个二维数组替代, 这里也能看到 vis 数组的作用, 即当同一个节点被更新了很多次, 第一个 poll 出来的一定对应了最短路径, 此时堆中剩下到相同节点的路径都可以依靠这个 vis 数组而失效

# 3.8

## [2834. 找出美丽数组的最小和 (Find the Minimum Possible Sum of a Beautiful Array)](https://leetcode.cn/classic/problems/find-the-minimum-possible-sum-of-a-beautiful-array/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/find-the-minimum-possible-sum-of-a-beautiful-array/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/08/18:45:54:2834.png" />
	</a>
</div>
本题其实是一个数学问题, 简单来说, 可选的数字被 target 分为两部分:

*   一部分属于范围 [1, target - 1], 在范围内选取数字受限, 该范围内, 只要选择了一个数字, 就注定有一个数字不能选; 比如如果选了数字 1, 就不能再选数字 target - 1, 选了数字 2 就不能选择数字 target - 2 ...

    综上, 该范围内可以选择的数字的个数为: $\lfloor\frac{target}{2}\rfloor$ (无论 target 为奇数还是偶数)

*   第二部分属于范围 [target, $\infty$], 该部分的数字随便选择, 没有限制, 所以选的数字越小越好

综上, 为了让数组整体和最小, 需要从范围 [1, target - 1] 中选择 $\lfloor \frac{target}{2}\rfloor$ 个数字 (越小越好), 剩下的比较大的数字都从 [target, $\infty$] 中选择

```java
class Solution {
    private static final int MOD = (int)1e9 + 7;
    public int minimumPossibleSum(int n, int target) {
        int min = Math.min(target >> 1, n);
        int rst = (int)((((long)(1 + min) * min) >> 1) % MOD);
        int re = n - min;
        rst += (int)(((((long)target + target + re - 1) * re) >> 1) % MOD);
        rst %= MOD;
        return rst;
    }
}
```

# 3.12

## [1171. Remove Zero Sum Consecutive Nodes from Linked List](https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/12/10:32:06:1171.png" />
	</a>
</div>

如果将链表看成数组的话, 本题就是要求将子数组和为 0 的部分从链表中去除; 说到子数组和, 很容易想到使用前缀和快速得到任意一个子数组的和

本题的可行解有很多种, 题目并没有要求删除的节点数最多/最少, 题解给出的解法是遍历两次两次, 第一次记录前缀和出现的最后一个位置, 第二次记录前缀和出现的第一个位置

相同前缀出现的两个位置之间的 "子数组" 和一定为 0, 直接跳过即可

```java
class Solution {
    public ListNode removeZeroSumSublists(ListNode head) {
        ListNode pre = new ListNode(0);
        pre.next = head;
        Map<Integer, ListNode> m = new HashMap<>();
        ListNode cur = pre;
        int sum = 0;
        
        while (cur != null) {
            sum += cur.val;
            m.put(sum, cur);
            cur = cur.next;
        }
        
        cur = pre;
        sum = 0;
        
        while (cur != null) {
            sum += cur.val;
            cur.next = m.get(sum).next;
            cur = cur.next;
        }

        return pre.next;
    }
}
```

# 3.13

## [2789. 合并后数组中的最大元素 (Largest Element in an Array after Merge Operations)](https://leetcode.cn/classic/problems/largest-element-in-an-array-after-merge-operations/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/largest-element-in-an-array-after-merge-operations/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/14/10:44:42:2789.png" />
	</a>
</div>

>   如果正向看不容易的话, 为什么不反向看呢

从前向后遍历数组, 如果当前位置比后一个位置小的话, 不能贪心的将当前数字和后一个数字合并: 考虑序列 [3, 4, 5]; 正确的合并顺序应该是 5 先和 4 合并, 最后再和 3 合并

这其实是在诱导是否可以从后向前看, 从后向前遍历数组, 如果后一个数字比前一个数字更大的话, 就执行合并 -> 这种贪心思路是可行的, 因为从后向前遍历时, 数字合并的要求是后一个数字比前要给数字更大, 而后边的数字越合并, 就越能满足比前一个更大的条件

```java
class Solution {
    public long maxArrayValue(int[] nums) {
        long rst = 0;
        int n = nums.length;
        long tmp = 0;
        for (int i = n - 1; i >= 0; i --) {
            if (nums[i] <= tmp) tmp += nums[i];
            else {
                rst = Math.max(rst, tmp);
                tmp = nums[i];
            }
        }
        rst = Math.max(rst, tmp);
        return rst;
    }
}
```

# 3.14

## [930. Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/binary-subarrays-with-sum/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/14/11:29:22:930.png" />
	</a>
</div>

枚举每个子数组的时间复杂度为: $O(n^2)$, 输入大小达到了 $10^4$​ 级别, 肯定超时

注意到可以使用前缀和进行优化, 使用一个 map 记录各个前缀出现的个数; 从前向后遍历整个数组, 对于当前遍历的位置 i, 记录前缀和 sum, 那么所有以 i 结尾的和为 goal 的子数组个数为: map[sum - goal], 即找一下前缀和为 sum - goal 的出现的频率

实际编码的时候, 由于前缀和比较小, 可以使用数组对前缀和进行优化

```java
class Solution {
    private static final int N = (int)3e4 + 10;
    public int numSubarraysWithSum(int[] nums, int goal) {
        int n = nums.length;
        int[] m = new int[N];
        m[0]++;
        int sum = 0;
        int rst = 0;
        for (int i = 0; i < n; i++) {
            sum += nums[i];
            int idx = sum - goal;
            if (idx >= 0) rst += m[idx];
            m[sum]++;
        }
        return rst;
    }
}
```

# 3.15

## [2312. 卖木头块 (Selling Pieces of Wood)](https://leetcode.cn/classic/problems/selling-pieces-of-wood/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/selling-pieces-of-wood/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/16/10:43:41:2312.png" />
	</a>
</div>

题目给出的比较明显的提示是, 每次切割可以沿着垂直方向完全切割, 或者按照水平方向完全切割, 这意味着, **每次切割都会将一整块木头一分为二**

定义状态 f\[i][j] 表示高为 i 的, 宽为 j 的木头可以通过切割或者直接卖出得到的最大价值; 显然本题可以通过记忆化搜索求解

```java
class Solution {
    private static final int N = 210;
    private Map<Integer, Integer> map;
    private long[][] buff;
    public long sellingWood(int m, int n, int[][] prices) {
        this.map = new HashMap<>();
        // bitmode 压缩坐标
        for (int[] price : prices) map.put(price[0] * N + price[1], price[2]);
        this.buff = new long[m + 1][n + 1];
        for (int i = 0; i <= m; i++) Arrays.fill(buff[i], -1);
        return dfs(m, n);
    }
    
    private long dfs(int x, int y) {
        if (x == 0 || y == 0) return 0;
        if (buff[x][y] != -1) return buff[x][y];

        int key = x * N + y;
        long rst = map.getOrDefault(key, 0);
        // 水平方向切割
        for (int i = 1; i < x; i++) rst = Math.max(rst, dfs(i, y) + dfs(x - i, y));
        // 垂直方向切割
        for (int j = 1; j < y; j++) rst = Math.max(rst, dfs(x, j) + dfs(x, y - j));
        
        buff[x][y] = rst;
        return buff[x][y];
    }
}
```

## [238. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/product-of-array-except-self/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/238.png" />
	</a>
</div>

在本题的说明里面提到了不要使用除法, 最简单的做法就是维护一个前后缀乘积数组, 这样每个位置的取值可以通过一个前缀和后缀的乘积得到

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] pre = new int[n + 1];
        pre[0] = 1;
        for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] * nums[i - 1];
        int[] suf = new int[n + 1];
        suf[n] = 1;
        for (int i = n - 1; i >= 0; i--) suf[i] = suf[i + 1] * nums[i];
        int[] rst = new int[n];
        for (int i = 0; i < n; i++) rst[i] = pre[i] * suf[i + 1];
        return rst;
    }
}
```

而在本题的进阶中要求使用常数空间, 那么其实可以将前缀/后缀数组的一部分移到 rst 本身中, 同时再使用一个 local variable 维护没有被计算的后缀/前缀

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] rst = new int[n];
        rst[n - 1] = 1;
        // 将后缀数组移动到 rst 中
        for (int i = n - 2; i >= 0; i --) rst[i] = nums[i + 1] * rst[i + 1];
        // 使用 rst 维护前缀
        int sum = 1;
        for (int i = 1; i < n; i ++) {
            sum *= nums[i - 1];
            rst[i] *= sum;
        }
        return rst;
    }
}
```

# 3.16

## [2684. 矩阵中移动的最大次数 (Maximum Number of Moves in a Grid)](https://leetcode.cn/classic/problems/maximum-number-of-moves-in-a-grid/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/maximum-number-of-moves-in-a-grid/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/16/10:56:40:2684.png" />
	</a>
</div>

定义状态 f\[i][j] 表示从矩阵中位置 (i, j) 处可以移动的最大次数, 每次移动都通过记忆化搜索进行, 最后把第一列中最大的那个返回就行了

```java
class Solution {
    private static final int[][] DIR = {{1, 1}, {-1, 1}, {0, 1}};
    private int[][] grid;
    private int n, m;
    private int[][] buff;
    public int maxMoves(int[][] grid) {
        this.grid = grid;
        this.n = grid.length;
        this.m = grid[0].length;
        this.buff = new int[n][m];
        for (int i = 0; i < n; i++) Arrays.fill(buff[i], -1);
        int rst = 0;
        for (int i = 0; i < n; i++) rst = Math.max(rst, dfs(i, 0));
        return rst;
    }
    
    private int dfs(int x, int y) {
        if (buff[x][y] != -1) return buff[x][y];
        
        int rst = 0;
        
        for (int[] d : DIR) {
            int nx = x + d[0];
            int ny = y + d[1];
            if (nx < 0 || nx >= n || ny < 0 || ny >= m || grid[nx][ny] <= grid[x][y]) continue;
            rst = Math.max(rst, dfs(nx, ny) + 1);
        }
        
        buff[x][y] = rst;
        return buff[x][y];
    }
}
```

## [525. Contiguous Array](https://leetcode.com/problems/contiguous-array/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/contiguous-array/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/525.png" />
	</a>
</div>
本题的难点在于, 输入范围太大了, 达到了 $10^5$ 级别, 最多只能接受时间复杂度为: $O(n\log n)$ 的算法

对于子数组, 一种优化的思路是借助一个 map 一边遍历一边取值, 但是本题要求的是 0 和 1 数量相同的子数组, 通过一个简单的前缀和肯定不能实现 $O(1)$ 查询

本题的思路是: 如果需要查找相同数量的 0 和 1 的子数组, 其实等价于求解 1 的数量和 0 的数量做差为 0 的子数组, 即本题维护的前缀和是整个前缀中 1 和 0 的数量的差值, 这样使用 map 维护差值出现的第一个位置, 后续遇到了相同的差值, 则两个位置之间的子数组, 其中 0 的数量和 1 的数量一定相同

```java
class Solution {
    public int findMaxLength(int[] nums) {
        int n = nums.length;
        int sum = 0;
        Map<Integer, Integer> m = new HashMap<>();
        // 预存的位置 -1, 表示最开始 1 和 0 的数量都是 0
        m.put(0, -1);
        int rst = 0;
        for (int i = 0; i < n; i++) {
            sum += nums[i];
            int len = i + 1;
            int gap = sum - (len - sum);
            // 本来这里 -1 就够了, 都怪上面把 -1 给占用了
            int pre = m.getOrDefault(gap, -2);
            if (pre == -2) m.put(gap, i);
            else rst = Math.max(rst, i - pre);
        }
        return rst;
    }
}
```

