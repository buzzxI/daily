# 3.1

## [2369. 检查数组是否存在有效划分 (Check if There is a Valid Partition For The Array)](https://leetcode.cn/classic/problems/check-if-there-is-a-valid-partition-for-the-array/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/check-if-there-is-a-valid-partition-for-the-array/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/02/11:11:26:2369.png" />
	</a>
</div>

需要将一个数组划分为若干子数组, 而不是若干子序列 !

本题可以通过定义状态 (dp/记忆化搜索) 解决, 状态 f[i] 表示前 i 个数字是否可以构成一个有效的划分

如果使用记忆化搜索, 显然把 f[i] 作为结尾考虑时, f[i] 一定属于最后的两个/三个数字的子数组

即要么有 f[i] = f\[i - 1]( = f[i - 2]), 要么有 f[i] = f[i - 1] + 1 = f[i - 2] + 2; 在满足该条件的基础上, 再记忆化搜索前一个子数组 (i - 2 或 i - 3)

```java
class Solution {
    private int[] nums;
    private int[] buff;
    public boolean validPartition(int[] nums) {
        this.nums = nums;
        int n = nums.length;
        this.buff = new int[n];
        Arrays.fill(buff, -1);
        return dfs(n - 1);
    }
    
    private boolean dfs(int idx) {
        if (idx < 0) return true;
        if (buff[idx] != -1) return buff[idx] == 1;
        
        if (idx == 0) {
            buff[idx] = 0;
            return false;
        }
        
        buff[idx] = 0;
        
        if (nums[idx] == nums[idx - 1] && dfs(idx - 2)) buff[idx] = 1;
        else if (idx > 1) {
            if (nums[idx] == nums[idx - 1] && nums[idx] == nums[idx - 2] && dfs(idx - 3)) buff[idx] = 1;
            if (nums[idx] == nums[idx - 1] + 1 && nums[idx] == nums[idx - 2] + 2 && dfs(idx - 3)) buff[idx] = 1;
        }
        
        return buff[idx] == 1;
    }
}
```

# 3.4

## [948. Bag of Tokens](https://leetcode.com/problems/bag-of-tokens/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/bag-of-tokens/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/04/10:50:12:948.png" />
	</a>
</div>

不管是什么 token 都价值一个 score, 那么显然, 最开始使用 power 换 score 的时候, 应该从 token 小的开始; 

当出现 power 不足时, 考虑使用规则 2, 此时牺牲一个 score 换取目前剩余的最大的 token, 这样一定可以换取当前 token 中最小的那个 -> 本质上就是使用大 token 和小 token 抵消, 并让 power 增加这两者的插值, 对 score 本身不受影响

所以在规则 1 下, 随着 power 不断减少, score 会不断增加; 而在规则 2 下, score 不会变化, 而 power 一定不会减少; 从贪心的角度出发, 肯定是优先执行规则 1, 不满足条件时执行规则 2

```java
class Solution {
    public int bagOfTokensScore(int[] tokens, int power) {
        Arrays.sort(tokens);
        int rst = 0;
        int n = tokens.length;
        int i = 0, j = n - 1;
        while (i <= j) {
            if (power >= tokens[i]) {
                rst ++;
                power -= tokens[i];
                i ++;
            } else {
                if (rst == 0) break;
                power = power + tokens[j] - tokens[i];
                i ++;
                j --;
            }
        }
        return rst;
    }
}
```

# 3.5

## [1976. 到达目的地的方案数 (Number of Ways to Arrive at Destination)](https://leetcode.cn/classic/problems/number-of-ways-to-arrive-at-destination/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/number-of-ways-to-arrive-at-destination/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/05/10:53:11:1976.png" />
	</a>
</div>

本题可以看成是求解最短路的一个升级版, 现在求解的不再是最短路到底有多短, 而是求解最短路的个数

>   很多题目都是这样, 最开始求解一个最值, 后面求解的就是个数

因为本题不存在负环, 因此最短路通过 dijkstra 即可求解, 在此基础上, 对最短路进行计数, 具体的计数规则如下:

*   在最短距离数组 dis 之外额外开辟一个计数数组 cnt
*   如果当前节点 i 更新了节点 j 的最短路径, 即 dis[j] = dis[i] + w[i -> j], 则有 cnt[j] = cnt[i], 表示所有到达 i 的最短路个数, 都可以通过相同的方式到达节点 j
*   如果当前节点 i 到达节点 j 的路径碰巧和节点 j 当前的最短路径一致, 则有 cnt[j] += cnt[i], 表示所有到达 i 的最短路个数, 都可以通过相同的方式到达节点 j

```java
class Solution {
    private static final long INF = 0x3f3f3f3f3f3f3f3fL;
    private static final int MOD = (int)1e9 + 7;
    private int[] h;
    private int[] e;
    private int[] ne;
    private int[] w;
    private int idx;
    public int countPaths(int n, int[][] roads) {
        this.h = new int[n];
        Arrays.fill(this.h, -1);
        int m = roads.length;
        this.e = new int[m << 1];
        this.ne = new int[m << 1];
        this.w = new int[m << 1];
        this.idx = 0;
        long[] dis = new long[n];
        Arrays.fill(dis, INF);
        int[] cnt = new int[n];
        int[] vis = new int[n];
        for (int[] rs : roads) {
            add(rs[0], rs[1], rs[2]);
            add(rs[1], rs[0], rs[2]);
        }
        // 第一个维度表示距离, 第二个维度表示节点 id
        Queue<long[]> q = new PriorityQueue<>(Comparator.comparingLong(b -> b[0]));
        dis[0] = 0;
        cnt[0] = 1;
        q.offer(new long[]{0, 0});
        while (!q.isEmpty()) {
            long[] b = q.poll();
            int node = (int) b[1];
            if (vis[node] == 1) continue;
            vis[node] = 1;
            for (int i = h[node]; i != -1; i = ne[i]) {
                int j = e[i];
                long cur = dis[node] + w[i];
                if (cur < dis[j]) {
                    cnt[j] = cnt[node];
                    dis[j] = cur;
                    q.offer(new long[]{dis[j], j});
                } else if (cur == dis[j]) cnt[j] = (cnt[j] + cnt[node]) % MOD;
            }
        }
        return cnt[n - 1];
    }

    private void add(int a, int b, int c) {
        e[idx] = b;
        ne[idx] = h[a];
        w[idx] = c;
        h[a] = idx++;
    }
}
```

写一个正确的 dijkstra 并没有看起来那么简单, 就算使用了堆进行优化, 堆中的节点也可能出现重复的情况, 因此必须使用一个 vis 数组用来标识当前找到的最近的节点

此外堆排序本身只有在入堆和出堆时进行重新排序, 因此不要使用会动态变化的数值维护堆, 比如千万不要使用 dis 数组维护堆中元素的顺序, 因为每次对 dis 的修改并不会重构堆

因此堆优化的 dijkstra 需要依赖 pair 进行排序, 在 java 中使用一个二维数组替代, 这里也能看到 vis 数组的作用, 即当同一个节点被更新了很多次, 第一个 poll 出来的一定对应了最短路径, 此时堆中剩下到相同节点的路径都可以依靠这个 vis 数组而失效

# 3.8

## [2834. 找出美丽数组的最小和 (Find the Minimum Possible Sum of a Beautiful Array)](https://leetcode.cn/classic/problems/find-the-minimum-possible-sum-of-a-beautiful-array/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/find-the-minimum-possible-sum-of-a-beautiful-array/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/08/18:45:54:2834.png" />
	</a>
</div>
本题其实是一个数学问题, 简单来说, 可选的数字被 target 分为两部分:

*   一部分属于范围 [1, target - 1], 在范围内选取数字受限, 该范围内, 只要选择了一个数字, 就注定有一个数字不能选; 比如如果选了数字 1, 就不能再选数字 target - 1, 选了数字 2 就不能选择数字 target - 2 ...

    综上, 该范围内可以选择的数字的个数为: $\lfloor\frac{target}{2}\rfloor$ (无论 target 为奇数还是偶数)

*   第二部分属于范围 [target, $\infty$], 该部分的数字随便选择, 没有限制, 所以选的数字越小越好

综上, 为了让数组整体和最小, 需要从范围 [1, target - 1] 中选择 $\lfloor \frac{target}{2}\rfloor$ 个数字 (越小越好), 剩下的比较大的数字都从 [target, $\infty$] 中选择

```java
class Solution {
    private static final int MOD = (int)1e9 + 7;
    public int minimumPossibleSum(int n, int target) {
        int min = Math.min(target >> 1, n);
        int rst = (int)((((long)(1 + min) * min) >> 1) % MOD);
        int re = n - min;
        rst += (int)(((((long)target + target + re - 1) * re) >> 1) % MOD);
        rst %= MOD;
        return rst;
    }
}
```

# 3.12

## [1171. Remove Zero Sum Consecutive Nodes from Linked List](https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/12/10:32:06:1171.png" />
	</a>
</div>

如果将链表看成数组的话, 本题就是要求将子数组和为 0 的部分从链表中去除; 说到子数组和, 很容易想到使用前缀和快速得到任意一个子数组的和

本题的可行解有很多种, 题目并没有要求删除的节点数最多/最少, 题解给出的解法是遍历两次两次, 第一次记录前缀和出现的最后一个位置, 第二次记录前缀和出现的第一个位置

相同前缀出现的两个位置之间的 "子数组" 和一定为 0, 直接跳过即可

```java
class Solution {
    public ListNode removeZeroSumSublists(ListNode head) {
        ListNode pre = new ListNode(0);
        pre.next = head;
        Map<Integer, ListNode> m = new HashMap<>();
        ListNode cur = pre;
        int sum = 0;
        
        while (cur != null) {
            sum += cur.val;
            m.put(sum, cur);
            cur = cur.next;
        }
        
        cur = pre;
        sum = 0;
        
        while (cur != null) {
            sum += cur.val;
            cur.next = m.get(sum).next;
            cur = cur.next;
        }

        return pre.next;
    }
}
```

# 3.13

## [2789. 合并后数组中的最大元素 (Largest Element in an Array after Merge Operations)](https://leetcode.cn/classic/problems/largest-element-in-an-array-after-merge-operations/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/largest-element-in-an-array-after-merge-operations/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/14/10:44:42:2789.png" />
	</a>
</div>

>   如果正向看不容易的话, 为什么不反向看呢

从前向后遍历数组, 如果当前位置比后一个位置小的话, 不能贪心的将当前数字和后一个数字合并: 考虑序列 [3, 4, 5]; 正确的合并顺序应该是 5 先和 4 合并, 最后再和 3 合并

这其实是在诱导是否可以从后向前看, 从后向前遍历数组, 如果后一个数字比前一个数字更大的话, 就执行合并 -> 这种贪心思路是可行的, 因为从后向前遍历时, 数字合并的要求是后一个数字比前要给数字更大, 而后边的数字越合并, 就越能满足比前一个更大的条件

```java
class Solution {
    public long maxArrayValue(int[] nums) {
        long rst = 0;
        int n = nums.length;
        long tmp = 0;
        for (int i = n - 1; i >= 0; i --) {
            if (nums[i] <= tmp) tmp += nums[i];
            else {
                rst = Math.max(rst, tmp);
                tmp = nums[i];
            }
        }
        rst = Math.max(rst, tmp);
        return rst;
    }
}
```

# 3.14

## [930. Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/binary-subarrays-with-sum/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/14/11:29:22:930.png" />
	</a>
</div>

枚举每个子数组的时间复杂度为: $O(n^2)$, 输入大小达到了 $10^4$​ 级别, 肯定超时

注意到可以使用前缀和进行优化, 使用一个 map 记录各个前缀出现的个数; 从前向后遍历整个数组, 对于当前遍历的位置 i, 记录前缀和 sum, 那么所有以 i 结尾的和为 goal 的子数组个数为: map[sum - goal], 即找一下前缀和为 sum - goal 的出现的频率

实际编码的时候, 由于前缀和比较小, 可以使用数组对前缀和进行优化

```java
class Solution {
    private static final int N = (int)3e4 + 10;
    public int numSubarraysWithSum(int[] nums, int goal) {
        int n = nums.length;
        int[] m = new int[N];
        m[0]++;
        int sum = 0;
        int rst = 0;
        for (int i = 0; i < n; i++) {
            sum += nums[i];
            int idx = sum - goal;
            if (idx >= 0) rst += m[idx];
            m[sum]++;
        }
        return rst;
    }
}
```

# 3.15

## [2312. 卖木头块 (Selling Pieces of Wood)](https://leetcode.cn/classic/problems/selling-pieces-of-wood/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/selling-pieces-of-wood/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/16/10:43:41:2312.png" />
	</a>
</div>

题目给出的比较明显的提示是, 每次切割可以沿着垂直方向完全切割, 或者按照水平方向完全切割, 这意味着, **每次切割都会将一整块木头一分为二**

定义状态 f\[i][j] 表示高为 i 的, 宽为 j 的木头可以通过切割或者直接卖出得到的最大价值; 显然本题可以通过记忆化搜索求解

```java
class Solution {
    private static final int N = 210;
    private Map<Integer, Integer> map;
    private long[][] buff;
    public long sellingWood(int m, int n, int[][] prices) {
        this.map = new HashMap<>();
        // bitmode 压缩坐标
        for (int[] price : prices) map.put(price[0] * N + price[1], price[2]);
        this.buff = new long[m + 1][n + 1];
        for (int i = 0; i <= m; i++) Arrays.fill(buff[i], -1);
        return dfs(m, n);
    }
    
    private long dfs(int x, int y) {
        if (x == 0 || y == 0) return 0;
        if (buff[x][y] != -1) return buff[x][y];

        int key = x * N + y;
        long rst = map.getOrDefault(key, 0);
        // 水平方向切割
        for (int i = 1; i < x; i++) rst = Math.max(rst, dfs(i, y) + dfs(x - i, y));
        // 垂直方向切割
        for (int j = 1; j < y; j++) rst = Math.max(rst, dfs(x, j) + dfs(x, y - j));
        
        buff[x][y] = rst;
        return buff[x][y];
    }
}
```

## [238. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/product-of-array-except-self/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/238.png" />
	</a>
</div>

在本题的说明里面提到了不要使用除法, 最简单的做法就是维护一个前后缀乘积数组, 这样每个位置的取值可以通过一个前缀和后缀的乘积得到

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] pre = new int[n + 1];
        pre[0] = 1;
        for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] * nums[i - 1];
        int[] suf = new int[n + 1];
        suf[n] = 1;
        for (int i = n - 1; i >= 0; i--) suf[i] = suf[i + 1] * nums[i];
        int[] rst = new int[n];
        for (int i = 0; i < n; i++) rst[i] = pre[i] * suf[i + 1];
        return rst;
    }
}
```

而在本题的进阶中要求使用常数空间, 那么其实可以将前缀/后缀数组的一部分移到 rst 本身中, 同时再使用一个 local variable 维护没有被计算的后缀/前缀

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] rst = new int[n];
        rst[n - 1] = 1;
        // 将后缀数组移动到 rst 中
        for (int i = n - 2; i >= 0; i --) rst[i] = nums[i + 1] * rst[i + 1];
        // 使用 rst 维护前缀
        int sum = 1;
        for (int i = 1; i < n; i ++) {
            sum *= nums[i - 1];
            rst[i] *= sum;
        }
        return rst;
    }
}
```

# 3.16

## [2684. 矩阵中移动的最大次数 (Maximum Number of Moves in a Grid)](https://leetcode.cn/classic/problems/maximum-number-of-moves-in-a-grid/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/maximum-number-of-moves-in-a-grid/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/16/10:56:40:2684.png" />
	</a>
</div>

定义状态 f\[i][j] 表示从矩阵中位置 (i, j) 处可以移动的最大次数, 每次移动都通过记忆化搜索进行, 最后把第一列中最大的那个返回就行了

```java
class Solution {
    private static final int[][] DIR = {{1, 1}, {-1, 1}, {0, 1}};
    private int[][] grid;
    private int n, m;
    private int[][] buff;
    public int maxMoves(int[][] grid) {
        this.grid = grid;
        this.n = grid.length;
        this.m = grid[0].length;
        this.buff = new int[n][m];
        for (int i = 0; i < n; i++) Arrays.fill(buff[i], -1);
        int rst = 0;
        for (int i = 0; i < n; i++) rst = Math.max(rst, dfs(i, 0));
        return rst;
    }
    
    private int dfs(int x, int y) {
        if (buff[x][y] != -1) return buff[x][y];
        
        int rst = 0;
        
        for (int[] d : DIR) {
            int nx = x + d[0];
            int ny = y + d[1];
            if (nx < 0 || nx >= n || ny < 0 || ny >= m || grid[nx][ny] <= grid[x][y]) continue;
            rst = Math.max(rst, dfs(nx, ny) + 1);
        }
        
        buff[x][y] = rst;
        return buff[x][y];
    }
}
```

## [525. Contiguous Array](https://leetcode.com/problems/contiguous-array/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/contiguous-array/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/525.png" />
	</a>
</div>

本题的难点在于, 输入范围太大了, 达到了 $10^5$ 级别, 最多只能接受时间复杂度为: $O(n\log n)$ 的算法

对于子数组, 一种优化的思路是借助一个 map 一边遍历一边取值, 但是本题要求的是 0 和 1 数量相同的子数组, 通过一个简单的前缀和肯定不能实现 $O(1)$ 查询

本题的思路是: 如果需要查找相同数量的 0 和 1 的子数组, 其实等价于求解 1 的数量和 0 的数量做差为 0 的子数组, 即本题维护的前缀和是整个前缀中 1 和 0 的数量的差值, 这样使用 map 维护差值出现的第一个位置, 后续遇到了相同的差值, 则两个位置之间的子数组, 其中 0 的数量和 1 的数量一定相同

```java
class Solution {
    public int findMaxLength(int[] nums) {
        int n = nums.length;
        int sum = 0;
        Map<Integer, Integer> m = new HashMap<>();
        // 预存的位置 -1, 表示最开始 1 和 0 的数量都是 0
        m.put(0, -1);
        int rst = 0;
        for (int i = 0; i < n; i++) {
            sum += nums[i];
            int len = i + 1;
            int gap = sum - (len - sum);
            // 本来这里 -1 就够了, 都怪上面把 -1 给占用了
            int pre = m.getOrDefault(gap, -2);
            if (pre == -2) m.put(gap, i);
            else rst = Math.max(rst, i - pre);
        }
        return rst;
    }
}
```

# 3.17

## [57. Insert Interval](https://leetcode.com/problems/insert-interval/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/insert-interval/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/17/11:21:16:57.png" />
	</a>
</div>

本题的 newInterval 大小仅为 1, 并且 intervals 已经是事先排好序的了, 因此 intervals 在 newInterval 的作用下可以分为三部分:

*   左侧未和 newInterval 合并的部分
*   和 newInterval 合并的部分
*   右侧未和 newInterval 合并的部分

其中第一部分和第二部分的分隔标志是, 第一部分的 interval 的结束位置小于 newInterval 的开头

```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        List<int[]> list = new ArrayList<>();
        
        int idx = 0;
        int n = intervals.length;
        // 第一部分
        while (idx < n && intervals[idx][1] < newInterval[0]) list.add(intervals[idx ++]);
        
        int l = newInterval[0];
        int r = newInterval[1];
        // 第二部分
        while (idx < n && intervals[idx][0] <= r) {
            l = Math.min(l, intervals[idx][0]);
            r = Math.max(r, intervals[idx ++][1]);
        }
        list.add(new int[]{l, r});
        
        // 第三部分
        while (idx < n) list.add(intervals[idx ++]);
        
        int m = list.size();
        int[][] rst = new int[m][2];
        for (int i = 0; i < m; i++) rst[i] = list.get(i);
        return rst;
    }
}
```

# 3.18

## [452. Minimum Number of Arrows to Burst Balloons](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/452.png" />
	</a>
</div>

其实是等价于求最多重叠区间的个数, 按照区间开头对各个区间排序, 同时维护区间重叠边界 l 和 r

对于给定的一组 l 和 r, 下一组区间左边界一定是后续所有未遍历区间中最小的, 如果下一组区间和 l, r 有重叠 (next[0] < r), 标识这两个区间可以被同一个箭头击穿, 此时继续更新重叠边界 l 和 r

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        Arrays.sort(points, Comparator.comparingInt(p -> p[0]));
        int n = points.length;
        int rst = 0;
        for (int i = 0; i < n; i ++) {
            int l = points[i][0];
            int r = points[i][1];
            int ne = i + 1;
            while (ne < n && points[ne][0] <= r) {
                l = Math.max(l, points[ne][0]);
                r = Math.min(r, points[ne][1]);
                ne ++;
            }
            i = ne - 1;
            rst ++;
        }
        return rst;
    }
}
```

# 3.19

## [1793. 好子数组的最大分数 (Maximum Score of a Good Subarray)](https://leetcode.cn/classic/problems/maximum-score-of-a-good-subarray/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/maximum-score-of-a-good-subarray/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/19/10:43:03:1793.png" />
	</a>
</div>

为了让分数尽可能的大, 在某个数字作为子数组的最小值时, 应该试图让该子数组的长度尽可能大, 即找到某个数字作为子数组的最小值时, 最左侧及最右侧边界 -> 单调栈

维护一个单调递增的单调栈, 新的元素入栈时, 左边界取到栈顶; 当元素弹栈时, 右边界为使其弹栈的元素

```java
class Solution {
    public int maximumScore(int[] nums, int k) {
        int n = nums.length;
        int[] l = new int[n];
        int[] r = new int[n];
        int[] stk = new int[n];
        int e = -1;
        for (int i = 0; i < n; i ++) {
            while (e >= 0 && nums[i] < nums[stk[e]]) {
                int idx = stk[e --];
                // 右边界取到 i, 即不能取到
                r[idx] = i;
            }
        	
            // 左边界为是可以取到的
            if (e == -1) l[i] = 0;
            else l[i] = stk[e] + 1;
            
            stk[++ e] = i;
        }
        
        while (e >= 0) r[stk[e --]] = n;
        
        int rst = 0;
        
        for (int i = 0; i < n; i ++) {
            // 题目给出了 k 作为限制, 需要左右边界在 k 两侧
            if (l[i] <= k && k < r[i]) rst = Math.max(rst, (r[i] - l[i]) * nums[i]);
        }
        
        return rst;
    }
}
```

## [621. 任务调度器](https://leetcode-cn.com/problems/task-scheduler/)

<div style="text-align:center;">
	<a href="https://leetcode-cn.com/problems/task-scheduler/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/621.png" />
	</a>
</div>

考虑只有一种任务时, 完成任务的时间取决于当前任务的个数 m 和冷却间隔 n, 此时完成任务需要的时间为 (m - 1) * (n + 1) + 1

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/621_1.png)

每一行为一轮, 每列为该轮次中执行的任务, 注意到在该种任务的调度中, 除了最后一轮, 剩下的每一轮都需要 n 个时间冷却, 因此最后一行只需要 1 个单位的时间完成执行

在多种任务的场景中, 上图的行数取决于出现频率最多的任务

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/621_2.png)

可以注意到上图中, 出现频率最多的任务是 A 和 B, 而任务 C 出现频率比较小, 可以直接插入到 A 和 B 的冷却时间内, 因此完成任务需要的时间为 (m - 1) * (n + 1) + 2, 除了最后一行只需要 2 个单位的时间之外, 剩下的每行都需要 n + 1 个时间

注意到上图中比较关键的点在于, 除了出现频率最多的任务之外, 剩下的任务可以插入到任务的冷却时间内, 继续增加任务的种类数, 使其填充冷却的空闲时间内

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/621_3.png)

注意到此时不会有任何的冷却时间闲置, 此时完成任务需要的时间等于任务的个数, 然而, 任务的种类可能有很多, 但频率都不大, 因此可能出现冷却时间不足以安排所有小频率的任务

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/621_4.png)

在上图所示的任务编排下, 尽管每轮需要的时间增加了, 但按照这种编排方式, 不会出现任何的冷却空闲时间, 即此时任务完成的时间等于任务个数

综上, 可以通过出现频率最大的任务个数和冷却时间计算一个可能的, 包含了冷却时间的任务安排方式; 而如果任务种类太大, 就可以将任务个数视为任务的完成时间

```java
class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] freq = new int[26];
        for (int i = 0; i < tasks.length; i ++) {
            freq[tasks[i] - 'A']++;
        }
        Arrays.sort(freq);
        int maxLen = 1;
        // 计算出现频率最多的任务种类数
        for (int i = 24; i >= 0 && freq[25] == freq[i]; i --, maxLen ++);
        // 返回两者中最大的那个
        return Math.max((freq[25] - 1) * (n + 1) + maxLen, tasks.length);
    }
}
```







