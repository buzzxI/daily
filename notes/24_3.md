# 3.1

## [2369. 检查数组是否存在有效划分 (Check if There is a Valid Partition For The Array)](https://leetcode.cn/classic/problems/check-if-there-is-a-valid-partition-for-the-array/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/check-if-there-is-a-valid-partition-for-the-array/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/02/11:11:26:2369.png" />
	</a>
</div>

需要将一个数组划分为若干子数组, 而不是若干子序列 !

本题可以通过定义状态 (dp/记忆化搜索) 解决, 状态 f[i] 表示前 i 个数字是否可以构成一个有效的划分

如果使用记忆化搜索, 显然把 f[i] 作为结尾考虑时, f[i] 一定属于最后的两个/三个数字的子数组

即要么有 f[i] = f\[i - 1]( = f[i - 2]), 要么有 f[i] = f[i - 1] + 1 = f[i - 2] + 2; 在满足该条件的基础上, 再记忆化搜索前一个子数组 (i - 2 或 i - 3)

```java
class Solution {
    private int[] nums;
    private int[] buff;
    public boolean validPartition(int[] nums) {
        this.nums = nums;
        int n = nums.length;
        this.buff = new int[n];
        Arrays.fill(buff, -1);
        return dfs(n - 1);
    }
    
    private boolean dfs(int idx) {
        if (idx < 0) return true;
        if (buff[idx] != -1) return buff[idx] == 1;
        
        if (idx == 0) {
            buff[idx] = 0;
            return false;
        }
        
        buff[idx] = 0;
        
        if (nums[idx] == nums[idx - 1] && dfs(idx - 2)) buff[idx] = 1;
        else if (idx > 1) {
            if (nums[idx] == nums[idx - 1] && nums[idx] == nums[idx - 2] && dfs(idx - 3)) buff[idx] = 1;
            if (nums[idx] == nums[idx - 1] + 1 && nums[idx] == nums[idx - 2] + 2 && dfs(idx - 3)) buff[idx] = 1;
        }
        
        return buff[idx] == 1;
    }
}
```

# 3.4

## [948. Bag of Tokens](https://leetcode.com/problems/bag-of-tokens/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/bag-of-tokens/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/04/10:50:12:948.png" />
	</a>
</div>

不管是什么 token 都价值一个 score, 那么显然, 最开始使用 power 换 score 的时候, 应该从 token 小的开始; 

当出现 power 不足时, 考虑使用规则 2, 此时牺牲一个 score 换取目前剩余的最大的 token, 这样一定可以换取当前 token 中最小的那个 -> 本质上就是使用大 token 和小 token 抵消, 并让 power 增加这两者的插值, 对 score 本身不受影响

所以在规则 1 下, 随着 power 不断减少, score 会不断增加; 而在规则 2 下, score 不会变化, 而 power 一定不会减少; 从贪心的角度出发, 肯定是优先执行规则 1, 不满足条件时执行规则 2

```java
class Solution {
    public int bagOfTokensScore(int[] tokens, int power) {
        Arrays.sort(tokens);
        int rst = 0;
        int n = tokens.length;
        int i = 0, j = n - 1;
        while (i <= j) {
            if (power >= tokens[i]) {
                rst ++;
                power -= tokens[i];
                i ++;
            } else {
                if (rst == 0) break;
                power = power + tokens[j] - tokens[i];
                i ++;
                j --;
            }
        }
        return rst;
    }
}
```

# 3.5

## [1976. 到达目的地的方案数 (Number of Ways to Arrive at Destination)](https://leetcode.cn/classic/problems/number-of-ways-to-arrive-at-destination/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/number-of-ways-to-arrive-at-destination/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/05/10:53:11:1976.png" />
	</a>
</div>

本题可以看成是求解最短路的一个升级版, 现在求解的不再是最短路到底有多短, 而是求解最短路的个数

>   很多题目都是这样, 最开始求解一个最值, 后面求解的就是个数

因为本题不存在负环, 因此最短路通过 dijkstra 即可求解, 在此基础上, 对最短路进行计数, 具体的计数规则如下:

*   在最短距离数组 dis 之外额外开辟一个计数数组 cnt
*   如果当前节点 i 更新了节点 j 的最短路径, 即 dis[j] = dis[i] + w[i -> j], 则有 cnt[j] = cnt[i], 表示所有到达 i 的最短路个数, 都可以通过相同的方式到达节点 j
*   如果当前节点 i 到达节点 j 的路径碰巧和节点 j 当前的最短路径一致, 则有 cnt[j] += cnt[i], 表示所有到达 i 的最短路个数, 都可以通过相同的方式到达节点 j

```java
class Solution {
    private static final long INF = 0x3f3f3f3f3f3f3f3fL;
    private static final int MOD = (int)1e9 + 7;
    private int[] h;
    private int[] e;
    private int[] ne;
    private int[] w;
    private int idx;
    public int countPaths(int n, int[][] roads) {
        this.h = new int[n];
        Arrays.fill(this.h, -1);
        int m = roads.length;
        this.e = new int[m << 1];
        this.ne = new int[m << 1];
        this.w = new int[m << 1];
        this.idx = 0;
        long[] dis = new long[n];
        Arrays.fill(dis, INF);
        int[] cnt = new int[n];
        int[] vis = new int[n];
        for (int[] rs : roads) {
            add(rs[0], rs[1], rs[2]);
            add(rs[1], rs[0], rs[2]);
        }
        // 第一个维度表示距离, 第二个维度表示节点 id
        Queue<long[]> q = new PriorityQueue<>(Comparator.comparingLong(b -> b[0]));
        dis[0] = 0;
        cnt[0] = 1;
        q.offer(new long[]{0, 0});
        while (!q.isEmpty()) {
            long[] b = q.poll();
            int node = (int) b[1];
            if (vis[node] == 1) continue;
            vis[node] = 1;
            for (int i = h[node]; i != -1; i = ne[i]) {
                int j = e[i];
                long cur = dis[node] + w[i];
                if (cur < dis[j]) {
                    cnt[j] = cnt[node];
                    dis[j] = cur;
                    q.offer(new long[]{dis[j], j});
                } else if (cur == dis[j]) cnt[j] = (cnt[j] + cnt[node]) % MOD;
            }
        }
        return cnt[n - 1];
    }

    private void add(int a, int b, int c) {
        e[idx] = b;
        ne[idx] = h[a];
        w[idx] = c;
        h[a] = idx++;
    }
}
```

写一个正确的 dijkstra 并没有看起来那么简单, 就算使用了堆进行优化, 堆中的节点也可能出现重复的情况, 因此必须使用一个 vis 数组用来标识当前找到的最近的节点

此外堆排序本身只有在入堆和出堆时进行重新排序, 因此不要使用会动态变化的数值维护堆, 比如千万不要使用 dis 数组维护堆中元素的顺序, 因为每次对 dis 的修改并不会重构堆

因此堆优化的 dijkstra 需要依赖 pair 进行排序, 在 java 中使用一个二维数组替代, 这里也能看到 vis 数组的作用, 即当同一个节点被更新了很多次, 第一个 poll 出来的一定对应了最短路径, 此时堆中剩下到相同节点的路径都可以依靠这个 vis 数组而失效

# 3.8

## [2834. 找出美丽数组的最小和 (Find the Minimum Possible Sum of a Beautiful Array)](https://leetcode.cn/classic/problems/find-the-minimum-possible-sum-of-a-beautiful-array/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/find-the-minimum-possible-sum-of-a-beautiful-array/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/08/18:45:54:2834.png" />
	</a>
</div>
本题其实是一个数学问题, 简单来说, 可选的数字被 target 分为两部分:

*   一部分属于范围 [1, target - 1], 在范围内选取数字受限, 该范围内, 只要选择了一个数字, 就注定有一个数字不能选; 比如如果选了数字 1, 就不能再选数字 target - 1, 选了数字 2 就不能选择数字 target - 2 ...

    综上, 该范围内可以选择的数字的个数为: $\lfloor\frac{target}{2}\rfloor$ (无论 target 为奇数还是偶数)

*   第二部分属于范围 [target, $\infty$], 该部分的数字随便选择, 没有限制, 所以选的数字越小越好

综上, 为了让数组整体和最小, 需要从范围 [1, target - 1] 中选择 $\lfloor \frac{target}{2}\rfloor$ 个数字 (越小越好), 剩下的比较大的数字都从 [target, $\infty$] 中选择

```java
class Solution {
    private static final int MOD = (int)1e9 + 7;
    public int minimumPossibleSum(int n, int target) {
        int min = Math.min(target >> 1, n);
        int rst = (int)((((long)(1 + min) * min) >> 1) % MOD);
        int re = n - min;
        rst += (int)(((((long)target + target + re - 1) * re) >> 1) % MOD);
        rst %= MOD;
        return rst;
    }
}
```

# 3.12

## [1171. Remove Zero Sum Consecutive Nodes from Linked List](https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/12/10:32:06:1171.png" />
	</a>
</div>

如果将链表看成数组的话, 本题就是要求将子数组和为 0 的部分从链表中去除; 说到子数组和, 很容易想到使用前缀和快速得到任意一个子数组的和

本题的可行解有很多种, 题目并没有要求删除的节点数最多/最少, 题解给出的解法是遍历两次两次, 第一次记录前缀和出现的最后一个位置, 第二次记录前缀和出现的第一个位置

相同前缀出现的两个位置之间的 "子数组" 和一定为 0, 直接跳过即可

```java
class Solution {
    public ListNode removeZeroSumSublists(ListNode head) {
        ListNode pre = new ListNode(0);
        pre.next = head;
        Map<Integer, ListNode> m = new HashMap<>();
        ListNode cur = pre;
        int sum = 0;
        
        while (cur != null) {
            sum += cur.val;
            m.put(sum, cur);
            cur = cur.next;
        }
        
        cur = pre;
        sum = 0;
        
        while (cur != null) {
            sum += cur.val;
            cur.next = m.get(sum).next;
            cur = cur.next;
        }

        return pre.next;
    }
}
```

# 3.13

## [2789. 合并后数组中的最大元素 (Largest Element in an Array after Merge Operations)](https://leetcode.cn/classic/problems/largest-element-in-an-array-after-merge-operations/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/largest-element-in-an-array-after-merge-operations/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/14/10:44:42:2789.png" />
	</a>
</div>

>   如果正向看不容易的话, 为什么不反向看呢

从前向后遍历数组, 如果当前位置比后一个位置小的话, 不能贪心的将当前数字和后一个数字合并: 考虑序列 [3, 4, 5]; 正确的合并顺序应该是 5 先和 4 合并, 最后再和 3 合并

这其实是在诱导是否可以从后向前看, 从后向前遍历数组, 如果后一个数字比前一个数字更大的话, 就执行合并 -> 这种贪心思路是可行的, 因为从后向前遍历时, 数字合并的要求是后一个数字比前要给数字更大, 而后边的数字越合并, 就越能满足比前一个更大的条件

```java
class Solution {
    public long maxArrayValue(int[] nums) {
        long rst = 0;
        int n = nums.length;
        long tmp = 0;
        for (int i = n - 1; i >= 0; i --) {
            if (nums[i] <= tmp) tmp += nums[i];
            else {
                rst = Math.max(rst, tmp);
                tmp = nums[i];
            }
        }
        rst = Math.max(rst, tmp);
        return rst;
    }
}
```

# 3.14

## [930. Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/binary-subarrays-with-sum/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/14/11:29:22:930.png" />
	</a>
</div>

枚举每个子数组的时间复杂度为: $O(n^2)$, 输入大小达到了 $10^4$​ 级别, 肯定超时

注意到可以使用前缀和进行优化, 使用一个 map 记录各个前缀出现的个数; 从前向后遍历整个数组, 对于当前遍历的位置 i, 记录前缀和 sum, 那么所有以 i 结尾的和为 goal 的子数组个数为: map[sum - goal], 即找一下前缀和为 sum - goal 的出现的频率

实际编码的时候, 由于前缀和比较小, 可以使用数组对前缀和进行优化

```java
class Solution {
    private static final int N = (int)3e4 + 10;
    public int numSubarraysWithSum(int[] nums, int goal) {
        int n = nums.length;
        int[] m = new int[N];
        m[0]++;
        int sum = 0;
        int rst = 0;
        for (int i = 0; i < n; i++) {
            sum += nums[i];
            int idx = sum - goal;
            if (idx >= 0) rst += m[idx];
            m[sum]++;
        }
        return rst;
    }
}
```

# 3.15

## [2312. 卖木头块 (Selling Pieces of Wood)](https://leetcode.cn/classic/problems/selling-pieces-of-wood/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/selling-pieces-of-wood/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/16/10:43:41:2312.png" />
	</a>
</div>

题目给出的比较明显的提示是, 每次切割可以沿着垂直方向完全切割, 或者按照水平方向完全切割, 这意味着, **每次切割都会将一整块木头一分为二**

定义状态 f\[i][j] 表示高为 i 的, 宽为 j 的木头可以通过切割或者直接卖出得到的最大价值; 显然本题可以通过记忆化搜索求解

```java
class Solution {
    private static final int N = 210;
    private Map<Integer, Integer> map;
    private long[][] buff;
    public long sellingWood(int m, int n, int[][] prices) {
        this.map = new HashMap<>();
        // bitmode 压缩坐标
        for (int[] price : prices) map.put(price[0] * N + price[1], price[2]);
        this.buff = new long[m + 1][n + 1];
        for (int i = 0; i <= m; i++) Arrays.fill(buff[i], -1);
        return dfs(m, n);
    }
    
    private long dfs(int x, int y) {
        if (x == 0 || y == 0) return 0;
        if (buff[x][y] != -1) return buff[x][y];

        int key = x * N + y;
        long rst = map.getOrDefault(key, 0);
        // 水平方向切割
        for (int i = 1; i < x; i++) rst = Math.max(rst, dfs(i, y) + dfs(x - i, y));
        // 垂直方向切割
        for (int j = 1; j < y; j++) rst = Math.max(rst, dfs(x, j) + dfs(x, y - j));
        
        buff[x][y] = rst;
        return buff[x][y];
    }
}
```

## [238. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/product-of-array-except-self/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/238.png" />
	</a>
</div>

在本题的说明里面提到了不要使用除法, 最简单的做法就是维护一个前后缀乘积数组, 这样每个位置的取值可以通过一个前缀和后缀的乘积得到

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] pre = new int[n + 1];
        pre[0] = 1;
        for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] * nums[i - 1];
        int[] suf = new int[n + 1];
        suf[n] = 1;
        for (int i = n - 1; i >= 0; i--) suf[i] = suf[i + 1] * nums[i];
        int[] rst = new int[n];
        for (int i = 0; i < n; i++) rst[i] = pre[i] * suf[i + 1];
        return rst;
    }
}
```

而在本题的进阶中要求使用常数空间, 那么其实可以将前缀/后缀数组的一部分移到 rst 本身中, 同时再使用一个 local variable 维护没有被计算的后缀/前缀

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] rst = new int[n];
        rst[n - 1] = 1;
        // 将后缀数组移动到 rst 中
        for (int i = n - 2; i >= 0; i --) rst[i] = nums[i + 1] * rst[i + 1];
        // 使用 rst 维护前缀
        int sum = 1;
        for (int i = 1; i < n; i ++) {
            sum *= nums[i - 1];
            rst[i] *= sum;
        }
        return rst;
    }
}
```

# 3.16

## [2684. 矩阵中移动的最大次数 (Maximum Number of Moves in a Grid)](https://leetcode.cn/classic/problems/maximum-number-of-moves-in-a-grid/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/maximum-number-of-moves-in-a-grid/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/16/10:56:40:2684.png" />
	</a>
</div>

定义状态 f\[i][j] 表示从矩阵中位置 (i, j) 处可以移动的最大次数, 每次移动都通过记忆化搜索进行, 最后把第一列中最大的那个返回就行了

```java
class Solution {
    private static final int[][] DIR = {{1, 1}, {-1, 1}, {0, 1}};
    private int[][] grid;
    private int n, m;
    private int[][] buff;
    public int maxMoves(int[][] grid) {
        this.grid = grid;
        this.n = grid.length;
        this.m = grid[0].length;
        this.buff = new int[n][m];
        for (int i = 0; i < n; i++) Arrays.fill(buff[i], -1);
        int rst = 0;
        for (int i = 0; i < n; i++) rst = Math.max(rst, dfs(i, 0));
        return rst;
    }
    
    private int dfs(int x, int y) {
        if (buff[x][y] != -1) return buff[x][y];
        
        int rst = 0;
        
        for (int[] d : DIR) {
            int nx = x + d[0];
            int ny = y + d[1];
            if (nx < 0 || nx >= n || ny < 0 || ny >= m || grid[nx][ny] <= grid[x][y]) continue;
            rst = Math.max(rst, dfs(nx, ny) + 1);
        }
        
        buff[x][y] = rst;
        return buff[x][y];
    }
}
```

## [525. Contiguous Array](https://leetcode.com/problems/contiguous-array/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/contiguous-array/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/525.png" />
	</a>
</div>

本题的难点在于, 输入范围太大了, 达到了 $10^5$ 级别, 最多只能接受时间复杂度为: $O(n\log n)$ 的算法

对于子数组, 一种优化的思路是借助一个 map 一边遍历一边取值, 但是本题要求的是 0 和 1 数量相同的子数组, 通过一个简单的前缀和肯定不能实现 $O(1)$ 查询

本题的思路是: 如果需要查找相同数量的 0 和 1 的子数组, 其实等价于求解 1 的数量和 0 的数量做差为 0 的子数组, 即本题维护的前缀和是整个前缀中 1 和 0 的数量的差值, 这样使用 map 维护差值出现的第一个位置, 后续遇到了相同的差值, 则两个位置之间的子数组, 其中 0 的数量和 1 的数量一定相同

```java
class Solution {
    public int findMaxLength(int[] nums) {
        int n = nums.length;
        int sum = 0;
        Map<Integer, Integer> m = new HashMap<>();
        // 预存的位置 -1, 表示最开始 1 和 0 的数量都是 0
        m.put(0, -1);
        int rst = 0;
        for (int i = 0; i < n; i++) {
            sum += nums[i];
            int len = i + 1;
            int gap = sum - (len - sum);
            // 本来这里 -1 就够了, 都怪上面把 -1 给占用了
            int pre = m.getOrDefault(gap, -2);
            if (pre == -2) m.put(gap, i);
            else rst = Math.max(rst, i - pre);
        }
        return rst;
    }
}
```

# 3.17

## [57. Insert Interval](https://leetcode.com/problems/insert-interval/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/insert-interval/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/17/11:21:16:57.png" />
	</a>
</div>

本题的 newInterval 大小仅为 1, 并且 intervals 已经是事先排好序的了, 因此 intervals 在 newInterval 的作用下可以分为三部分:

*   左侧未和 newInterval 合并的部分
*   和 newInterval 合并的部分
*   右侧未和 newInterval 合并的部分

其中第一部分和第二部分的分隔标志是, 第一部分的 interval 的结束位置小于 newInterval 的开头

```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        List<int[]> list = new ArrayList<>();
        
        int idx = 0;
        int n = intervals.length;
        // 第一部分
        while (idx < n && intervals[idx][1] < newInterval[0]) list.add(intervals[idx ++]);
        
        int l = newInterval[0];
        int r = newInterval[1];
        // 第二部分
        while (idx < n && intervals[idx][0] <= r) {
            l = Math.min(l, intervals[idx][0]);
            r = Math.max(r, intervals[idx ++][1]);
        }
        list.add(new int[]{l, r});
        
        // 第三部分
        while (idx < n) list.add(intervals[idx ++]);
        
        int m = list.size();
        int[][] rst = new int[m][2];
        for (int i = 0; i < m; i++) rst[i] = list.get(i);
        return rst;
    }
}
```

# 3.18

## [452. Minimum Number of Arrows to Burst Balloons](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/452.png" />
	</a>
</div>

其实是等价于求最多重叠区间的个数, 按照区间开头对各个区间排序, 同时维护区间重叠边界 l 和 r

对于给定的一组 l 和 r, 下一组区间左边界一定是后续所有未遍历区间中最小的, 如果下一组区间和 l, r 有重叠 (next[0] < r), 标识这两个区间可以被同一个箭头击穿, 此时继续更新重叠边界 l 和 r

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        Arrays.sort(points, Comparator.comparingInt(p -> p[0]));
        int n = points.length;
        int rst = 0;
        for (int i = 0; i < n; i ++) {
            int l = points[i][0];
            int r = points[i][1];
            int ne = i + 1;
            while (ne < n && points[ne][0] <= r) {
                l = Math.max(l, points[ne][0]);
                r = Math.min(r, points[ne][1]);
                ne ++;
            }
            i = ne - 1;
            rst ++;
        }
        return rst;
    }
}
```

# 3.19

## [1793. 好子数组的最大分数 (Maximum Score of a Good Subarray)](https://leetcode.cn/classic/problems/maximum-score-of-a-good-subarray/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/maximum-score-of-a-good-subarray/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/19/10:43:03:1793.png" />
	</a>
</div>

为了让分数尽可能的大, 在某个数字作为子数组的最小值时, 应该试图让该子数组的长度尽可能大, 即找到某个数字作为子数组的最小值时, 最左侧及最右侧边界 -> 单调栈

维护一个单调递增的单调栈, 新的元素入栈时, 左边界取到栈顶; 当元素弹栈时, 右边界为使其弹栈的元素

```java
class Solution {
    public int maximumScore(int[] nums, int k) {
        int n = nums.length;
        int[] l = new int[n];
        int[] r = new int[n];
        int[] stk = new int[n];
        int e = -1;
        for (int i = 0; i < n; i ++) {
            while (e >= 0 && nums[i] < nums[stk[e]]) {
                int idx = stk[e --];
                // 右边界取到 i, 即不能取到
                r[idx] = i;
            }
        	
            // 左边界为是可以取到的
            if (e == -1) l[i] = 0;
            else l[i] = stk[e] + 1;
            
            stk[++ e] = i;
        }
        
        while (e >= 0) r[stk[e --]] = n;
        
        int rst = 0;
        
        for (int i = 0; i < n; i ++) {
            // 题目给出了 k 作为限制, 需要左右边界在 k 两侧
            if (l[i] <= k && k < r[i]) rst = Math.max(rst, (r[i] - l[i]) * nums[i]);
        }
        
        return rst;
    }
}
```

## [621. 任务调度器](https://leetcode-cn.com/problems/task-scheduler/)

<div style="text-align:center;">
	<a href="https://leetcode-cn.com/problems/task-scheduler/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/621.png" />
	</a>
</div>

考虑只有一种任务时, 完成任务的时间取决于当前任务的个数 m 和冷却间隔 n, 此时完成任务需要的时间为 (m - 1) * (n + 1) + 1

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/621_1.png)

每一行为一轮, 每列为该轮次中执行的任务, 注意到在该种任务的调度中, 除了最后一轮, 剩下的每一轮都需要 n 个时间冷却, 因此最后一行只需要 1 个单位的时间完成执行

在多种任务的场景中, 上图的行数取决于出现频率最多的任务

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/621_2.png)

可以注意到上图中, 出现频率最多的任务是 A 和 B, 而任务 C 出现频率比较小, 可以直接插入到 A 和 B 的冷却时间内, 因此完成任务需要的时间为 (m - 1) * (n + 1) + 2, 除了最后一行只需要 2 个单位的时间之外, 剩下的每行都需要 n + 1 个时间

注意到上图中比较关键的点在于, 除了出现频率最多的任务之外, 剩下的任务可以插入到任务的冷却时间内, 继续增加任务的种类数, 使其填充冷却的空闲时间内

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/621_3.png)

注意到此时不会有任何的冷却时间闲置, 此时完成任务需要的时间等于任务的个数, 然而, 任务的种类可能有很多, 但频率都不大, 因此可能出现冷却时间不足以安排所有小频率的任务

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/621_4.png)

在上图所示的任务编排下, 尽管每轮需要的时间增加了, 但按照这种编排方式, 不会出现任何的冷却空闲时间, 即此时任务完成的时间等于任务个数

综上, 可以通过出现频率最大的任务个数和冷却时间计算一个可能的, 包含了冷却时间的任务安排方式; 而如果任务种类太大, 就可以将任务个数视为任务的完成时间

```java
class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] freq = new int[26];
        for (int i = 0; i < tasks.length; i ++) {
            freq[tasks[i] - 'A']++;
        }
        Arrays.sort(freq);
        int maxLen = 1;
        // 计算出现频率最多的任务种类数
        for (int i = 24; i >= 0 && freq[25] == freq[i]; i --, maxLen ++);
        // 返回两者中最大的那个
        return Math.max((freq[25] - 1) * (n + 1) + maxLen, tasks.length);
    }
}
```

# 3.20

## [1969. 数组元素的最小非零乘积 (Minimum Non-Zero Product of the Array Elements)](https://leetcode.cn/classic/problems/minimum-non-zero-product-of-the-array-elements/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/minimum-non-zero-product-of-the-array-elements/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/20/10:49:13:1969.png" />
	</a>
</div>

对于任意的参与交换的两个数字 x 和 y, 假设在当前轮次的交换中, x 将 0 变为了 1, y 将 1 变为了 0, 交换的为第 k 位, 则有: $y = y' + 2^{k}$

交换之前 x 和 y 的乘积为: $x \times (y' + k) = x \times y' + x\times 2^{k}$; 交换之后 x 和 y 的乘积为: $(x + 2^{k})\times y' = x\times y' + y'\times2^{k}$

交换后, 为了乘积变小, 应该让 $x > y'$, 在本题中, y' 不能取到 0, 因此最小 y' 也就是 1

本题给定的输入范围是: $[1, 2^{p} - 1]$, 该区间内一共有 $2^{p} - 1$ 个数字, 除开最后的数字 $2^{p} - 1$ 之外, 将剩余的 $2^{p} - 2$ 个数字相互配对, 剩下的数字一定都可以组合交换后得到 1 和 $2^{p} - 2$ 的乘积, 一共有 $2^{p - 1} - 1$ 对这样的乘积

因此本题的返回值为: $(2^{p} - 1)\times(2^{p} - 2)^{(2^{p - 1} - 1)}$, 由于幂级数太大, 这里需要使用快速幂求解

```java
class Solution {
    private static final int MOD = (int)1e9 + 7;
    public int minNonZeroProduct(int p) {
        if (p == 1) return 1;
        long a = (1L << p) - 1;
        long b = a - 1;
        long c = (1L << (p - 1)) - 1;
        a %= MOD;
        return (int)((a * pow(b, c)) % MOD);
    }

    private long pow(long x, long factor) {
        long rst = 1L;
        long base = x % MOD;

        // factor 的二进制各个 bit 一定都是 1, 因此这里的 for 循环内并没有对当前 bit 为 1 的判别
        for (; factor > 0; factor >>= 1, base = (base * base) % MOD) {
            rst *= base;
            rst %= MOD;
        }

        return rst;
    }
}
```

# 3.21

## [2671. 频率跟踪器 (Frequency Tracker)](https://leetcode.cn/classic/problems/frequency-tracker/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/frequency-tracker/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/21/10:10:18:2671.png" />
	</a>
</div>

维护每个数字出现的频率: map 和每种频率的数字的个数: freq; 同步更新 map 和 freq

```java
class FrequencyTracker {
    private static final int N = (int)1e5 + 10;
    private int[] freq;
    private int[] map;

    public FrequencyTracker() {
        this.freq = new int[N];
        this.map = new int[N];
        freq[0] = N;
    }
    
    public void add(int number) {
        freq[map[number]] --;
        map[number] ++;
        freq[map[number]] ++;
    }
    
    public void deleteOne(int number) {
        if (map[number] == 0) return;
        freq[map[number]] --;
        map[number] --;
        freq[map[number]] ++;
    }
    
    public boolean hasFrequency(int frequency) {
        return freq[frequency] != 0;
    }
}
```

# 3.22

## [2617. 网格图中最少访问的格子数 (Minimum Number of Visited Cells in a Grid)](https://leetcode.cn/classic/problems/minimum-number-of-visited-cells-in-a-grid/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/minimum-number-of-visited-cells-in-a-grid/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/26/10:43:20:2617.png" />
	</a>
</div>
本题最朴素的做法就是暴力枚举, 定义状态 f\[i][j] 表示从左上角到达位置 (i, j) 需要移动的最少次数, 对于枚举到的每个位置 (i, j), 其移动方式只有从上到下和从左到右, 直接挨个枚举即可, 整体时间复杂度为: $O(m\times n\times(n + m))$, 在本题的输入中达到了 $10^{10}$​ 级别, 必定超时

对于某个位置 f(i, j) 其可以向右到达的最远距离是确定的: f(i, j) + j; 其可以向下到达的最远距离也是确定的: f(i, j) + i, 因此这里使用贪心的想法进行优化, 为每一行/每一列维护一个优先队列, 堆顶为当前行/列中 f 最小的位置, 这样可以在 $O(1)$ 的时间内完成状态转移, 并在 $O(\log n)$ 的时间内完成新值的插入

```java
class Solution {
    private static final int INF = 0x3f3f3f3f;
    public int minimumVisitedCells(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;

        int[][] f = new int[n][m];
        for (int i = 0; i < n; i ++) Arrays.fill(f[i], INF);

        List<Queue<Integer>> rows = new ArrayList<>(n);
        List<Queue<Integer>> cols = new ArrayList<>(m);
        for (int i = 0; i < n; i ++) {
            int row = i;
            rows.add(new PriorityQueue<>(Comparator.comparingInt(c -> f[row][c])));
        }
        for (int j = 0; j < m; j ++) {
            int col = j;
            cols.add(new PriorityQueue<>(Comparator.comparingInt(r -> f[r][col])));
        }

        f[0][0] = 1;
        
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < m; j ++) {
                Queue<Integer> row = rows.get(i);
                while (!row.isEmpty()) {
                    int c = row.peek();
                    if (grid[i][c] + c >= j) {
                        f[i][j] = Math.min(f[i][j], f[i][c] + 1);
                        break;
                    } else row.poll();
                }

                Queue<Integer> col = cols.get(j);
                while (!col.isEmpty()) {
                    int r = col.peek();
                    if (grid[r][j] + r >= i) {
                        f[i][j] = Math.min(f[i][j], f[r][j] + 1);
                        break;
                    } else col.poll();
                }

                if (f[i][j] != INF) {
                    row.offer(j);
                    col.offer(i);
                }

                rows.set(i, row);
                cols.set(j, col);
            }
        }

        return f[n - 1][m - 1] == INF ? -1 : f[n - 1][m - 1];
    }
}
```

>   整体时间复杂度: $O(n\times m\times(\log(n\times m)))$

## [234. Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/palindrome-linked-list/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/25/11:08:08:234.png" />
	</a>
</div>

如果把链表扒下来, 放进数组里, 其实本题还是很好判断的, 但是本题的 fellow up 中限制了时间和空间复杂度, 因此这里的策略是使用快慢指针找到链表的中心, 然后从中心处递归执行反转链表, 将反转的链表和原链表比较即可判断是否为回文链表

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode pre = new ListNode();
        pre.next = head;
        ListNode fast = pre;
        ListNode slow = pre;
        while (fast != null) {
            fast = fast.next;
            if (fast != null) {
                fast = fast.next;
                slow = slow.next;
            }
        }
        ListNode tail = reverse(slow.next);
        slow.next = null;
        while (head != null && tail != null) {
            if (head.val != tail.val) return false;
            head = head.next;
            tail = tail.next;
        }
        return true;
    }
    
    private ListNode reverse(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode newHead = reverse(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
}
```

# 3.23

## [143. Reorder List](https://leetcode.com/problems/reorder-list/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/reorder-list/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/25/11:19:04:143.png" />
	</a>
</div>
简单来说, 本题需要把链表的后半部分反转, 并和前半部分交叉; 因此首先需要通过快慢指针明确链表的后半部分, 然后将其反转; 最后同时更新前半部分的头和后半部分的头, 实现链表交叉

```java
class Solution {
    public void reorderList(ListNode head) {
        ListNode pre = new ListNode();
        pre.next = head;
        ListNode fast = pre;
        ListNode slow = pre;

        while (fast != null) {
            fast = fast.next;
            if (fast != null) {
                fast = fast.next;
                slow = slow.next;
            }
        }

        ListNode reverse_head = reverse(slow.next);
        slow.next = null;
        ListNode dummy = new ListNode();
        dummy.next = reverse_head;
        ListNode p = pre.next, q = dummy.next;

        ListNode cur = new ListNode();
        while (p != null && q != null) {
            cur.next = p;
            p = p.next;
            cur = cur.next;
            cur.next = q;
            q = q.next;
            cur = cur.next;
        }
        if (p != null) cur.next = p;
        if (q != null) cur.next = q;
		
        // 多余的操作
        pre.next = null;
        dummy.next = null;
    }
    private ListNode reverse(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode new_head = reverse(head.next);
        head.next.next = head;
        head.next = null;
        return new_head;
    }
}
```

# 3.24

## [322. 零钱兑换 (Coin Change)](https://leetcode.cn/classic/problems/coin-change/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/coin-change/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/322.png" />
	</a>
</div>

定义状态 f[i] 标识构成数字 i 需要的最少硬币数, 则可以根据最后一个硬币的取值进行状态划分, 整体上执行记忆化搜索


```java
class Solution {
    private static final int INF = 0x3f3f3f3f;
    private int[] cs;
    private int[] buff;
    public int coinChange(int[] coins, int amount) {
        this.cs = coins;
        this.buff = new int[amount + 1];
        Arrays.fill(buff, -1);
        int rst = dfs(amount);
        return rst == INF ? -1 : rst;
    }
    
    private int dfs(int x) {
        if (x == 0) return 0;
        
        if (buff[x] != -1) return buff[x];
        
        int rst = INF;
        
        for (int i = 0; i < cs.length; i ++) {
            if (x - cs[i] >= 0) rst = Math.min(rst, dfs(x - cs[i]) + 1);
        }
        
        buff[x] = rst;
        
        return buff[x];
    }
}
```

## [518. 零钱兑换 II (Coin Change II)](https://leetcode.cn/classic/problems/coin-change-ii/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/coin-change-ii/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/518.png" />
	</a>
</div>

注意到方案需要去重, 即 2 + 2 + 1 和 1 + 2 + 2 本质上是同一种方案, 因此这里进行枚举的时候还是使用了 dp 定义状态, 定义 f\[i][j] 表示前 i 种硬币可以凑成 j 的方案的个数, 在考虑状态转移的时候, 考虑的其实是尾数, 即当前枚举的第 i 种硬币的个数, 有: $f[i][j] = f[i - 1][j] + f[i - 1][j - coins[i]] + f[i - 1][j - 2\times coins[j]] + ...$

枚举 i 和 j 需要复杂度 $O(m\times n)$, 在此基础上再对当前硬币的个数进行枚举, 时间复杂度来到了 $O(m\times n^2)$

```java
class Solution {
    public int change(int amount, int[] coins) {
        int n = amount;
        int m = coins.length;
        int[][] f = new int[m + 1][n + 1];
        f[0][0] = 1;
        for (int i = 1; i <= m; i ++) {
            for (int j = 0; j <= n; j ++) {
                f[i][j] = f[i - 1][j];
                for (int k = 1; coins[i - 1] * k <= j; k ++) f[i][j] += f[i - 1][j - k * coins[i - 1]];
            } 
        }
        return f[m][n];
    }
}
```

>   再本题中, 计算量达到了 $7.5\times 10^9$ 按理来说应该超时, 可能是 leetcode 的 oj 比较宽松, 这种写法居然能过

注意到状态 $f[i][j + coins[i]] = f[i - 1][j + coins[i]] + f[i - 1][j] + f[i - 1][j - coins[j]] + ... = f[i - 1][j + coins[i]] + f[i][j]$, 通过这种方式可以优化第三层的枚举, 把时间复杂度降低到 $O(m\times n)$

此外还注意到本行状态 f\[i][...] 仅仅和上一行 f\[i - 1][...] 有关, 因此还可以对二维的状态数组进行状态压缩, 尽可能利用 space locality

```java
class Solution {
    public int change(int amount, int[] coins) {
        int n = amount;
        int m = coins.length;
        int[] f = new int[n + 1];
        f[0] = 1;
        for (int i = 1; i <= m; i ++) {
            for (int j = coins[i - 1]; j <= n; j ++) {
                f[j] += f[j - coins[i - 1]];
            } 
        }
        return f[n];
    }
}
```

## [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/find-the-duplicate-number/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/287.png" />
	</a>
</div>

本题的建图, 双指针的做法确实有点抽象了, 这里使用题解中另外的一个思路: 二进制枚举

维护两个大小为 32 的数组 x 和 y; 其中 x 保存的 1 ~ n 各个数字的二进制表示中的 1, 而 y 保存的是 nums 数组中各个数组的二进制表示中的 1

那么重复出现的数字, 在 y 数组中对应 bit 一定大于在 x 中的对应 bit, 以示例 1 为例:

|         |  1   |  3   |  4   |  2   |  2   |  x   |  y   |
| :-----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 第 0 位 |  1   |  1   |  0   |  0   |  0   |  2   |  2   |
| 第 1 位 |  0   |  1   |  0   |  1   |  1   |  2   |  3   |
| 第 2 位 |  0   |  0   |  1   |  0   |  0   |  1   |  1   |

因此重复数字的第一位 bit 一定为 1 -> $(010)_2$ -> 2

这种做法的正确性可以分为两个阶段证明:

*   数字仅重复一次: 此时 x 保存的是 n 个数字的各个二进制, 而 y 保存的是 n + 1 个数字的各个二进制, 因此 y 中多出的部分恰好组成了重复数组

*   数字重复了多次: 此时必然存在 1 ~ n 中的某个数字被当前数字替换掉了, 假设当前重复数字为 a, 被替换掉的数字为 b, 按 bit 考虑 a 和 b

    *   a 的某个 bit 为 0, b 的某个 bit 也为 0: 此时 x 和 y 的对应 bit 关系满足 x <= y (这里的小于号是为了兼容 a 可能替换掉了多个数字的情况)
    *   a 的某个 bit 为 1, b 的某个 bit 为 0: 此时 x 和 y 的对应 bit 关系满足 x > y
    *   a 的某个 bit 为 1, b 的某个 bit 也为 1: 此时 x 和 y 的对应 bit 关系满足 x > y (毕竟 x 是 n + 1 个数字的二进制统计, 肯定是多一个的)
    *   a 的某个 bit 为 0, b 的某个 bit 为 1: 此时 x 和 y 对应 bit 的关系满足 x < y


本题的目的是找到重复的数字 a, 也即确定 a 的二进制中为 1 的部分, 可以注意到 a 的二进制为 0 的部分一定都满足 x <= y; 而 a 的二进制为 1 的部分一定满足 x > y, 因此只要 x > y, 那么重复数字中的该 bit 一定为 1

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int[] x = new int[32];
        int[] y = new int[32];
        int n = nums.length - 1;
        
        for (int i = 1; i <= n; i ++) {
            for (int j = 0; j < 32; j ++) {
                if (((i >> j) & 1) == 1) x[j] ++;
            }
        }
        
        for (int num : nums) {
            for (int j = 0; j < 32; j ++) {
                if (((num >> j) & 1) == 1) y[j] ++;
            }
        }
        
        int rst = 0;
        for (int i = 0; i < 32; i ++) {
            if (y[i] > x[i]) rst |= (1 << i);
        }
        
        return rst;
    }
}
```

# 3.25

## [442. Find All Duplicates in an Array](https://leetcode.com/problems/find-all-duplicates-in-an-array/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/find-all-duplicates-in-an-array/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/442.png" />
	</a>
</div>

重复数字的题目一般而言可以考虑使用 hash 映射的方式解决, 将数字 num 映射到数组中下标为 num - 1 的位置处; 

对于遍历到的每个位置 i, 其当前数字为 x, 有 nums[i] = x, 如果 num[x - 1] != x 就让下标 i 和 x - 1 处进行交换; 而如果一开始位置 i 处的数字 x, 就已经满足了 num[x - 1] = x, 则说明数字 x 出现了重复

要特别注意的是, 数字 x 出现了重复就意味着其占用了其他数字的位置, 为了避免数字 x 多次加入结果集, 需要在将其放入结果集后置位负数, 避免被重复添加

```java
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> rst = new ArrayList<>();
        int n = nums.length;
        for (int i = 0; i < n; i ++) {
            if (nums[i] == i + 1 || nums[i] < 0) continue;
            if (nums[nums[i] - 1] == nums[i]) {
                rst.add(nums[i]);
                nums[i] *= -1;
            }
            else {
                swap(i, nums[i] - 1, nums);
                // 持续交换, 使得要么当前位置 i 已经保存了数字 i + 1, 要么当前位置需要加入结果集
                i --;
            }
        }
        return rst;
    }
    
    private void swap(int i, int j, int[] arr) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

## [41. 缺失的第一个正数 (First Missing Positive)](https://leetcode.cn/classic/problems/first-missing-positive/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/first-missing-positive/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/41.png" />
	</a>
</div>

本题关心的数字是正整数, 要求所有未出现的数字中最小的那个, 返回值最小为 1, 最大也只有 n + 1 (数组长度), 因此本题也可以采用 hash 映射的方式, 将所有的正整数 i 映射到下标为 i - 1 的位置处

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n; i ++) {
            while (nums[i] >= 1 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) swap(nums[i] - 1, i, nums);
        }
        for (int i = 0; i < n; i ++) {
            if (nums[i] != i + 1) return i + 1;
        }
        return n + 1;
    }

    private void swap(int i, int j, int[] arr) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

# 3.26

## [2642. 设计可以求最短路径的图类 (Design Graph With Shortest Path Calculator)](https://leetcode.cn/classic/problems/design-graph-with-shortest-path-calculator/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/design-graph-with-shortest-path-calculator/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/26/10:31:50:2642.png" />
	</a>
</div>

本题一边增加有向边, 一边求解最短路, 由于边权为正数 (不存在负环), 因此可以通过 dijkstra 求解最短路

最开始的想法是尽可能将计算工作放在初始化的环节中, 即在初始化中计算各个点到其他节点的最短路, 后续添加新边后, 增量式更新最短路 -> 假设新增了最短路 a -> b 开销为 c, 则重新枚举图中任意两个节点 i 和 j, 并试图使用 i -> a -> b -> j 这条路更新 i -> j 的最短路

整体上更新的时间复杂度为 $O(n^2)$, 而建图求解最短路的时间复杂度为: $O(n^2\log n)$

但是注意到本题的 n 取到了 100, 而新边的添加次数最多也为 100, 整体上调用更新函数的此次数并没有那么多, 主要的开销都是在建图阶段; 因为查询的次数比较少, 这里采用的是每个查询单独寻路的方式, 降低建图时的开销

```java
class Graph {
    private static final int INF = 0x3f3f3f3f;
    private int[] h;
    private int[] e;
    private int[] ne;
    private int[] w;
    private int idx;

    public Graph(int n, int[][] edges) {
        this.h = new int[n];
        Arrays.fill(h, -1);
        int m = edges.length + 110;
        this.e = new int[m];
        this.ne = new int[m];
        this.w = new int[m];
        this.idx = 0;
        for (int[] edge : edges) add(edge[0], edge[1], edge[2]);
    }

    public void addEdge(int[] edge) {
        add(edge[0], edge[1], edge[2]);
    }

    public int shortestPath(int node1, int node2) {
        int n = h.length;
        int[] dis = new int[n];
        Arrays.fill(dis, INF);
        dis[node1] = 0;
        Queue<int[]> q = new PriorityQueue<>(Comparator.comparingInt(n2 -> n2[1]));
        q.offer(new int[]{node1, 0});
        while (!q.isEmpty()) {
            int[] tmp = q.poll();
            if (dis[tmp[0]] < tmp[1]) continue;
            dis[tmp[0]] = tmp[1];
            if (tmp[0] == node2) return dis[node2];
            for (int i = h[tmp[0]]; i != -1; i = ne[i]) {
                int j = e[i];
                if (dis[j] > dis[tmp[0]] + w[i]) q.offer(new int[]{j, dis[tmp[0]] + w[i]});
            }
        }
        return -1;
    }

    private void add(int a, int b, int c) {
        e[idx] = b;
        ne[idx] = h[a];
        w[idx] = c;
        h[a] = idx ++;
    }
}
```







