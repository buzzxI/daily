# 3.1

## [2369. 检查数组是否存在有效划分 (Check if There is a Valid Partition For The Array)](https://leetcode.cn/classic/problems/check-if-there-is-a-valid-partition-for-the-array/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/check-if-there-is-a-valid-partition-for-the-array/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/03/02/11:11:26:2369.png" />
	</a>
</div>
需要将一个数组划分为若干子数组, 而不是若干子序列 !

本题可以通过定义状态 (dp/记忆化搜索) 解决, 状态 f[i] 表示前 i 个数字是否可以构成一个有效的划分

如果使用记忆化搜索, 显然把 f[i] 作为结尾考虑时, f[i] 一定属于最后的两个/三个数字的子数组

即要么有 f[i] = f\[i - 1]( = f[i - 2]), 要么有 f[i] = f[i - 1] + 1 = f[i - 2] + 2; 在满足该条件的基础上, 再记忆化搜索前一个子数组 (i - 2 或 i - 3)

```java
class Solution {
    private int[] nums;
    private int[] buff;
    public boolean validPartition(int[] nums) {
        this.nums = nums;
        int n = nums.length;
        this.buff = new int[n];
        Arrays.fill(buff, -1);
        return dfs(n - 1);
    }
    
    private boolean dfs(int idx) {
        if (idx < 0) return true;
        if (buff[idx] != -1) return buff[idx] == 1;
        
        if (idx == 0) {
            buff[idx] = 0;
            return false;
        }
        
        buff[idx] = 0;
        
        if (nums[idx] == nums[idx - 1] && dfs(idx - 2)) buff[idx] = 1;
        else if (idx > 1) {
            if (nums[idx] == nums[idx - 1] && nums[idx] == nums[idx - 2] && dfs(idx - 3)) buff[idx] = 1;
            if (nums[idx] == nums[idx - 1] + 1 && nums[idx] == nums[idx - 2] + 2 && dfs(idx - 3)) buff[idx] = 1;
        }
        
        return buff[idx] == 1;
    }
}
```



