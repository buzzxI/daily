# 3.2

## [564. 寻找最近的回文数](https://leetcode-cn.com/problems/find-the-closest-palindrome/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/564.png)

这里主要参考了[题解](https://leetcode-cn.com/problems/find-the-closest-palindrome/solution/xun-zhao-zui-jin-de-hui-wen-shu-by-leetc-biyt/)

直观上我们对于一个特定的数字，为了实现最近的回文，我们肯定希望改变低位，比如`12345`

如果数字可以实现回文，我们希望数字是`12321`，即将低位的`45`修改，修改后的数字和高位的`12`形成对称的关系

所以写法已经出来了，就是将字符串从中间截断，然后低位部分和高位部分形成轴对称的关系

但凡事总有例外，比如：`12399`，我们如果按照上面的思路，构建的字符串将是：`12321`，但实际中和它最近的回文数为：`12421`

类似的，比如：`99300`，如果按照上面的思路，构建的字符串将是：`99399`，但实际中和它最接近的是`99299`

所以我们需要将上面的思路修正为：我们将字符串截断后一共有三个候选，要么原封不动的将其对称过去，要么减一之后对称过去，要么加一之后对称过去

这还没完，比如`100`，这个数，如果按照上面的思路，候选变为了：`9, 101, 111`

> 这里问题就出现在9这里
>
> 本身这个字符串长度为奇数长，截断后为`10`，那么我们对称的时候应该将其翻转，然后从第二位开始复制
>
> 如果我们减一变为了9，然后再从第二位开始复制，就只能复制空了
>
> 即`10`的出现，使得**减一后的字符串的奇偶性发生了改变**
>
> 同样的，`999`的候选为：`989, 999, 10001`，因为`99`的出现，使得**加一后字符串的奇偶性发生的改变**

我们需要将结果集进行修正，即对于长度为len的字符串，提前存入：$10 ^ {len - 1} - 1, 10 ^{len} + 1$

> 存入$10 ^ {len - 1} - 1$是为了防止`10`这样的出现导致了字符串奇偶性发生了变化
>
> 存入$10 ^ {len} + 1$是为了防止：`99`的出现导致了字符串奇偶性的变化

```java
class Solution {
    public String nearestPalindromic(String n) {
        long num = Long.parseLong(n);
        //获取候选集，一共5个（不重叠的情况下是5个）
        Set<String> candidates = getStrings(n);
        String rst = "";
        long gap = Integer.MAX_VALUE;
        for (String s : candidates) {
            if (n.equals(s)) continue;
            long snum = Long.parseLong(s);
            long sgap = Math.abs(snum - num);
            if (sgap < gap) {
                gap = sgap;
                rst = s;
            }else if (sgap == gap && snum < Long.parseLong(rst)) {
                rst = s;
            }
        }
        return rst;
    }

    private Set<String> getStrings(String n) {
        Set<String> rst = new HashSet<>();
        int len = n.length();
        rst.add(getPow(len, 1));
        rst.add(getPow(len - 1, -1));
        long half = Long.parseLong(n.substring(0, (len + 1) / 2));
        
        StringBuilder builder = new StringBuilder();
        for (int i = -1; i <= 1; i++) {
            builder.delete(0, builder.length());
            long tmp = half + i;
            builder.append(tmp);
            String tail = reverse(builder.toString());
            if ((len & 1) == 1) {
                builder.append(tail.substring(1));
            }else {
                builder.append(tail);
            }
            rst.add(builder.toString());

        }
        return rst;
    }
    
    private String getPow(int len, int factor) {
        long base = 1;
        for (int i = 0; i < len; i++) {
            base *= 10;
        }
        StringBuilder builder = new StringBuilder();
        return builder.append(base + factor).toString();
        
    }

    private String reverse(String origin) {
        char[] tmp = origin.toCharArray();
        int i = 0;
        int j = tmp.length - 1;
        while (i < j) {
            char c = tmp[i];
            tmp[i] = tmp[j];
            tmp[j] = c;
            i++;
            j--;
        }
        return new String(tmp);
    }
}
```



# 3.3

## [258. 各位相加](https://leetcode-cn.com/problems/add-digits/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/258.png)

正常一个递归很好求解

但是现在它要求时间复杂度为`o(1)`

我们考虑一个数：$num = a_0 + 10 \times a_1 + 10 \times a_2 +... = \sum_{i = 0} a_i\times 10 ^{i}$

这里面所有的：$a_i$依次对应num中的个位，十位，百位...

我们给这个式子变形：$\sum_{i = 0} a_i\times 10 ^{i} = \sum_{i = 0}a_i\times (10^i - 1 + 1) = \sum_{i = 0}a_i + \sum_{i = 0}a_i\times (10 ^ i - 1)$

式子的第一项就是我们每次递归的目标

而对应第二项：$\sum_{i = 0}a_i\times (10 ^ i - 1)$，永远是9的倍数

> i为0的时候为$0$
>
> 当i为1的时候为$9\times a_1$
>
> ...

等到下一轮递归的时候有：
$\sum_{i = 0} a_i= \sum_{i = 0} b_i\times 10^i = \sum_{i = 0}b_i + \sum_{i = 0}b_i\times (10 ^ i - 1) = ...$

最终我们求的就是$\text{num} \mod 9$

其实也并不完全正确，因为这个题目说每次将各位相加，其实结果集的范围就是：`[1, 9]`

> 也可能为0，此时num就是0

而单纯的进行取模结果集为`[0, 8]`，问题就出现在0上

所以如果取模不为0，那么直接返回取模结果就好

如果取模为0，还要考虑num是不是0

```java
class Solution {
    public int addDigits(int num) {
        int rst = num % 9;
        if (rst == 0) {
            return num == 0 ? 0 : 9;
        }
        return rst;
    }
}
```

# 3.4

## [2104. 子数组范围和](https://leetcode-cn.com/problems/sum-of-subarray-ranges/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/2104.png)

这个题不能局限于求出每个子数组的最大值和最小值的差

可以转换一个思路，我们是否可以求出所有子数组最小值的和，以及所有子数组最大值的和，二者做差，就是我们需要的结果

现在转化为求出所有子数组最小值的和（以及最大值的和），而求解所有子数组最小值的和其实也并不需要枚举所有的子数组

我们可以枚举数组中的所有位置，对于每个位置我们求解出它作为最小值的最大区间范围，有了这个范围，我们可以计算出以当前值为最小值的子数组的个数；这样枚举每个位置的个数和当前位置乘积，最后再加和，得到的就是所有子数组的最小值的和

> 比如当前位置下标索引为i，以当前位置为最小值的左边界的下标为j（`nums[j] < nums[i]`），右边界为k（`nums[k] < nums[i]`）
>
> 那么以当前位置为最小值的区间的个数为：`(k - i) * (i - j)`
>
> 枚举每个位置的个数和当前位置的值相乘并求和：$\sum_{i = 0} nums[i]\times(k_i - i)\times(i - j_i) $

好了现在问题转化为对于某一个位置，以它为最小值（最大值）的左右边界，这其实就是用单调栈了

> 以前总结过单调栈就是求以当前位置为最小值（最大值）的区间的边界的

对于求出某个位置为子数组最小值的边界，可以使用一个单调递增的栈，这样每次入栈前栈顶就是左边界，入栈后导致当前位置出栈的就是右边界

```java
class Solution {
    public long subArrayRanges(int[] nums) {
        int len = nums.length;
        //某个位置为最小值的子数组左边界
        int[] minLeft = new int[len];
        //某个位置为最小值的子数组的右边界，实际中可以不用这个右边界
        int[] minRight = new int[len];
        int[] maxLeft = new int[len];
        int[] maxRight = new int[len];
        Deque<Integer> minStack = new ArrayDeque<>();
        Deque<Integer> maxStack = new ArrayDeque<>();
        for (int i = 0; i < nums.length; i++) {
            //单调栈递增的栈，当前位置小于栈顶，栈顶元素出栈，同时栈顶元素的右边界确定
            while (!minStack.isEmpty() && nums[i] < nums[minStack.peekLast()]) {
                int tmp = minStack.pollLast();
                minRight[tmp] = i;
            }
            //入栈的时候确定左边界，可能为栈顶可以能为-1（入栈的时候栈已经空了）
            minLeft[i] = minStack.isEmpty() ? -1 : minStack.peekLast();
            minStack.offerLast(i);
            while (!maxStack.isEmpty() && nums[i] > nums[maxStack.peekLast()]) {
                int tmp = maxStack.pollLast();
                maxRight[tmp] = i; 
            }
            maxLeft[i] = maxStack.isEmpty() ? -1 : maxStack.peekLast();
            maxStack.offerLast(i);
        }
        //遍历玩全部元素后，栈中可能还存在元素，此时认为他们的右边界为len
        while(!minStack.isEmpty()) {
            minRight[minStack.pollLast()] = len;
        }
        while (!maxStack.isEmpty()) {
            maxRight[maxStack.pollLast()] = len;
        }
        long rst = 0;
        long minRst = 0;
        long maxRst = 0;
        for (int i = 0; i < len; i++) {
            //这里面强制类型转换很关键
            rst += (long)((i - maxLeft[i]) * (maxRight[i] - i) - (i - minLeft[i]) * (minRight[i] - i)) * nums[i];
            
        }
        return rst;
    }
}
```

## [799. 香槟塔](https://leetcode-cn.com/problems/champagne-tower/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/799.png)

某一层的杯子最多可以从两个位置接收到酒，如果将所有的酒杯按照矩阵的形式排列，那么对于第i层第j列的位置，它可以获取到从第i - 1层第j列和第j - 1列两个位置的酒

此外为了让某一层某列获取到上一层的酒，必须保证上一层对应列已满（在本题中表示流经的酒的量大于1）

定义`dp[i][j]`表示流经第i层第j列酒的量，那么显然`dp[0][0] = poured(倾倒香槟总杯数)`

特别的对于任意一个位置有：

* `dp[i][j] += (dp[i - 1][j] - 1) / 2`，当且仅当`dp[i - 1][j] > 1`
* `dp[i][j] += (dp[i - 1][j - 1] - 1) / 2`，当且仅当`j > 0`且`dp[i - 1][j - 1] > 1`

返回的时候注意，他要求的并不是流经某个位置的酒的流量，而是某个位置满的程度，所以如果流量大于1的话就返回1

```java
class Solution {
    public double champagneTower(int poured, int query_row, int query_glass) {
        double[][] dp = new double[query_row + 1][query_glass + 1];
        dp[0][0] = poured;
        for (int i = 1; i <= query_row; i++) {
            for (int j = 0; j <= Math.min(i, query_glass); j++) {
                if (dp[i - 1][j] > 1) dp[i][j] += (dp[i - 1][j] - 1) / 2;
                if (j > 0 && dp[i - 1][j - 1] > 1) dp[i][j] += (dp[i - 1][j - 1] - 1) / 2;
            }
        }
        return dp[query_row][query_glass] >= 1 ? 1 : dp[query_row][query_glass];
    }
}
```

获取到状态转移方程后发现，当前行某列的取值仅仅和上一行对应列，以及上一行前一列有关

这样的话就可以通过在内层遍历的时候反向遍历对dp数组进行一维优化

```java
class Solution {
    public double champagneTower(int poured, int query_row, int query_glass) {
        double[] dp = new double[query_glass + 1];
        dp[0] = poured;
        for (int i = 1; i <= query_row; i++) {
            for (int j = Math.min(i, query_glass); j >= 0; j--) {
                dp[j] = dp[j] > 1 ? (dp[j] - 1) / 2 : 0;
                if (j > 0 && dp[j - 1] > 1) {
                    dp[j] += (dp[j - 1] - 1) / 2;
                }
            }
        }
        return dp[query_glass] >= 1 ? 1 : dp[query_glass];
    }
}
```

# 3.5

## [521. 最长特殊序列 Ⅰ](https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/521.png)

这个题就离谱，他说返回两个字符串中的最长特殊序列，按照定义，返回值最多只能有三个，即两个字符串的长度len1，len2，要么就-1

那我们直接返回长的那个不就行了吗，如果两个字符串一样长，就看看这两个长得是不是一样的，如果二者长得也一样，就返回-1

```java
class Solution {
    public int findLUSlength(String a, String b) {
        int lenA = a.length();
        int lenB = b.length();
        if (lenA > lenB) {
            return lenA;
        }else if (lenA < lenB){
            return lenB;
        }else {
            return a.equals(b) ? -1 : lenA;
        }
    }
}
```

> 这个题它要求的是最长特殊序列，就是不一样的序列，以前的题都是最长公共子序列

## [740. 删除并获得点数](https://leetcode-cn.com/problems/delete-and-earn/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/740.png)

类似于打家劫舍

先统计词频，然后从头向后进行dp

定义`dp[i]`表示前i可以获得的最大点数，显然`dp[i] = Math.max(dp[i - 1], dp[i - 2] + i * freq[i])`

`dp[i]`要么选择当前数字i要么不选，从二者中选择一个最大的返回

```java
class Solution {
    private static final int LEN = (int)1e4;
    public int deleteAndEarn(int[] nums) {
        int[] dp = new int[LEN + 1];
        int[] freq = new int[LEN + 1];
        for (int num : nums) {
            freq[num]++;
        }
        dp[1] =  freq[1];
        for (int i = 2; i <= LEN; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + freq[i] * i);
        }
        return dp[LEN];
    }
}
```

## [522. 最长特殊序列 II](https://leetcode-cn.com/problems/longest-uncommon-subsequence-ii/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/522.png)

暴力法，就是依次比较当前字符是不是其他字符的子序列，如果是直接判断下一个字符，如果不是就更新max值

此外，我们可以通过预先排序，将字符串降序排序，然后同理依次比较当前字符串是不是其他字符的子序列，如果不是的话，就直接返回

```java
class Solution {
    public int findLUSlength(String[] strs) {
        Arrays.sort(strs, (str1, str2) -> str2.length() - str1.length());
        for (int i = 0; i < strs.length; i++) {
            int j = 0;
            for (; j < strs.length; j++) {
                if (j == i) continue;
                if (isSubSequence(strs[i], strs[j])) {
                    break;
                }
            }
            if (j == strs.length) return strs[i].length();
        }
        return -1;
    }

    private boolean isSubSequence(String str1, String str2) {
        int len1 = str1.length();
        int len2 = str2.length();
        if (len1 > len2) return false;
        int i = 0;
        int j = 0;
        while (i < str1.length() && j < str2.length()) {
            if (str1.charAt(i) == str2.charAt(j)) i++;
            j++;
        }
        return i == len1;
    }
}
```

后来想着使用 map 优化，没什么用，反而时间变得更长了

```java
class Solution {
    public int findLUSlength(String[] strs) {
        Arrays.sort(strs, (str1, str2) -> str2.length() - str1.length());
        int maxLen = strs[0].length();
        int idx = 0;
        Map<String, Integer> map = new HashMap<>();
        while (idx < strs.length && strs[idx].length() == maxLen) {
            map.put(strs[idx], map.getOrDefault(strs[idx], 0) + 1);
            idx++;
        }
        for (String key : map.keySet()) {
            if (map.get(key) == 1) return maxLen;
        }
        for (int i = idx; i < strs.length; i++) {
            int j = 0;
            for (; j < strs.length; j++) {
                if (i == j) continue;
                if (isSubstring(strs[j], strs[i])) break;
            }
            if (j < strs.length) continue;
            return strs[i].length();
        }
        return -1;
    }

    private boolean isSubstring(String str1, String str2) {
        int i = 0;
        int j = 0;
        while (i < str1.length() && j < str2.length()) {
            if (str1.charAt(i) == str2.charAt(j)) j++;
            i++;
        }
        return j == str2.length();
    }
}
```



# 3.6

## [2100. 适合打劫银行的日子](https://leetcode-cn.com/problems/find-good-days-to-rob-the-bank/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/2100.png)

有点类似于找极小值

常规做法是遍历，从`[time, len - time)`枚举每个位置，然后向前，向后找看看是不是满足条件

时间复杂度为：$O(m\times n)$

但我们可以使用空间换时间，对原数组预处理，定义一个数组：`nonIncrease[i]`表示在第`i`天之前有多少天，守卫的人数是不增加的，显然这个可以通过dp计算

同理再定义一个数组：`nonDecrease[i]`表示第`i`天之后有多少天，守卫的人数是不减少的，也通过dp进行计算

这样两次预处理后，我们再对原数组进行枚举的时候，就可以在$O(1)$的时间内得知它前`time`和后`time`天是否满足条件

```java
class Solution {
    public List<Integer> goodDaysToRobBank(int[] security, int time) {
        int len = security.length;
        int[] nonIncrease = new int[len];
        int[] nonDecrease = new int[len];
        List<Integer> rst = new ArrayList<>();
        for (int i = 1; i < len; i++) {
            if (security[i] <= security[i - 1]) nonIncrease[i] = nonIncrease[i - 1] + 1;
        }
        for (int i = len - 2; i >= 0; i--) {
            if (security[i] <= security[i + 1]) nonDecrease[i] = nonDecrease[i + 1] + 1;
        }
        for (int i = time; i < len - time; i++) {
            if (nonIncrease[i] >= time && nonDecrease[i] >= time) rst.add(i);
        }
        return rst;
    }
}
```

## [1359. 有效的快递序列数目](https://leetcode-cn.com/problems/count-all-valid-pickup-and-delivery-options/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1359.png)

动态规划的思想，假设我们已经知道了`n - 1`笔订单，具有`a`种排列

现在多添加了1笔订单，首先要明确的是这笔订单的顺序是固定的，即$p_n$在$d_n$之前

这就相当于我们在原来`n - 1`笔订单中（长度为`2(n - 1)`排列中）插入两个点，且这两个点的顺序是固定的，所以一共具有：$C_{2(n - 1) + 1} ^{2}$种选择

> 在由`2(n - 1)`个点构成的一个排列中，具有`2(n - 1) + 1`个插入点，我们从这些插入点中任选两个，一共具有：$C_{2(n - 1) + 1}^2$种选法
>
> 因为我们知道这两个插入点的顺序，所以这里使用的是$C_m^n$的形式而不是$A_m^n$

将其化简一下就是：$\frac{(2(n - 1) + 1)\times(2(n - 1))}{2} = (2(n - 1) + 1)\times(n - 1)$

但不要忘了，我们的这些插入方式是建立在`n - 1`笔订单具有`a`种排列的基础上的，所以综上，对于`n`笔订单，实际的排列的个数应该是：$a\times(2(n - 1) + 1)\times(n - 1)$

当我们信心满满的带入数据后发现这也对不上啊，你把2代入，也不得6啊

肯定是哪里漏掉了，问题就出现在我们上面选择两个插入点的地方

为什么必须选两个插入点啊，选一个不是也行吗，反正$p_n$和$d_n$的顺序就已经确定了，我们从`2(n - 1) + 1`个插入点中选择任意一个位置，然后连续插入$p_n，d_n$不也行吗

所以我们需要修正答案为：$a\times(2(n - 1) + 1)\times(n - 1) + a\times(2(n - 1) + 1) = a\times(2\times n - 1)\times n$

> 写成更熟悉的`dp`的形式：`dp[n] = dp[n- 1](2n - 1)n`

```java
class Solution {
    private static int[] dp;
    private static final long MOD = (long)1e9 + 7;
    static {
        dp = new int[501];
        dp[1] = 1;
        for (int i = 2; i <= 500; i++) {
            long tmp = (long)(i * (2 * i - 1)) * dp[i - 1];
            tmp %= MOD;
            dp[i] = (int)tmp;
        }
    }
    public int countOrders(int n) {
        return dp[n];
    }
}
```

# 3.7

## [504. 七进制数](https://leetcode-cn.com/problems/base-7/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/504.png)

类比之前取出十进制的各位数，我们使用了一个while循环：

```java
while (num != 0) {
    int tmp = num % 10;
    num /= 10;
}
```

那么对于7进制其实也是一样的：

```java
class Solution {
    public String convertToBase7(int num) {
        boolean isNeg = num < 0;
        if (isNeg) num = -num;
        StringBuilder builder = new StringBuilder();
        while (num != 0) {
            builder.append(num % 7);
            num /= 7;
        }
        if (isNeg) builder.append("-");
        if (builder.length() == 0) builder.append(0);
        return builder.reverse().toString();
    }
}
```

# 3.8

## 永远学不会的二分

考虑一个有序数组中查找target

如果找不到target就返回-1，这样最好，但实际中如果查找不到的话，我们常常需要返回数组中刚好小于target的，或者是数组中刚好大于target的

### 返回target，找不到就返回刚好大于target的

```java
public int getIndex(int target, int[] nums) {
    int left = 0;
    int right = nums.length - 1;
    while (left < right) {
        int mid = left + ((right - left) >> 1);
        if (nums[mid] < target) {
            left = mid + 1;
        }else {
            right = mid;
        }
    }
    return left;
}
```

### 返回target，找不到就返回刚好小于target的

```java
public int getIndex(int target, int[] nums) {
    int left = 0;
    int right = nums.length - 1;
    while (left < right) {
        int mid = left + ((right - left) >> 1);
        if (nums[mid] > target) {
            right = mid - 1;
        }else {
            left = mid;
        }
    }
    return left;
}
```

## [2055. 蜡烛之间的盘子](https://leetcode-cn.com/problems/plates-between-candles/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/2055.png)

前缀和

记录每个位置左侧和右侧最近的蜡烛的位置

```java
class Solution {
    public int[] platesBetweenCandles(String s, int[][] queries) {
        int len = s.length();
        int[] pre = new int[len];
        int[] leftPlate = new int[len];
        int[] rightPlate = new int[len];
        int p = -1;
        for (int i = 0; i < len; i++) {
            char c = s.charAt(i);
            if (i > 0) pre[i] = pre[i - 1];
            if (c == '*') pre[i]++;
            if (c == '|') p = i;
            //记录每个位置左侧最近的蜡烛的位置
            leftPlate[i] = p;
        }
        p = -1;
        for (int i = len - 1; i >= 0; i--) {
            char c = s.charAt(i);
            if (c == '|') p = i;
            //记录每个位置右侧最近蜡烛的位置
            rightPlate[i] = p;
        }
        int[] rst = new int[queries.length];
        for (int i = 0; i < rst.length; i++) {
            int left = leftPlate[queries[i][1]];
            int right = rightPlate[queries[i][0]];
            /*
            	保证给定的子区间的左边界具有右侧蜡烛，右边界具有左侧蜡烛
            	此外还需要保证左边界的右蜡烛位置在右边界左侧蜡烛之前
            */
            if (left != -1 && right != -1 && left > right) {
                //计算两个蜡烛之间盘子的数量
                rst[i] = pre[left] - pre[right];
            }
        }
        return rst;
    }
}
```

# 3.9

## [798. 得分最高的最小轮调](https://leetcode-cn.com/problems/smallest-rotation-with-highest-score/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/798.png)

这个题关键在于找到每个num，可以得分的k的范围，遍历数组中的每个num，即可得到每个k值的得分

> 维护一个以k值索引的数组，数组取值表示得分，遍历数组查询对应哪个k的时候可以获得到最大的得分

首先进行k轮调后，原来下标索引为i的位置，现在为止变为了`(i + (n - k)) mod n`，假设原来的取值为x

那么如果希望轮调后可以得分，必须有：$x \leq (i + (n - k))\mod{n}$

这个写法等价于：$k \leq (i + n - x)\mod n$

现在考虑i和x的关系：

* $i \geq x$时，此时有$(i + n - x)\mod n = (i - x)$：此时可以认为为了轮调后可以得分，需要有：$k \leq (i - x)$

  > 但要注意的是，如果k比较大也可以得分，参考数组：`[0, 4, 1, 3, 2]`，对于位置`i = 3`，此时`x = 3`，如果k取4的话显然也是可以得分的，所以实际`k`的范围应该是：
  >
  > $k \leq (i - x)$或$k > i$
  >
  > 注意k的上下限分别是：`len - 1`和`0`

* $i < x$时，此时有$(i + n - x)\mod n = (i - x + n)$，为了轮调后得分，需要让：$k\leq i - x + n$

  > 但要注意此时k不可以太小，参考数组：`[0, 4, 1, 3, 2]`，对于位置`i = 2`，此时`x = 1`，如果k取到2还可以得分，但是如果k取到1的话，显然是不能得分的
  >
  > 所以k的范围为：$i + 1 \leq k\leq i - x + n$

要注意的是上面的分析并不是完全公式导出的，因为[题解](https://leetcode-cn.com/problems/smallest-rotation-with-highest-score/solution/gong-shui-san-xie-shang-xia-jie-fen-xi-c-p6kh/)的公式确实看不明白，就举了两个例子，分别对应了当前位置不能得分，那么如何轮调才能得分；和当前位置可以得分，如何轮调才能继续得分

于是经过上面的过程，我们可以知道让每个位置得分的k的区间，现在我们使用差分数组记录（因为要改变的是区间，所以差分数组比较合适）

最后遍历得到最大值

```java
class Solution {
    private static int[] c;
    private static final int N = 100000;
    static {
        c = new int[N + 1];
    }

    private static void add(int left, int right) {
        c[left] += 1;
        c[right + 1] -= 1;
    }

    public int bestRotation(int[] nums) {
        Arrays.fill(c, 0);
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            if (nums[i] > i) {
                add(i + 1, i - nums[i] + len);
            }else {
                add(i + 1, len - 1);
                add(0, i - nums[i]);
            }
        }
        int rst = 0;
        for (int i = 1; i < len; i++) {
            c[i] += c[i - 1];
            if (c[i] > c[rst]) {
                rst = i;
            }
        }
        return rst;
    }
}
```

# 3.10

## [1488. 避免洪水泛滥](https://leetcode-cn.com/problems/avoid-flood-in-the-city/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1488.png)

策略是如果遇到晴天先不管，放入一个list中；第一次遇到雨天也不管，多次遇到同一个地方的雨天就从所有可选的晴天中选择和前一次雨天最接近的，如果没有的话就直接返回空数组了

```java
class Solution {
    public int[] avoidFlood(int[] rains) {
        int[] rst = new int[rains.length];
        Arrays.fill(rst, -1);
        //记录雨天和地点的映射关系
        Map<Integer, Integer> map = new HashMap<>();
        //记录晴天
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < rains.length; i++) {
            if (rains[i] == 0) {
                list.add(i);
                rst[i] = 1;
            }else {
                //如果今天下雨的地方已经满了
                if (map.containsKey(rains[i])) {
                    int pre = map.get(rains[i]);
                    //通过二分查找的方法从所有的晴天中找到和前一个雨天最接近的晴天
                    int left = 0;
                    int right = list.size() - 1;
                    while (left < right) {
                        int mid = left + ((right - left) >> 1);
                        if (list.get(mid) < pre) {
                            left = mid + 1;
                        }else {
                            right = mid;
                        }
                    }
                    //如果找不到，或者本身之前就没有晴天了，就返回空数组
                    if (list.size() == 0 || list.get(left) < pre) {
                        return new int[0];
                    }
                    //这里要把晴天移除，对于list而言，移除的时间复杂度太高了
                    rst[list.remove(left)] = rains[i]; 
                }
                map.put(rains[i], i);
            }
        }
        return rst;
    }
}
```

上面的缺点在于每次需要移除晴天的时间复杂度太高了，所以使用了一个TreeSet代替list，这还省去了自己写二分查找

```java
class Solution {
    public int[] avoidFlood(int[] rains) {
        int[] rst = new int[rains.length];
        Arrays.fill(rst, -1);
        Map<Integer, Integer> map = new HashMap<>();
        TreeSet<Integer> set = new TreeSet<>();
        for (int i = 0; i < rains.length; i++) {
            if (rains[i] == 0) {
                set.add(i);
                rst[i] = 1;
            }else {
                if (map.containsKey(rains[i])) {
                    if (set.size() == 0 || set.higher(map.get(rains[i])) == null) {
                        return new int[0];
                    }
                    int tmp = set.higher(map.get(rains[i]));
                    rst[tmp] = rains[i];
                    set.remove(tmp);
                }
                map.put(rains[i], i);
            }
        }
        return rst;
    }
}
```

## [993. 二叉树的堂兄弟节点](https://leetcode-cn.com/problems/cousins-in-binary-tree/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/993.png)

dfs，找到target节点的深度和父节点，返回一个数组，数组的格式为[父节点，深度]

自定义如果target目标节点就是根节点，那么父节点为-1，如果树中不存在对应的target节点，深度设置为-1

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCousins(TreeNode root, int x, int y) {
        int[] xx = getFaAndDe(root, 0, -1, x);
        int[] yy = getFaAndDe(root, 0, -1, y);
        return xx[0] != yy[0] && xx[1] == yy[1] && xx[1] != -1;
    }
    private int[] getFaAndDe(TreeNode root, int depth, int father, int target) {
        if (root == null) {
            //父节点，深度
            return new int[]{-1, -1};
        }
        if (root.val == target) {
            return new int[]{father, depth};
        }
        depth++;
        int[] left = getFaAndDe(root.left, depth, root.val, target);
        if (left[1] == -1) return getFaAndDe(root.right, depth, root.val, target);
        return left;
    }
}
```

# 3.11

## [2049. 统计最高分的节点数目](https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/2049.png)

其实真的没啥的，就计算每个节点左右子树的节点个数就行

不过注意点在于需要使用long对分数进行统计

```java
class Solution {
    private long max = 0;
    private int freq = 0;
    private int n;
    //使用map构架树，题解中使用的是一个List的数组，这其实就是"邻接表"
    private Map<Integer, List<Integer>> map;
    public int countHighestScoreNodes(int[] parents) {
        this.n = parents.length;
        this.map = new HashMap<>();
        for (int i = 1; i < parents.length; i++) {
            List<Integer> children = map.getOrDefault(parents[i], new ArrayList<>());
            children.add(i);
            map.put(parents[i], children);
        }
        dfs(0);
        return freq;
    }

    private int dfs(int node) {
        List<Integer> children = map.get(node);
        long mark = 1;
        int childrenNodes = 0;
        if (children != null) {
            for (int child : children) {
                int tmp = dfs(child);
                mark *= tmp;
                childrenNodes += tmp; 
            }
            mark *= Math.max(n - 1 - childrenNodes, 1);
        }else {
            mark = n - 1;
        }
        if (mark > max) {
            max = mark;
            freq = 1;
        }else if (mark == max) {
            freq++;
        }
        return childrenNodes + 1;
    }
}
```

## [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/61.png)

最开始想着递归来着，简单的递归就是每次从结尾取一个节点连到头部，这样时间复杂度就是$O(n\times k)$

那还是迭代吧，第一次遍历求出链表的长度

第二次遍历求出需要旋转的位置

```java
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (head == null) return head;
        int len = 0;
        ListNode per = head;
        while (per != null) {
            len++;
            per = per.next;
        }
        //注意这里取模的运算，因为实际中的输入中存在k比链表长的
        int gap = k % len;
        if (gap == 0) return head;
        ListNode fast = head;
        int idx = 0;
        while (idx < gap) {
            idx++;
            fast = fast.next;
        }
        per = head;
        while (fast.next != null) {
            fast = fast.next;
            per = per.next;
        }
        ListNode rst = per.next;
        fast.next = head;
        per.next = null;
        return rst;
    }
}
```

# 3.13

## [393. UTF-8 编码验证](https://leetcode-cn.com/problems/utf-8-validation/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/393.png)

简单的模拟题，其实只要拿到数字低8位的二进制编码，就可以确定是否满足条件了。

首先我们要知道的是，开头为：`10xxxxxx`的不可能单独出现，这种前边必须有：`{若干个1，至少为两个}xxxx`的才可以出现

所以可以定义一个变量，表示我们当前需要多少个以`10xxxxxx`这种形式的数字，默认为0

```java
class Solution {
    public boolean validUtf8(int[] data) {
        int pre = 0;
        for (int i = 0; i < data.length; i++) {
            //判断当前数字的最高位，即第八位是0还是1
            if (((data[i] >> 7) & 1) == 0) {
                //如果是0，那么pre，即需要类似10xxxxxx的个数必须为0
                if (pre > 0) return false;
                continue;
            }else {
                //如果是1，需要判断当前pre是不是0
                if (pre > 0) {
                    /*
                    	如果pre不是0,那么当前数字的第七位必须是0
                    	即这个数字必须是10xxxxxx的形式
                    */
                    if (((data[i] >> 6) & 1) == 1) return false;
                    pre--;
                    continue;
                }else {
                    /*
                    	如果pre为0，那么当前数字一定不能是10xxxxxx的形式
                    	我们就看看它有多少个连续的1
                    	其实可取的值本来就没几个，因为uft-8编码一个字符1-4个字节
                    	所以连续的1个数为2，3，4的时候是有效的，其余都是无效的
                    */
                    int j = 6;
                    while (j >= 0 && ((data[i] >> j) & 1) == 1) j--;
                    pre = 6 - j;
                    if (pre == 0 || pre >= 4) return false;
                }
            }
        }
        //这里不可以直接返回true，还应该判断当前pre是不是0
        return pre == 0;
    }
}
```

# 3.15

## [2044. 统计按位或能得到最大值的子集数目](https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/2044.png)

数据范围：$1\leq nums.length\leq 16$

从数据范围上其实就能看出应该使用暴力回溯了

子集可以获得的最大值是数组中所有数字取或运算，所以可以提前预知最大值

```java
class Solution {
    private int max = 0;
    private int rst = 0;
    public int countMaxOrSubsets(int[] nums) {
        for (int num : nums) {
            max |= num;
        }
        dfs(0, nums, 0);
        return rst;
    }

    private void dfs(int index, int[] nums, int sum) {
        if (index == nums.length) {
            if (sum == max) rst++;
            return; 
        }

        dfs(index + 1, nums, sum);
        dfs(index + 1, nums, sum | nums[index]);
        
    }
}
```

## [1249. 移除无效的括号](https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1249.png)

两次遍历，正向遍历的时候去除掉不满足条件的右括号，反向遍历的时候去除掉不满足条件的左括号

```java
class Solution {
    public String minRemoveToMakeValid(String s) {
        StringBuilder builder = new StringBuilder();
        int pre = 0;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == ')') {
                if (pre == 0) continue;
                pre--;
            }else if (c == '(') pre++;
            builder.append(c);
        }
        s = builder.toString();
        pre = 0;
        builder.delete(0, builder.length());
        for (int i = s.length() - 1; i >= 0; i--) {
            char c = s.charAt(i);
            if (c == '(') {
                if (pre == 0) continue;
                pre--;
            }else if (c == ')') pre++;
            builder.append(c);
        }
        return builder.reverse().toString();
    }
}
```

# 3.16

## 双向链表yyds

通常在数据结构中，使用map可以实现$O(1)$时间内的存储和获取，然而如果希望在此基础上保证一定的顺序，就没那么容易了，比如我希望可以在$O(1)$的时间内，知道map中最不常用的key，这其实就对应了[146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)，和他类似的还有：[432. 全 O(1) 的数据结构](https://leetcode-cn.com/problems/all-oone-data-structure/)、[460. LFU 缓存](https://leetcode-cn.com/problems/lfu-cache/)

都需要我们在map的基础上，让数据集保持一定的顺序，这个时候就需要用到双向链表了

> 这个题以前也写过，但重新再写一遍确实没那么容易，可能感触还没那么深吧

### [146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/146.png)

自定义一个LRU缓存，`Least Recently Used`最近最少使用的

缓存的大小是固定的，不可能完全包含运算需要的数据，当缓存区满的时候，需要`sacrifice`缓存中的一部分区域，用来存储新的数据

表现在这个题中就是，当map的容量超出了capacity后，需要从map中删除key，删除的key是最近最不常使用的（在这里，put，get方法都认为使用了key）

使用双向链表的好处在于，它可以维持key之间的相对顺序，我们可以一直维持头部是最近访问的key，而尾部是最近最少访问的key，这样每次`sacrifice`的时候，在双向链表中我们就可以在$O(1)$的时间内删除掉最近最少访问的key

```java
class LRUCache {
    //维护两个dummy节点，本身不存储，作用在于维护一个顺序
    private Node head;
    private Node tail;
    // 这里的map的value指向一个Node，保证我们可以在O(1)的时间内找到双向链表中的节点
    private Map<Integer,Node> map;
    private int capacity;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.head = new Node();
        this.tail = new Node();
        // 默认情况下双向链表中的头尾节点是相连的
        head.pre = tail;
        tail.next = head;
        this.map = new HashMap<>();
    }
    
    public int get(int key) {
        Node node = map.get(key);
        if (node != null) {
            // 每当查询一个key时，需要同步更新当前节点，表示当前节点最近刚刚访问过的
            flushCache(node);
            return node.value;
        }
        return -1;
    }
    
    public void put(int key, int value) {
        // 每次put的时候，先查询当前key是不是已经存储过了
        if (map.containsKey(key)) {
            Node node = map.get(key);
            node.value = value;
            flushCache(node);
        }else {
            // 如果当前key没有存储过就需要检查当前缓存区是否已经满了
            Node node = new Node();
            node.value = value;
            node.key = key;
            if (map.size() == capacity) {
                map.remove(tail.next.key);
                tail.next = tail.next.next;
                tail.next.pre = tail;
            }
            update(node);
            map.put(key, node);
        }
    }
	
    /*
    	更新一个节点一共分为两部分:
    	先是把当前节点从原来的位置处断开
    	然后将当前节点插入到头部
  	*/
  	private void flushCache(Node node) {
        deleteOrigin(node);
        update(node);
    }

    private void deleteOrigin(Node node) {
        node.pre.next = node.next;
        node.next.pre = node.pre;
    }

    private void update(Node node) {
        node.pre = head.pre;
        node.pre.next = node;
        node.next = head;
        node.next.pre = node;
    }
}

class Node {
    int key;
    int value;
    Node pre;
    Node next;
}
```

这个其实还好做，真正困难的在于有的时候一个双向链表加一个map好像还是不够

### [432. 全 O(1) 的数据结构](https://leetcode-cn.com/problems/all-oone-data-structure/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/432.png)

看这个题也是需要我们以$O(1)$的时间复杂度进行数据的存储和获取，然而它需要获取到的不是某一个`key`，而是使用最小的（最大的）`key`对应的value

> 感觉像这种看起来一个map就可以解决，但是还需要维护键之间顺序的，就可以考虑使用双向链表了

这里面的计数机制，使得可能有多个key具有相同的计数；

双向链表可以维护一个顺序，这里，我们可以考虑计数作为顺序的标准，这样计数越大越靠近head节点，计数越小越靠近tail节点

这其实也就意味着一个节点中可能存在好多的key，这样我们其实需要一个**集合**存储这些key

```java
class AllOne {
    // 头节点和尾节点
	private Node tail;
	private Node head;
    // 类似的这里的map存储的是key和节点的映射关系
	private Map<String, Node> stringToNode;

	public AllOne() {
		tail = new Node(Integer.MIN_VALUE);
		head = new Node(Integer.MAX_VALUE);
		head.pre = tail;
		tail.next = head;
		stringToNode = new HashMap<>();
	}
	
    /*
    	每当我们新增一个key的时候，要先考虑当前key是不是已经存在了
    	因为如果key存在了，这意味着我们需要把他从一个节点中删除，而添加到另一个节点中
    	而如果key不存在，我们仅需要将他添加到另一个节点中
    	所以主要在于：key的存在与否决定了我们是否对节点中的key进行删除
    */
	public void inc(String key) {
		Node node = null;
		if (stringToNode.containsKey(key)) {
            // 获取key所在的节点
			Node per = stringToNode.get(key);
            // 查看下一个节点是不是存在，如果不存在就需要先进行创建
			if (per.next.value != per.value + 1) {
				Node next = new Node(per.value + 1);
				next.next = per.next;
				per.next.pre = next;
				per.next = next;
				next.pre = per;
			}
            // 将key添加到下一个节点中
			node = per.next;
			node.set.add(key);
			per.set.remove(key);
            /*
            	这里很关键，因为我们在一个节点中使用了一个集合维护节点中的key
            	如果这个集合都已经空了，那么理论上这个节点也就没有意义了应该删除
            	这里和上面LRU每次移动的都是key，只不过在LRU中节点就是key
            	而在这里，key只是节点的一部分，我们不仅需要维护key，还需要维护节点
			*/
			if (per.set.size() == 0) {
				per.pre.next = per.next;
				per.next.pre = per.pre;
			}
		}else {
            /*
            	这里和上面if中的基本一样
            	区别在于不需要删除key了，自然就不要判断是否删除节点
            */
			if (tail.next.value != 1) {
				node = new Node(1);
				node.next = tail.next;
				node.next.pre = node;
				node.pre = tail;
				tail.next = node;
			}
			node = tail.next;
			node.set.add(key);
		}
		stringToNode.put(key, node);
	}
	
    /*
    	题目说明中保证了每次删除key的时候key肯定已经存在了
    	所以我们需要做的就是找到当前key所在的节点
    	把他从当前这个节点中删除，并添加到前一个节点中
    	注意事项和上面是一样的，如果删除后节点中key的数量为0则需要删除key
    	如果前一个节点不存在就需要先创建
    	
    	然而我们还需要注意，如果当前key所在的节点value为1，此时再进行一次删除操作
    	那么此时key就不应该存在于当前数据结构中了，此时我们就不需要管前一个节点了
    */
	public void dec(String key) {
		Node per = stringToNode.get(key);
		Node node = null;
		if (per.value != 1) {
			if (per.pre.value != per.value - 1) {
				Node pre = new Node(per.value - 1);
				pre.pre = per.pre;
				per.pre.next = pre;
				pre.next = per;
				per.pre = pre;
			}
			per.pre.set.add(key);
			node = per.pre;
		}
		per.set.remove(key);
		if (per.set.size() == 0) {
			per.pre.next = per.next;
			per.next.pre = per.pre;
		}
		if (node != null) {
			stringToNode.put(key, node);
		}else {
			stringToNode.remove(key);
		}
	}

	public String getMaxKey() {
		String rst = "";
		for (String s : head.pre.set) {
			rst = s;
			break;
		}
		return rst;
	}

	public String getMinKey() {
		String rst = "";
		for (String s : tail.next.set) {
			rst = s;
			break;
		}
		return rst;
	}
}

class Node {
	int value;
	Set<String> set;
	Node next;
	Node pre;

	public Node(int value) {
		this.value = value;
		set = new HashSet<>();
	}
}
```

### [460. LFU 缓存](https://leetcode-cn.com/problems/lfu-cache/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/460.png)

这个题应该是最难的了，它也需要维护一个顺序，那么自然需要使用一个双向链表，根据上一个题的经验，我们这个双向链表的顺序是基于频率的，同样的一个节点中可能具有多个key

然而如果真的有这么简单就好了

我们如果仔细读一下题干的话会发现，当缓存溢出后，他删除的顺序，不是从频率最小的节点中随便挑一个，而是在频率使用最少的节点中，使用LRU，挑选出一个最近最不常使用的节点进行删除

即如果使用频率作为维护双向链表顺序的基础的话，那么同一个节点中的多个key还应该有一个顺序

它的结构应该长这样：

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/460题解.webp)

我们需要在一个节点中再维护一个双向链表

对于第一层，即最外层，我们的写法和上面432 全O(1)类似，而内层和LRU的写法类似

```java
class LFUCache {
    // 外层节点的head和tail，外层表示了使用的频率
	private Bucket head;
	private Bucket tail;
    // 外层的map将一个key指向了外层的一个节点
	private Map<Integer, Bucket> map;
	private int capacity;

	public LFUCache(int capacity) {
		this.head = new Bucket(Integer.MAX_VALUE);
		this.tail = new Bucket(Integer.MIN_VALUE);
		tail.next = head;
		head.pre = tail;
		this.map = new HashMap<>();
		this.capacity = capacity;
	}

	public int get(int key) {
		if (map.containsKey(key)) {
			Bucket bucket = map.get(key);
			int value = bucket.get(key);
			put(key, value, bucket);
			return value;
		}
		return -1;
	}
	
    /*
    	这里的写法类似于432全O(1)，也需要判断当前key是否已经存在了
    	如果存在的话也是两个操作
    	* 将key从当前节点中删除（如果删除后该节点中的key的数量为0的话，需要删除当前节点）
    	* 添加到下一个结点中（如果下一个节点不存在的话，需要先创建）
    	而如果不存在的话，同样，我们仅需要进行添加就好了（此时需要考虑缓存区是不是已经满了）
   		如果缓存满了，需要删除频率最小的节点中，最近最不常使用的key
        同样的，删除后，需要判断节点中的key的数量是不是0
        
        总之，如果需要添加到节点中，需要先判断下一个节点是不是存在，不存在，先创建
        如果需要删除节点中的key，需要在删除后判断当前节点中h
    */
	public void put(int key, int value) {
		if (map.containsKey(key)) {
			put(key, value, map.get(key));
		}else {
			if (map.size() == capacity) {
				Bucket bucket = tail.next;
				int rst = bucket.removeLeast();
				if (rst == -1) return;
				map.remove(rst);
				if (bucket.map.size() == 0) {
					removeBucket(bucket);
				}
			}
			if (tail.next.freq != 1) {
				Bucket bucket = new Bucket(1);
				bucket.next = tail.next;
				bucket.next.pre = bucket;
				bucket.pre = tail;
				bucket.pre.next = bucket;
			}
			tail.next.add(key, value);
			map.put(key, tail.next);
		}
	}
    
    private void put(int key, int value, Bucket bucket) {
		int freq = bucket.freq;
		if (bucket.next.freq != freq + 1) {
			Bucket newBucket = new Bucket(freq + 1);
			newBucket.next = bucket.next;
			newBucket.next.pre = newBucket;
			bucket.next = newBucket;
			newBucket.pre = bucket;
		}
		bucket.next.add(key, value);
		bucket.remove(key);
		map.put(key, bucket.next);
		if (bucket.map.size() == 0) {
			removeBucket(bucket);
		}
	}

	private void removeBucket(Bucket bucket) {
		bucket.pre.next = bucket.next;
		bucket.next.pre = bucket.pre;
	}
}

class Bucket {
	int freq;
	Bucket pre;
	Bucket next;
	Map<Integer, Node> map;
	Node head;
	Node tail;

	public Bucket(int freq) {
		this.freq = freq;
		this.map = new HashMap<>();
		head = new Node();
		tail = new Node();
		head.pre = tail;
		tail.next = head;
	}

	//删除最不常使用的key，如果没有（capacity为0的情况），就返回-1
	public int removeLeast() {
		if (tail.next == head) return -1;
		Node node = tail.next;
		removeNode(node);
		map.remove(node.key);
		return node.key;
	}

	//删除指定的key
	public void remove(int key) {
		Node node = map.get(key);
		removeNode(node);
		map.remove(key);
	}

	private void removeNode(Node node) {
		node.pre.next = node.next;
		node.next.pre = node.pre;
	}

	public void add(int key, int value) {
		Node node = new Node();
		node.key = key;
		node.value = value;
		update(node);
		map.put(key, node);
	}

	//更新指定的key到最前方的位置
	private void update(Node node) {
		node.pre = head.pre;
		node.pre.next = node;
		node.next = head;
		node.next.pre = node;
	}

	public int get(int key) {
		return map.get(key).value;
	}
}

class Node {
	int key;
	int value;
	Node pre;
	Node next;
}

```

# 3.19

## [606. 根据二叉树创建字符串](https://leetcode-cn.com/problems/construct-string-from-binary-tree/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/606.png)

就是简单的前序遍历（递归写法）：

```java
class Solution {
    public String tree2str(TreeNode root) {
        if (root == null) return "";
        String rst = String.valueOf(root.val);
        String left = tree2str(root.left);
        if (!"".equals(left)) {
            rst += "(" + left + ")";
        }
        String right = tree2str(root.right);
        if (!"".equals(right)) {
            if ("".equals(left)) rst += "()";
            rst += "(" + right + ")";
        }
        return rst;
    }
}
```

注意左节点为空，而右节点不空的情况，这种情况下，需要额外`append`一个括号

上面的写法最大的开销在于我们需要不断进行字符串拼接操作，这种操作是很耗时的，推荐使用一个`StringBuilder`（全局）

```java
class Solution {
    private StringBuilder builder;
    public String tree2str(TreeNode root) {
        if (root == null) return "";
        builder = new StringBuilder();
        dfs(root);
        return builder.substring(1, builder.length() - 1);
    }

    private void dfs(TreeNode root) {
        builder.append("(");
        builder.append(root.val);
        if (root.left != null) {
            dfs(root.left);
        }else if (root.right != null) {
            builder.append("()");
        }
        if (root.right != null) dfs(root.right);
        builder.append(")");
    }
}
```

## 没有什么是一条双向链表解决不了的，如果有就再来一条:[895. 最大频率栈](https://leetcode-cn.com/problems/maximum-frequency-stack/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/895.png)

这个题，一看到频率，我就想到了前几天的全$O(1)$，直接一条双向链表怼上

```java
class FreqStack {
    // 统计频率
    private Map<Integer, Integer> freq;
    // 统计某一个频率属于哪一个节点
    private Map<Integer, Node> freqToNode;
    private Node tail;
    private Node head;
    
    public FreqStack() {
        this.freq = new HashMap<>();
        this.freqToNode = new HashMap<>();
        // 这里面借助了哨兵，让尾节点自身具有了意义，即尾节点表示了出现频率为0，主要是为了统一写法
        tail = new Node(0);
        head = new Node(Integer.MAX_VALUE);
        tail.next = head;
        head.pre = tail;
        freqToNode.put(0, tail);
    }
    
    /**
     * 添加元素
     * 首先要知道当前元素对应的节点（通过频数确定）
     * 然后向当前节点的“后一个节点”添加元素
     * 这里的后一个是严格意义上的后一个，即当前节点频率为freq，那么后一个节点就应该为freq + 1
     * 所以对于后一个节点不存在的情况，需要提前创建后一个节点
     * 注意这个题和全O(1)最大的区别在于，添加完节点后我们不需要将元素从当前节点移除
     * （这么说来，好像全O(1)这个题如果节点中使用栈存储的话也不需要移除？）
     */
    public void push(int val) {
        int count = freq.getOrDefault(val, 0);
        Node node = freqToNode.get(count);
        Node next = node.next;
        if (next.freq != node.freq + 1) {
            next = new Node(node.freq + 1);
            next.next = node.next;
            next.next.pre = next;
            next.pre = node;
            node.next = next;
            freqToNode.put(next.freq, next);
        }
        next.stack.offerLast(val);
        freq.put(val, count + 1);
    }
    
    /**
     * 移除元素
     * 注意点和之前双向链表一样，如果某一个节点中元素个数为0时，需要将这个节点从链表中移除
     */
    public int pop() {
        int val = head.pre.stack.pollLast();
        freq.put(val, head.pre.freq - 1);
        if (head.pre.stack.size() == 0) {
            freqToNode.put(head.pre.freq, null);
            head.pre = head.pre.pre;
            head.pre.next = head;
        }
        return val;
    }
}
// 每个节点保存的是频率和对应的栈
class Node {
    int freq;
    Deque<Integer> stack;
    Node next;
    Node pre;

    public Node(int freq) {
        this.freq = freq;
        this.stack = new LinkedList<>();
    }
}
```

然而这个题的正确解法并没有这么复杂，我上面仅仅是为了说明双向链表yyds

```java
class FreqStack {
    /**
     * 直接两个map，一个max记录位置就好了，反正它每次弹出的都是频率最大的
     */
    private int maxFreq;
    // 记录val出现的频率
    private Map<Integer, Integer> freq;
    // 记录频率和栈的映射
    private Map<Integer, Deque<Integer>> freqToStack;
    public FreqStack() {
        this.maxFreq = 0;
        this.freq = new HashMap<>();
        this.freqToStack = new HashMap<>();
    }
    
    public void push(int val) {
        int count = freq.getOrDefault(val, 0) + 1;
        maxFreq = Math.max(maxFreq, count);
        Deque<Integer> stack = freqToStack.getOrDefault(count, new LinkedList<>());
        stack.offerLast(val);
        freqToStack.put(count, stack);
        freq.put(val, count);
    }
    
    public int pop() {
        Deque<Integer> stack = freqToStack.get(maxFreq);
        int val = stack.pollLast();
        freq.put(val, maxFreq - 1);
        if (stack.size() == 0) {
            maxFreq--;
        }
        return val;
    }
}
```

# 3.20

## [2039. 网络空闲的时刻](https://leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/2039.png)

最开始想的很复杂，感觉还需要Dijkstra求一下最短路，后来发现这些边的边权不都是1吗，直接退化变为BFS了

这个题简化了思路，因为它每条链路上是不限制传输信息的个数的，所以一条消息的最短路就是节点间最短路（当然消息是来回的，所以实际距离是节点之间最短路的二倍）

我们知道了节点之间的距离，就可以根据`patience`数组推算，一共需要发送的消息的数目，进而推算出这个节点从发送消息到完全接收到消息需要的时间，这样我们仅需要返回一个最大值就好了

这里面优化的空间其实在于建图，这里采用的链式前向星建图，这个确实厉害

> 只要明确了节点的个数和边的个数，就可以用这个方法建图
>
> 它一共具有三个数组：
>
> * head数组，存储某个节点的第一条边所在的edge数组中的下标
> * egde数组，存储某条边的终点节点
> * **next数组（核心）**：存储和某条边具有相同起点的下一条边在edge数组中的下标
>
> 具体的看：[链式前向星](./21_12.md#链式前向星)

```java
class Solution {
    private static final int N = 100010;
    private static final int M = N * 2;

    private static int[] head;
    private static int[] edge;
    private static int[] next;
    static {
        head = new int[N];
        edge = new int[M];
        next = new int[M];
    }
    public int networkBecomesIdle(int[][] edges, int[] patience) {
        int rst = 0;
        int index = 0;
        Arrays.fill(head, -1);
        Arrays.fill(edge, -1);
        Arrays.fill(next, -1);
        for (int[] points : edges) {
            edge[index] = points[1];
            next[index] = head[points[0]];
            head[points[0]] = index++;
            edge[index] = points[0];
            next[index] = head[points[1]];
            head[points[1]] = index++;
        }
        boolean[] visited = new boolean[patience.length];
        visited[0] = true;
        Queue<Integer> queue = new LinkedList<>();
        int dis = 1;
        for (int i = head[0]; i != -1; i = next[i]) {
            int end = edge[i];
            queue.offer(end);
            visited[end] = true;
            int real = 2 * dis;
            int extraNum = real / patience[end] - (real % patience[end] == 0 ? 1 : 0);
            rst = Math.max(rst, real + extraNum * patience[end] + 1);
        }
        
        while (!queue.isEmpty()) {
            dis++;
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int tmp = queue.poll();
                for (int j = head[tmp]; j != -1; j = next[j]) {
                    int end = edge[j];
                    if (!visited[end]) {
                        queue.offer(end);
                        visited[end] = true;
                        int real = 2 * dis;
                        int extraNum = real / patience[end] - (real % patience[end] == 0 ? 1 : 0);
                        rst = Math.max(rst, real + extraNum * patience[end] + 1);
                    }
                }
            }
        }
        return rst;
    }
}
```

## [1007. 行相等的最少多米诺旋转](https://leetcode-cn.com/problems/minimum-domino-rotations-for-equal-row/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1007.png)

容易乱，需要整理一下思路：

首先如果有解，那么相同的值一定是第一个牌的正面或反面

那么我们就假设：

* 以第一张牌的正面为相同值时，求出

  * 使得正面全部相同需要旋转的次数
  * 和使得反面全部相同时需要旋转的次数

  二者取一个最小值，即为相同的值为第一张牌的正面的值，需要旋转的最小次数

  注意，这里解可能不存在，即存在某一张牌，其正反两面的取值和第一张牌的正面都不相同

* 以第一张牌的反面为相同值时，求出：

  ...

将以第一张牌的正面、第一张牌的反面为相同值需要旋转的次数取一个最小值，即为最终解

这里还是需要注意解不存在的情况

```java
class Solution {
    public int minDominoRotations(int[] tops, int[] bottoms) {
        int rst = Integer.MAX_VALUE;
        int base = tops[0];
        int topCount = 0;
        int bottomCount = 1;
        boolean topLegal = true;
        for (int i = 1; i < tops.length; i++) {
            if (tops[i] != base && bottoms[i] != base) {
                topLegal = false;
                break;
            }else if (tops[i] != base) {
                topCount++;
            }else if (bottoms[i] != base){
                bottomCount++;
            }
        }
        if (topLegal) {
            rst = Math.min(bottomCount, topCount);
        }
        base = bottoms[0];
        topCount = 1;
        bottomCount = 0;
        boolean bottomLegal = true;
        for (int i = 1; i < tops.length; i++) {
            if (tops[i] != base && bottoms[i] != base) {
                bottomLegal = false;
                break;
            }else if (tops[i] != base) {
                topCount++;
            }else if (bottoms[i] != base) {
                bottomCount++;
            }
        }
        if (bottomLegal) {
            int min = Math.min(topCount, bottomCount);
            if (topLegal) {
                rst = Math.min(rst, min);
            }else {
                rst = min;
            }
        }

        if (rst == Integer.MAX_VALUE) return -1;
        return rst;
    }
}
```

# 3.21

## [653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/653.png)

直接dfs，一个set存储已经遍历节点的value，假设遍历到节点的值为value，就看看集合中是否存在：`k - value`，如果存在直接返回true

上面的思路肯定是可以做出来的，不过那样做就浪费了BST的一个性质，即中序遍历时，得到的集合是有序的

所以可以利用中序遍历和双指针，做法类似于两数之和

```java
class Solution {
    private List<Integer> rst;
    public boolean findTarget(TreeNode root, int k) {
        this.rst = new ArrayList<>();
        intertraverse(root);
        int left = 0;
        int right = rst.size() - 1;
        while (left < right) {
            int sum = rst.get(left) + rst.get(right);
            if (sum < k) {
                left++;
            }else if (sum > k) {
                right--;
            }else {
                return true;
            }
        }
        return false;
    }
    private void intertraverse(TreeNode root) {
        if (root == null) return;
        intertraverse(root.left);
        rst.add(root.val);
        intertraverse(root.right);
    }
}
```

## [763. 划分字母区间](https://leetcode-cn.com/problems/partition-labels/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/763.png)

我第一眼看上去是先统计词频，然后再遍历一次，统计区间内出现单词的种类个数和区间内出现单词频率降为0的个数，二者一致的时候取一个区间作为结果

```java
class Solution {
    private static final int SIZE = 26;
    public List<Integer> partitionLabels(String s) {
        List<Integer> rst = new ArrayList<>();
        int[] freq = new int[SIZE];
        int len = s.length();
        for (int i = 0; i < len; i++) {
            freq[s.charAt(i) - 'a']++;
        }
        // 统计区间内字母的种类，这里因为只有26中字母，就没有使用set
        int[] set = new int[SIZE];
        int cnt = 0;
        // 区间内字母频数降为0的种类
        int count = 0;
        int left = 0;
        for (int i = 0; i < len; i++) {
            int c = s.charAt(i) - 'a';
            freq[c]--;
            if (set[c] == 0) {
                set[c] = 1; 
                cnt++;
            }
            if (freq[c] == 0) count++;
            if (cnt == count) {
                rst.add(i - left + 1);
                left = i + 1;
                count = 0;
                cnt = 0;
            }
        }
        return rst;
    }
}
```

题解的做法就省去了复杂的统计工作，因为我们判断一个字母存在的区间，只需要判断其最左侧和最右侧出现的位置就好了

所以它先统计了所有字母在最右侧出现的位置，记在一个数组`endc[]`中

然后遍历，维护一个区间的最右侧值：`end`其初始为0，但每当遍历到一个字母的时候更新一次，更新的规则是：`end = Math.max(end, endc[])`

只有当前遍历到区间的右边界的时候，即`end = i`的时候才进行区间的取值

```java
class Solution {
    private static final int SIZE = 26;
    public List<Integer> partitionLabels(String s) {
        List<Integer> rst = new ArrayList<>();
        int[] endc = new int[SIZE];
        int len = s.length();
        for (int i = 0; i < len; i++) {
           endc[s.charAt(i) - 'a'] = i;
        }
        int start = 0;
        int end = 0;
        for (int i = 0; i < len; i++) {
            int c = s.charAt(i) - 'a';
            end = Math.max(end, endc[c]);
            if (end == i) {
                rst.add(end - start + 1);
                start = i + 1;
                end = i + 1;
            }
        }
        return rst;
    }
}
```

# 3.22

## [2038. 如果相邻两个颜色均相同则删除当前颜色](https://leetcode-cn.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/2038.png)

如果可以删除，那么位置是固定的，因为删除时必须保证左右两侧为相同字母

可以认为整个字符串是由多个区间拼接而成的，每个区间的左右两侧可以保留，而中间剩下的就是可以删除的

所以无论`A`,`B`两人如何操作都不会影响对方可以删除的位置的数量，而这个数量仅和字符串本身有关

所以我们仅需要统计除去了区间左右边界的位置的数量就好了：

```java
class Solution {
    public boolean winnerOfGame(String colors) {
        int len = colors.length();
        if (len < 3) return false;
        int[] count = new int[2];
        int left = 0;
        char interval = colors.charAt(left);
        for (int right = 1; right <= len; right++) {
            if (right == len || colors.charAt(right) != colors.charAt(right - 1)) {
                count[interval - 'A'] += Math.max(right - left - 2, 0);
                if (right < len) {
                    interval = colors.charAt(right);
                    left = right;
                }
            }
        }
        return count[0] > count[1];
    }
}
```

## [1663. 具有给定数值的最小字符串](https://leetcode-cn.com/problems/smallest-string-with-a-given-numeric-value/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1663.png)

如果希望字典序越小越好，那么显然应该尽可能以 'z' 结尾，以 'a' 开头，所以一种思路是从后向前填，能填 'z' 就填，如果 k 太小，那么直接跳出循环，剩下的所有位置都填 'a'

```java
class Solution {
	public String getSmallestString(int n, int k) {
		char[] cs = new char[n];
		int idx = n - 1;
		while (idx >= 0) {
            // 只要剩下的 k 足够填写前面的 'a' 就让当前位置填 'z'
			if (k - 26 > idx) {
				cs[idx] = 'z';
				k -= cs[idx--] - 'a' + 1;
			} else {
                // 否者在前面全填写 'a' 的基础上，让当前位取得最大
				cs[idx] = (char)(k - idx + 'a' - 1);
				idx--;
				break;
			}
		}
		while (idx >= 0) cs[idx--] = 'a';
		return new String(cs);
	}
}
```

一个更好的想法是，先假设所有位置都填 'a' ，然后从后向前修改，每个位置添加 25 得到 'z'，直到 k 没有剩余

```java
class Solution {
	public String getSmallestString(int n, int k) {
		char[] cs = new char[n];
        Arrays.fill(cs, 'a');
        k -= n;
		int idx = n - 1;
        while (k > 0) {
            if (k >= 25) cs[idx] = 'z';
            else cs[idx] = (char)('a' + k);
            k -= cs[idx--] - 'a';
        }
		return new String(cs);
	}
}
```

# 3.23

## [991. 坏了的计算器](https://leetcode-cn.com/problems/broken-calculator/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/991.png)

从`startValue`到`target`要么减法，那么乘法，所以让当前值变大，只能通过乘法操作，而让当前值变小，只能通过减法操作

这里主要思路参考[题解]([无需逆向计算，正向简洁证明 - 坏了的计算器 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/broken-calculator/solution/wu-xu-ni-xiang-zheng-xiang-ji-suan-jian-ji-zheng-m/))

假设一共乘法的次数为`cntMul`，一共减法的次数为`cntDe`

我们可以在乘法之间穿插减法：

假如在第一次乘法之前进行了减一，相当于在对原来的`startValue`进行了`cntMul`次乘法后进行了减$2^{cntMul}$

同理在第二次乘法前进行了减一，相当于在`cntMul`次乘法后进行了减$2^{cntMul - 1}$

假设第一次减去了`a`个1，第二次减去了`b`个1......，那么一定有等式：$target = startValue \times 2^{cntMul} - a\times 2^{cntMul} - b\times 2^{cntMul - 1} -...$

同时，一定有：$a + b + c + ... = cntDe$

所以我们的操作是，将`startValue`乘2，直到比`target`更大，然后计算系数`a,b,c,...`原则上，为了尽快凑到`target`，`a`越大越好，其次是`b`...

```java
class Solution {
    public int brokenCalc(int startValue, int target) {
        if (startValue >= target) {
            return startValue - target;
        }
        int cntMul = 0;
        while (startValue < target) {
            startValue *= 2;
            cntMul++;
        }
        int cntDe = 0;
        int factor = (int)Math.pow(2, cntMul);
        while (startValue != target) {
            int gap = startValue - target;
            int cnt = gap / factor;
            startValue -= factor * cnt;
            cntDe += cnt;
            factor /= 2;
        }
        return cntMul + cntDe;
    }
}
```

# 3.25

## [172. 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/172.png)



对于结果中含有 0 的，一定是乘出了 10，将 10 质因数分解：10 = 2 x 5，所以我们的求解就变成了在 n! 中，找到有多少对(2,5)

而因为只要是偶数将其质因数分解，就一定含有 2，所以这个求解又等效为：**在 n! 中有多少个 5**

一个比较简单的想法是，遍历，看看每个位置上，质因数分解中 5 的个数

这样做有点慢，考虑在 n! 中含有 1 个 5 的个数(n / 5)，含有 2 个 5 的个数(n / 25)...

```java
class Solution {
    public int trailingZeroes(int n) {
        int rst = 0;
        while (n >= 5) {
            rst += n / 5;
            n /= 5;
        }
        return rst;
    }
}
```

## [1029. 两地调度](https://leetcode-cn.com/problems/two-city-scheduling/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1029.png)

第一个想法是排序，让`costs[i][0]`和`costs[i][1]`相差较大的排在前面，因为对于相差比较大的，我们应该尽可能满足选择较小的

```java
class Solution {
    public int twoCitySchedCost(int[][] costs) {
        Arrays.sort(costs, (int[] cost1, int[] cost2) -> 
                    Math.abs(cost2[1] - cost2[0]) - Math.abs(cost1[1] - cost1[0]));
        int n = costs.length / 2;
        int aCount = 0, bCount = 0;
        int idx = 0;
        int rst = 0;
        while (aCount < n && bCount < n) {
            if (costs[idx][0] < costs[idx][1]) {
                rst += costs[idx++][0];
                aCount++;
            }else {
                rst += costs[idx++][1];
                bCount++;
            }
        }
        while (aCount < n) {
            rst += costs[idx++][0];
            aCount++;
        }
        while (bCount < n) {
            rst += costs[idx++][1];
            bCount++;
        }
        return rst;
    }
}
```

而[题解](https://leetcode-cn.com/problems/two-city-scheduling/solution/er-cha-shu-de-chui-xu-bian-li-by-leetcode/)更进一步，它说，根据`costs[idx][0] - costs[idx][1]`从小到大排序

因为这个值越小，说明，选择让当前用户去`A`地，更省钱（理想情况下，为这个值小于0的部分），而越大，说明让当前用户去`B`地更省钱（理想情况下，为这个值大于0的部分）

```java
class Solution {
    public int twoCitySchedCost(int[][] costs) {
        Arrays.sort(costs, (int[] cost1, int[] cost2) -> 
                    (cost1[0] - cost1[1]) - (cost2[0] - cost2[1]));
        int n = costs.length / 2;
        int idx = 0;
        int rst = 0;
        while (idx < n) {
            rst += costs[idx++][0];
        }
        while (idx < costs.length) {
            rst += costs[idx++][1];
        }
        return rst;
    }
}
```

# 3.28

## 终极二分

### 找到target区间左边界/target取值的右边界

> 一会区间一会取值的，都快混了，其实很好理解
>
> 区间的左边界，是指，如果nums中元素允许重复的话，那么我们下面这个模板找到的是对应target区间中，最左侧的下标索引
>
> 取值的右边界是指，如果target不在nums数组中出现，那么最终left会落在数组中刚好大于target的索引的位置，当然，如果数组中的元素都比target小，那么left最终落在的位置还是比target小

之前常用的模板：

```java
public int leftBound(int[] nums, int target) {
	int left = 0;
    int right = nums.length;
    while (left < right) {
        int mid = left + ((right - left) >> 1);
        if (nums[mid] < target) {
            left = mid + 1;
        }else {
            right = mid;
        }
    }
    return nums[left] == target ? left : -1;    
}
```

这个是求区间左边界的，个人的记忆方式是

我们每次遇到`nums[mid] < target`的时候，都将`left = mid + 1`，即当前位置比目标值小的时候，就”大胆“收缩左边界

而如果遇到了$nums[mid] \geq target$的时候，仅仅是`right = mid`，相比于上面的操作，更加“慎重”地收缩右边界，所以最后会渐进到区间的左边界

### 找到区间的右边界/target取值的左边界

> 类比上面的写法，不解释了

之前一直没有好的求右边界的方法，直到今天看到了，[【宫水三叶】二分 + 倍增乘法解法（含模板） - 两数相除 ](https://leetcode-cn.com/problems/divide-two-integers/solution/shua-chuan-lc-er-fen-bei-zeng-cheng-fa-j-m73b/)，原来右边界也是很好求的，也是一个模板：

```java
public int rightBound(int[] nums, int target) {
  	int left = 0;
    int right = nums.length - 1;
    while (left < right) {
        int mid = left + ((right - left + 1) >> 1);
        if (nums[mid] > target) {
            right = mid - 1;
        }else {
            left = mid;
        }
    }
    return nums[left] == target ? left : -1;  
} 
```

注意到因为我们要求的是右边界，类比上面的写法，我们遇到：`nums[mid] > target`的时候大胆收缩右边界使得：`right = mid - 1`，而如果遇到$nums[mid] <= target$的时候，就仅仅让`left = mid`

这个求右边界和上面求左边界最大的区别在于mid的取值不一样了，这里是：`mid = left + ((right - left + 1) >> 1)`，如果不加1，那么会进入死循环

> 原来从来没有改过mid的写法，所以求右边界的话最终转化为求刚好大于target的左边界，然后再看看能不能减一，十分麻烦

下面这张图，配合上更方便记忆

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/%E4%BA%8C%E5%88%86%E5%B7%A6%E5%8F%B3%E5%8C%BA%E9%97%B4.png)

## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/34.png)

这个就是二分的裸题了

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] rst = new int[]{-1, -1};
        if (nums.length == 0) return rst;
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] < target) {
                left = mid + 1;
            }else {
                right = mid;
            }
        }
        if (nums[left] == target) {
            rst[0] = left;
            left = 0;
            right = nums.length - 1;
            while (left < right) {
                int mid = left + ((right - left + 1) >> 1);
                if (nums[mid] > target) {
                    right = mid - 1;
                }else {
                    left = mid;
                }
            }
            rst[1] = left;
        }
        return rst;
    }
}
```

## [29. 两数相除](https://leetcode-cn.com/problems/divide-two-integers/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/29.png)

这个题，求除法，但不允许直接除

如果什么都不说，其实还挺不好求的，但上面都写了一个二分了，这个肯定也是二分

* 注意到这里都是整数之间的除法，且除数不为0
* 此外在这个题目中：$7 \div (-3) = (-7) \div 3 = -2$

这其实就指示我们，可以先不管负号，都变成正的，然后求出一个商，最后再考虑负号

因为它不允许使用乘法，但二分的话，怎么都需要乘算，一个简单的替代方式类似于快速幂，这里称为快速积

```java
/**
 * 姑且叫base为被乘数，factor为乘数
 * 将乘数写为二进制的形式，然后类似快速幂的写法，求出乘积
 */
public long getMul(long base, long factor) {
    long rst = 0;
    while (factor > 0) {
        if ((factor & 1) == 1) {
            rst += base;
        }
        base <<= 1;
    }
    return rst;
}
```

注意到，$10\div3 = 3$，相当于求`target = 3.33333...`取值的左边界

所以这里二分的写法是第二种：

```java
class Solution {
    public int divide(int dividend, int divisor) {
        if (dividend == 0) return 0;
        long total = dividend < 0 ? -(long)dividend : dividend;
        long factor = divisor < 0 ? -(long)divisor : divisor;
        long left = 0;
        long right = total;
        while (left < right) {
            long mid = left + ((right - left + 1) >> 1);
            if (getMul(factor, mid) > total) {
                right = mid - 1;
            }else {
                left = mid;
            }
        }
        // 注意负号和越界的问题
        if ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0)) {
            if (left > Integer.MAX_VALUE) left = Integer.MAX_VALUE;
            return (int)left;
        }else {
            return -(int)left;
        }
    }

    public long getMul(long base, long factor) {
        long rst = 0;
        while (factor > 0) {
            if ((factor & 1) == 1) {
                rst += base;
            }
            base <<= 1;
        }
        return rst;
    }
} 
```

# 3.30

## [1606. 找到处理最多请求的服务器](https://leetcode-cn.com/problems/find-servers-that-handled-most-number-of-requests/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1606.png)

这个题还真就没有那么难

首先，不管我们怎么统计，肯定需要知道每台服务器处理了多少业务，就是至少需要一个数组维护每台服务器处理了多少业务，最后我们遍历这个数组，就可以知道有多少个服务器最繁忙，结构如下：

```java
class Solution {
    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {
        int[] counts = new int[k];
        List<Integer> rst = new ArrayList<>();
        
        
        /**
         * 统计部分
         */
        
        int max = 0;
        for (int i = 0; i < k; i++) {
            if (counts[i] < max) continue;
            if (counts[i] > max) {
                max =  counts[i];
                rst.clear();
            }
            rst.add(i);
        }
        return rst;
    }
}
```

现在最关键的就是统计部分了，最开始的想法：**维护每个服务器繁忙的时间**，然后当一个新的业务到来的时候，**从所有当前时间不繁忙的服务器中，选择一个序号最小的**

也就是说，我们进行比较的不仅仅是服务器的繁忙时间，还需要比较服务器的序号

比如说，新的业务在t = 10到达，而一号服务器最远的繁忙时间是9，二号服务器最远的繁忙时间是8，此时应该选择一号，而不是二号

所以我的第一版代码是两个优先队列进行统计：一个优先队列保存的节点是数组，`arr[0]`表述服务器的序号，而`arr[1]`表示服务器的最远的繁忙时间，根据最远繁忙时间维护一个小顶堆，在繁忙时间相同时，根据服务器的序号进行排序，我将他定义为`nextAvailable`；另一个优先队列保存的节点是服务器的序号，根据服务器的序号排序，我将他定义为`candidates`

初始化时，`nextAvailable`中存储了所有的服务器，取值为：`{i, 0}`，其中`i`表示服务器的序号，而`0`表示服务器的最远繁忙时间为`0`；而`candidates`优先队列是空

这样遍历所有业务的时候，先看看有那些服务器的最远繁忙时间小于当前业务到达的时间，将其加入`candidates`中，而进行分配业务的时候再从`candidates`中取出节点

```java
PriorityQueue<int[]> nextAvailable = new PriorityQueue<>((nums1, nums2) -> {
    if (nums1[1] == nums2[1]) return nums1[0] - nums2[0];
    return nums1[1] - nums2[1];
});
for (int i = 0; i < k; i++) {
    nextAvaliable.offer(new int[]{i, 0});
}
PriorityQueue<Integer> candidates = new PriorityQueue<>();
for (int i = 0; i < arrival.length; i++) {
    while (!nextAvailable.isEmpty() && nextAvaliable.peek()[1] <= arrival[i]) {
        int[] tmp = nextAvailable.poll();
        candidates.offer(tmp[0]);
    }
    if (!candidates.isEmpty()) {
        int tmp = candidates.poll();
        counts[tmp]++;
        nextAvailable.offer(new int[]{tmp, arrival[i] + load[i]});
    }
}
```

上面的这个写法是对的，但也不是完全对

我们有关序号的讨论太少了，上面的这个业务处理的逻辑就是，每当一个业务到达，就从`0`号服务器开始，从头向后遍历所有的服务器，如果有一个可以进行服务，就让他进行服务

> 当然，我们并不是真的遍历，而是通过优先队列这个数据结构，优化了查找空闲服务器的时间复杂度，不过基本处理逻辑是这样的

这个时候重新看看题干可以发现，题目中要求，当第`i`个请求到达的时候，如果第`i % k`个服务器是空闲的，就像第`i % k`个服务器进行工作；

比如假如现在是第`4`个请求，而一共有三台服务器，现在第一台和第二台都是空闲；如果按照我们上面的逻辑，直接就把业务推给第一台服务器了；而题干的意思是此时应该让第二台服务器进行工作，如果第二台不行，就看看第三台，最后再看看第一台

> 我是怎么发现这个问题的呢，主要是实例4怎么都不能通过，程序返回的结果是`[0, 1]`，而题目的正确结果是`[1]`
>
> 我实际动笔算了一下，发现，如果按照最开始的思路，确实应该返回`[0, 1]`，这个时候才再看了一眼题干:sob:

其实如果希望得到正确的结果，也是很容易的，就是需要将我们上面的服务器的**绝对序号**的比较，变为一个**相对序号**，我们希望对于第4个请求（一共三台服务器），服务器2的序号最小，服务器3的序号其次，而服务器1的序号最大

对于服务器`i`，请求序号`idx`，一共`k`台服务器，定义相对序号为：`((i - idx) % k + k) % k`

首先在`java`里面$-2\mod 3 = -2$，所以我们的`+k)%k`的操作，其实就是把这个序号变成一个正数

但我们在分配服务器处理业务后，需要再将服务器加入`nextAvailable`优先队列中，所以需要能够根据这个相对序号恢复绝对序号

所以最终存储的是：`((i - idx) % k + k) % k + i`

而如果需要恢复绝对序号就需要将其进行`% k`操作

```java
class Solution {
    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {
        int[] counts = new int[k];
        List<Integer> rst = new ArrayList<>();
        PriorityQueue<int[]> nextAvailable = new PriorityQueue<>((nums1, nums2) -> {
            if (nums1[1] == nums2[1]) return nums1[0] - nums2[0];
            return nums1[1] - nums2[1];
        });
        for (int i = 0; i < k; i++) {
            nextAvailable.offer(new int[]{i, 0});
        }
        PriorityQueue<Integer> candidates = new PriorityQueue<>();
        for (int i = 0; i < arrival.length; i++) {
            while (!nextAvailable.isEmpty() && nextAvailable.peek()[1] <= arrival[i]) {
                int[] tmp = nextAvailable.poll();
                int value = (((tmp[0] - i) % k) + k) % k + i;
                candidates.offer(value);
            }
            if (!candidates.isEmpty()) {
                int tmp = candidates.poll() % k;
                counts[tmp]++;
                nextAvailable.offer(new int[]{tmp, arrival[i] + load[i]});
            }
        }
        int max = 0;
        for (int i = 0; i < k; i++) {
            if (counts[i] < max) continue;
            if (counts[i] > max) {
                max =  counts[i];
                rst.clear();
            }
            rst.add(i);
        }
        return rst;
    }
}
```









  
