# 2.1

## [LCP 24. 数字游戏](https://leetcode.cn/problems/5TxKeK/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/problems/5TxKeK/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/02/02/16:39:22:LCP24.png" />
	</a>
</div>

本题其实相当于是一个问题, 求解了 n 次, 即让一个数组的元素变为单调递增, 需要操作的最少次数, 现在考虑数组的前 i 项, a[0], a[1]... a[i - 1], 假设在最优解中序列的形式为: x, x + 1... x + i - 1

那么显然, 每个位置 j, 其操作次数为: |a[j] - (x + j)| = |(a[j] - j) - x|, 如果记: b[j] = a[j] - j, 则有每个位置的操作次数为: |b[j] - x|, 整体上就是需要找到一个 x, 使得 $\sum_{j = 0}^{i - 1}|b[j] - x|$ 最小

将本题转化为一个求解相对距离的问题, 根据之前[绝对值区间求解距离](./一些算法.md#绝对值区间距离问题)中的证明, 显然此时 x 取到中位数时, 整体的距离最小

因此本题也就变为了, 如何快速的在一个长度不断增加的数组中求解中位数, 本题的输入范围达到了 $10^5$, 不允许时间复杂度超过 $O(n^2)$ 级别的算法, 这里求解中位数的方式参考[双堆问题](./一些算法.md#双堆问题)的求解方式, 通过维护两个堆, 在 $O(n\log n)$ 的时间内找到一个不断变长的数组的中位数

```java
class Solution {
    private static final int MOD = (int)1e9 + 7;
    public int[] numsGame(int[] nums) {
        int n = nums.length;
        int[] rst = new int[n];
        for (int i = 0; i < nums.length; i++) nums[i] -= i;
        PriorityQueue<Integer> max = new PriorityQueue<>((n1, n2) -> n2 - n1);
        PriorityQueue<Integer> min = new PriorityQueue<>();
        int max_sum = 0, min_sum = 0;
        for (int i = 0; i < n; i++) {
            if (!max.isEmpty() && nums[i] > max.peek()) {
                min.offer(nums[i]);
                min_sum += nums[i];
                if (min.size() - max.size() > 1) {
                    int tmp = min.poll();
                    min_sum -= tmp;
                    max.offer(tmp);
                    max_sum += tmp;
                }
            } else {
                max.offer(nums[i]);
                max_sum += nums[i];
                if (max.size() - min.size() > 1) {
                    int tmp = max.poll();
                    max_sum -= tmp;
                    min.offer(tmp);
                    min_sum += tmp;
                }
            }
            int target = min.size() > max.size() ? min.peek() : max.peek();
            long tmp = max.size() * target - max_sum;
            tmp += min_sum - min.size() * target;
            tmp %= MOD;
            rst[i] = (int)tmp;
        }
        return rst;
    }
}
```

# 2.2

## [1686. 石子游戏 VI (Stone Game VI)](https://leetcode.cn/classic/problems/stone-game-vi/description/)


<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/stone-game-vi/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/02/02/17:20:14:1686.png" />
	</a>
</div>

>   当一个石子被其中一个人拿走了, 不仅仅相当于获得了该石子的价值, 还会让另外的人无法获得该石子的价值

对于任意的两个石子 i 和 j, alice 如果 a[i] - b[j] > a[j] - b[i], 则 alice 会选择石子 i 而不是 j, 交换一下等价于 a[i] + b[i] > a[j] + b[j]

即每个人选择石子的时候, 不仅需要考虑当前自己对于石子的估值, 还应该考虑另外一个人对于石子的估值

```java
class Solution {
    public int stoneGameVI(int[] as, int[] bs) {
        int n = as.length;
        int[][] b = new int[n][3];
        for (int i = 0; i < n; i++) {
            b[i][0] = as[i] + bs[i];
            b[i][1] = as[i];
            b[i][2] = bs[i];
        }
        Arrays.sort(b, (b1, b2) -> b2[0] - b1[0]);
        int a_cnt = 0;
        int b_cnt = 0;
        for (int i = 0; i < n; i++) {
            if ((i & 1) == 0) a_cnt += b[i][1];
            else b_cnt += b[i][2];
        }
        if (a_cnt == b_cnt) return 0;
        return a_cnt > b_cnt ? 1 : -1;
    }
}
```

# 2.3

## [1690. 石子游戏 VII (Stone Game VII)](https://leetcode.cn/classic/problems/stone-game-vii/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/stone-game-vii/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/02/04/22:07:36:1690.png" />
	</a>
</div>

得分规则为: 如果移除了某个石子, 则获得剩下所有石子的分数

定义状态 f(i, j) 表示从范围 i 到 j 内移除石子后当前玩家和下个一玩家分数差值的最大值, 显然有 $f(i, j) = max(\sum_{k = i + 1}^{j} s[k] - f(i + 1, j), \sum_{i}^{j - 1}s[k] - f(i, j - 1))$

这里使用记忆化搜索, 搜索终点为 i = j, 此时玩家移除石子后不会得到任何分数, 直接返回 0 即可

```java
class Solution {
    private int[] s;
    private int[] pre;
    private int[][] buff;
    public int stoneGameVII(int[] s) {
        this.s = s;
        int n = s.length;
        this.pre = new int[n + 1];
        for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + s[i - 1];
        this.buff = new int[n][n];
        for (int i = 0; i < n; i++) Arrays.fill(buff[i], -1);
        return dfs(0, n - 1);
    }
    
    private int dfs(int i, int j) {
        if (buff[i][j] != -1) return buff[i][j];
        
        if (i == j) return 0;
        
        int rst = Math.max(pre[j + 1] - pre[i + 1] - dfs(i + 1, j), pre[j] - pre[i] - dfs(i, j - 1));
        buff[i][j] = rst;
        return buff[i][j];
    }
    
}
```

## [1043. Partition Array for Maximum Sum](https://leetcode.com/problems/partition-array-for-maximum-sum/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/partition-array-for-maximum-sum/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/02/04/22:17:39:1043.png" />
	</a>
</div>
因为输入范围很小, 只有 500, 这里直接枚举每个子数组的左右边界, 定义状态 f[i] 表示从 i 开始进行子数组的枚举时, 可以获得的最大价值

```java
class Solution {
    private int[] arr;
    private int[] buff;
    private int k;
    public int maxSumAfterPartitioning(int[] arr, int k) {
        this.arr = arr;
        int n = arr.length;
        this.buff = new int[n];
        Arrays.fill(buff, -1);
        this.k = k;
        return dfs(0);
    }
    
    private int dfs(int idx) {
        if (idx == arr.length) return 0;
        if (buff[idx] != -1) return buff[idx];
        int rst = 0;
        int max = arr[idx];
        for (int i = idx; i < idx + k && i < arr.length; i++) {
            max = Math.max(max, arr[i]);
            rst = Math.max(rst, max * (i - idx + 1) + dfs(i + 1));
        }
        buff[idx] = rst;
        return buff[idx];
    }
}
```

>   整体时间复杂度为: $O(k\times n)$

# 2.4

## [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/problems/minimum-window-substring/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img@latest/img/76.png" />
	</a>
</div>

找到一个覆盖了 t 的最小窗口, 因为 t 本身包含了重复字符, 因此这里需要使用一个数组维护每种字符出现的频率; 使用双指针维护一个窗口, 并维护变量 diff 表示当前窗口内, 不满足条件的字符种类的个数

本题就是不断更新窗口的大小 -> 记录最小的窗口

```java
class Solution {
    public String minWindow(String s, String t) {
        char[] ss = s.toCharArray();
        char[] ts = t.toCharArray();
        int[] freq = new int[64];
        int diff = 0;
        for (int i = 0; i < t.length(); i++) {
            int idx = ts[i] - 'A';
            if (freq[idx] == 0) diff++;
            freq[idx]--;
        }
        int l = 0;
        int b = -1;
        int min = 0x3f3f3f3f;
        for (int r = 0; r < s.length(); r++) {
            int idx = ss[r] - 'A';
            freq[idx]++;
            if (freq[idx] == 0) diff--;
            while (diff == 0) {
                int len = r - l + 1;
                if (len < min) {
                    b = l;
                    min = len;
                }
                int next = ss[l++] - 'A';
                if (freq[next] == 0) diff++;
                freq[next]--;
            }
        }
        if (b != -1) return new String(ss, b, min);
        return "";
    }
}
```

>   整体时间复杂度为: $O(m + n)$, 其中 s 中的每个字符最多遍历两次



















