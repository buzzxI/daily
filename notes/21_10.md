[toc]

# 10.8

## 莫里斯中序遍历

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/%E8%8E%AB%E9%87%8C%E6%96%AF%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png)

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new LinkedList<>();
        while(root != null){
            TreeNode predecessor = null;
            if(root.left == null){
                list.add(root.val);
                root = root.right;
            }else{
                predecessor = root.left;
                while(predecessor.right != null && predecessor.right != root){
                    predecessor = predecessor.right;
                }
                if(predecessor.right == null){
                    predecessor.right = root;
                    root = root.left;
                }else{
                    list.add(root.val);
                    predecessor.right = null;
                    root = root.right;
                }
            }
        }
        return list;
    }
}
```

# 10.11

## 242-有效的字母异位词

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/242.png)

判断两个字符串中每个字符出现频率是否一致

第一个想法，使用两个数组分别统计字符出现的频率，随后比较两个数组

随后考虑简化为一个数组统计，认为cnt[i] = cnt1[i] - cnt2[i]，随后判断数组是否全为0即可

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int len1 = s.length();
        int len2 = t.length();
        if(len1 != len2){
            return false;
        }
        int[] nums = new int[26];
        for(int i = 0; i < len1; i++){
            nums[s.charAt(i) - 'a']++;
            nums[t.charAt(i) - 'a']--;
        }
        for(int i = 0; i < 26; i++){
            if(nums[i] != 0){
                return false;
            }
        }
        return true;
    }
}
```

## 567

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/567.png)

判断一个字符串中是否包含是否包含另一个字符串的排列

因为是排列，不要求顺序，可以统计模板字符串中每一个字符出现的频率，然后使用滑动窗口，对要求匹配的字符串在窗口内的字符串统计字符出现的频率，然后比较，如果相同，就返回true，如果不同就滑动窗口，窗口滑动到字符串尾就返回false

具体实现上，可以用两个数组统计模板中的频率，和窗口中的频率

改进一下，对于不断滑动的窗口，每次只有一个字符进入，一个字符划出，完全没有必要每次都将两个表示频率的数组进行比较；可以引入变量diff，表示两个数组中频率不同的字符的个数，随后判断依据变为diff是否为0，随后每次滑动之后就通过进入和划出的字符修正窗口内字符出现的频率，并修正变量diff即可

假设划入的字符为x，划出的字符为y

x与y相等时，不做任何变化；x与y不相等的时候，在划出前判断，窗口中x频率和模板中x频率是否相等，如果相等diff自增（y同理），在划出后判断，窗口中x频率和模板中x频率是否相等，如果相等diff自减（y同理）

上述过程中使用了两个数组表示频率，实际中可以考虑使用一个数组类似于242

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int len1 = s1.length();
        int len2 = s2.length();
        if(len2 < len1){
            return false;
        }
        int[] nums = new int[26];
        for(int i = 0; i < len1; i++){
            nums[s1.charAt(i) - 'a']++;
            nums[s2.charAt(i) - 'a']--;
        }
        int diff = 0;
        for(int i = 0; i < 26; i++){
            if(nums[i] != 0){
                diff++;
            }
        }
        int x = 0;
        int y = 0;
        for(int i = 0; i <= len2 - len1; i++){
            if(diff == 0){
                return true;
            }else{
                if(i < len2 - len1){
                    x = s2.charAt(i + len1) - 'a';
                    y = s2.charAt(i) - 'a';
                    if(x != y){
                        if(nums[x] == 0){
                            diff++;
                        }
                        if(nums[y] == 0){
                            diff++;
                        }
                        nums[x]--;
                        nums[y]++;
                        if(nums[x] == 0){
                            diff--;
                        }
                        if(nums[y] == 0){
                            diff--;
                        }
                    }
                }
            }
        }
        return false;
    }
}
```

## 438

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/438.png)

类似于567，只不过本题中模板字符串出现的排序不止一次，唯一不同的点在于如果diff=0，就将此时窗口的头加入list中

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int len1 = s.length();
        int len2 = p.length();
        List<Integer> list = new ArrayList<>();
        if(len1 < len2){
            return list;
        }
        int[] nums = new int[26];
        for(int i = 0; i < len2; i++){
            nums[p.charAt(i) - 'a']++;
            nums[s.charAt(i) - 'a']--;
        }
        int diff = 0;
        for(int i = 0; i < 26; i++){
            if(nums[i] != 0){
                diff++;
            }
        }
        int x = 0;
        int y = 0;
        for(int i = 0; i <= len1 - len2; i++){
            if(diff == 0){
                list.add(i);
            }
            if(i < len1 - len2){
                x = s.charAt(i + len2) - 'a';
                y = s.charAt(i) - 'a';
                if(x != y){
                    if(nums[x] == 0){
                        diff++;
                    }
                    if(nums[y] == 0){
                        diff++;
                    }
                    nums[y]++;
                    nums[x]--;
                    if(nums[x] == 0){
                        diff--;
                    }
                    if(nums[y] == 0){
                        diff--;
                    }
                }
            }
        }
        return list;
    }
}
```

# 10.13

对于滑动窗口的题目可以配合队列解题（因为每次滑动窗口移位的时候就相当于队列头出队列，且队列尾部进入新元素）

## 239

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/239.png)

配合单调双端队列解题，且认为队列头为每次窗口移动后的最大值

使用单调减队列，且在队列中元素的大小是递减的，而元素的索引是递增的

考虑窗口移动后新的元素进入队列，如果当前元素大小大于队列尾，那么令队尾元素出队，因为队尾元素小于当前元素，且其索引也比当前元素靠前，当前元素加入后，不可能成为窗口中的最大值

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] rst = new int[nums.length - k + 1];
        Deque<Integer> deque = new LinkedList<>();
        int end = 0;
        for(int begin = 0; end < nums.length; end++){
            while(!deque.isEmpty() && deque.peekLast() < nums[end]){
                deque.pollLast();
            }
            //不管如何当前元素一定是要入队的，只不过需要考虑入队之前是否有元素需要出队
            deque.offerLast(nums[end]);
            //即窗口完成构建，此后begin和end每轮自增保证窗口移动下去
            if(end - begin == k - 1){
            	if(nums[begin] == deque.peekFirst()) {
            		rst[begin] = deque.pollFirst();
            	}else {
            		rst[begin] = deque.peekFirst();
            	}
                begin++;
            } 
        }
        return rst;
    }
}
```

## 剑指59

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/%E5%89%91%E6%8C%8759.png)

要求实现一个队列，并且能够以常数时间实现增加，减少，找到最大值

最简单的方式是使用辅助队列，队列头为队列中的最大值

```java
class MaxQueue {
    private Queue<Integer> queue;
    private Deque<Integer> max;
    public MaxQueue() {
        queue = new LinkedList<>();
        max = new LinkedList<>();
    }
    
    public int max_value() {
        int rst = -1;
        if(!max.isEmpty()){
            rst = max.peekFirst();
        }
        return rst;
    }
    
    public void push_back(int value) {
        queue.offer(value);
        while(!max.isEmpty() && max.peekLast() < value){
            max.pollLast();
        }
        max.offerLast(value);
    }
    
    public int pop_front() {
        int rst = - 1;
        if(!queue.isEmpty()){
            rst = queue.poll();
            if(rst == max.peekFirst()){
                max.pollFirst();
            }
        }
        return rst;
    }
}
```

## [1696. 跳跃游戏 VI](https://leetcode.cn/problems/jump-game-vi/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1696.png)

这题一看就是dp，问题在于直接dp会超时

原因在于这题的状态转移方程为：$\text{dp[i] = max}\begin{cases}\text{dp[i - 1]}\\ \text{dp[i - 2]}\\ .\\.\\.\\\text{dp[i - k]}\end{cases}+ \text{nums[i]}$

如果k的值很大，那么每次求dp的时候需要判断很多次

一个优化的方法是，保留一个长度为k的滑动窗口，并且每次获得这个窗口中最大的值，要注意的是维护的窗口从i-k开始到i-1结束

显然这就是239的一个增强版

```java
class Solution {
    public int maxResult(int[] nums, int k) {
        int len = nums.length;
        int[] dp = new int[len];
        dp[0] = nums[0];
        Deque<Integer> deque = new LinkedList<>();
        int begin = 0;
        int max = 0;
        for(int i = 1, end = 0; i < len; i++, end++){
            while(!deque.isEmpty() && dp[end] > deque.peekLast()){
                deque.pollLast();
            }
            deque.offerLast(dp[end]);
            //这里用了一个投机取巧的判断
            if(end - begin == k - 1 && deque.peekFirst() == dp[begin++]){
            	max = deque.pollFirst();
            }else{
                max = deque.peekFirst();
            }
            dp[i] = max + nums[i];
        }
        return dp[len - 1];
    }
}
```

## 1438

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1438.png)

这题最开始看，感觉没什么办法

正确的思路应该看到，要求的是一个区间，在这个区间内最大值和最小值差值不超过limit，在整个数组中，找到这个区间的最大长度

显然可以认为求得是一个滑动窗口的最大长度，这个长度通过窗口的最大值和最小值约束

显然可以通过维护两个单调队列获取在窗口不断移动时，每个窗口的最大最小值

```java
class Solution {
    public int longestSubarray(int[] nums, int limit) {
        Deque<Integer> max = new LinkedList<>();
        Deque<Integer> min = new LinkedList<>();
        int begin = 0;
        int rst = 0;
        for(int end = 0; end < nums.length; end++){
            while(!max.isEmpty() && nums[end] > max.peekLast()){
                max.pollLast();
            }
            max.offerLast(nums[end]);
            while(!min.isEmpty() && nums[end] < min.peekLast()){
                min.pollLast();
            }
            min.offerLast(nums[end]);
            while(max.peekFirst() - min.peekFirst() > limit){
                if(nums[begin] == min.peekFirst()){
                    min.pollFirst();
                }
                if(nums[begin] == max.peekFirst()){
                    max.pollFirst();
                }
                begin++;
            }
            rst = Math.max(rst, end - begin + 1);
        }
        return rst;
    }
}
```

# 10.18

## 378

> 二分有关内容需要头脑清醒的时候看，最好再写一下，比较不同的left，right的影响

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/378.png)

矩阵的每列和每行均为递增的，找到矩阵中第k大的元素，所以可以使用二分查找

```java
class Solution {
    private int[][] matrix;
    private int len;
    public int kthSmallest(int[][] matrix, int k) {
        this.matrix = matrix;
        this.len = matrix.length;
        //定义left为矩阵中最小的元素
        int left = matrix[0][0];
        //定义right为矩阵中最大的元素
        int right = matrix[len - 1][len - 1];
        //用 < 作为判断条件，这样中止循环的条件为left == right
        while(left < right){
            int mid = left + ((right - left) >> 1);
            //一个比较显然的是，如果counts < k，这样left一定是小了，left = mid + 1
            if(counts(mid) < k){
                left = mid + 1;
            }else{
                //如果counts >= k,right = mid,这样保险
                right = mid;
            }
        }
        /*
        	跳出循环前，一定有：left + 1 = right，此时一定有mid = left
        	如果因为counts太小，那么一定有counts(mid) < k && counts(right) >= k
        	(因为只有counts(right) >= k，right的范围才会缩小到left + 1的情况)
        	随后因为left = mid + 1 == right而跳出循环，此时left == right，即为返回条件
        	如果因为counts太大，那么一定有counts(mid) >= k并且在此之前的所有小于mid的值都有counts(mid) < k
        	(正是因为这样left范围才缩小为right - 1)
        	随后因为right = mid == left而跳出循环，此时left == right，即为返回条件
        */
        return left;
    }
    /*
    	该方法用来统计矩阵中小于等于mid的元素的个数
    	具体原理见下图
    */
    private int counts(int mid){
        int i = len - 1;
        int j = 0;
        int rst = 0;
        while(i >= 0 && j < len){
            if(matrix[i][j] <= mid){
                rst += i + 1;
                j++;
            }else{
                i--;
            }
        }
        return rst;
    }
}
```

关于方法counts：

因为统计的是矩阵中小于等于mid的元素的个数，就以mid为8为例

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/378_fig3.png)

从$i = n - 1, j = 0$开始统计，即矩阵的左下角，如果当前元素小于等于mid，这意味着这一列的元素都是待统计的，如果当前元素大于mid，那么需要回到上一行

## 668

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/668.png)

其实如果将输入变为矩阵那么这个题就和上面的题变成一道题了

如果额外引入一个矩阵，因为输入的m，n太大了，会爆内存

观察这个矩阵，很特殊，如果元素不是左侧和上侧边界上的，那么他的大小是一个乘积

```java
class Solution {
    private int m;
    private int n;
    public int findKthNumber(int m, int n, int k) {
        this.m = m;
        this.n = n;
        int left = 1;
        int right = m * n;
        while(left < right){
            int mid = left + ((right - left) >> 1);
            if(counts(mid) < k){
                left = mid + 1;
            }else{
                right = mid;
            }
        }
        return left;
    }
    private int counts(int mid){
        int rst = 0;
        int i = m - 1;
        int j = 0;
        while(i >= 0 && j < n){
            if(mid >= (i + 1) * (j + 1)){
                rst += i + 1;
                j++;
            }else{
                i--;
            }
        }
        return rst;
    }
}
```

可能唯一的不同就在于统计counts的时候吧，不过过程还是一样的

这里借用数组下标索引的特点，即从0开始，从左下角开始统计

## [719. 找出第 K 小的数对距离](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/719.png)

这题一开始就没什么思路

注意到如果将数组排序，那么最大的距离将是最后一个元素和第一个元素的差

```java
class Solution {
    private int[] nums;
    private int len;
    public int smallestDistancePair(int[] nums, int k) {
        Arrays.sort(nums);
        this.len = nums.length;
        this.nums = nums;
        //这里取left为0，并不是说任何情况下最小值都是0，给了一个小的下限罢了
        int left = 0;
        int right = nums[len - 1] - nums[0];
        while(left < right){
            int mid = left + ((right - left) >> 1);
            if(counts(mid) < k){
                left = mid + 1;
            }else{
                right = mid;
            }
        }
        return left;
    }
    /*
    	用来统计，排序后，所有差值小于等于mid的距离的个数
    	统计的方法很巧妙，利用了双指针，对于一个有序的数组，显然当r距离l越远，dis越大
    	这样不断移动r，并根据mid选择性移动l，就可以统计整个数组中距离小于等于mid的个数
    */
    private int counts(int mid){
        int l = 0;
        int rst = 0;
        for(int r = 1; r < len; r++){
            while(nums[r] - nums[l] > mid && l < r){
                l++;
            }
            //这一步很关键，举例子来说，如果r = 3，l = 0，那么一共有(0,3),(1,3),(2,3)三个数据对是满足的条件，他们共同的特点是有公共上限3
            rst += r - l;
        }
        return rst;
    }
}
```

## 786

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/786.png)

数组有序，分数范围为（0，1）均为开区间

可以使用二分找到对应的i，j

定义left为0，而right为1，确定mid，在数组内查找小于等于mid的分数的个数，并将其和k比较大小

这里比较特殊的是，返回值是一个数组，定义数组大小为3，下标索引为0处标识小于等于mid的个数，下标索引为1处标识在所有小于等于mid的分数中最大的分数的分子，下标索引为2处标识在所有小于等于mid的分数中最大的分数的分母

统计个数的时候维护双指针，右指针遍历整个数组，左指针保证了左指针与右指针的商刚好大于mid，这样对于一个特定的右指针，其在数组中所有小于等于mid的分数（右边界为分母，左边界为分子）的个数为左指针的值

```java
class Solution {
    private int[] arr;

    public int[] kthSmallestPrimeFraction(int[] arr, int k) {
        this.arr = arr;
        double left = 0;
        double right = 1;
        while (left < right) {
            double mid = (left + right) / 2;
            int[] tmp = count(mid);
            if (tmp[0] < k) {
                left = mid;
            }else if (tmp[0] > k) {
                right = mid;
            }else {
                return new int[]{tmp[1], tmp[2]};
            }
        }
        return null;
    }

    private int[] count(double mid) {
        int[] rst = new int[3];
        for (int right = 1; right < arr.length; right++) {
            int left = 0;
            for (; (double)(arr[left]) / (double)(arr[right]) <= mid; left++);
            rst[0] += left;
            if (left > 0 && arr[left - 1] * rst[2] >= arr[right] * rst[1]) {
                rst[1] = arr[left - 1];
                rst[2] = arr[right];
            }
        } 
        return rst;
    }
}
```

## 658

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/658.png)

没什么好说的，先二分再线性查找就行

```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        int len = arr.length;
        int left = 0;
        int right = len - 1;
        int mid = 0;
        int count = 0;
        int[] nums = new int[k];
        while(left <= right){
            mid = left + ((right - left) >> 1);
            if(arr[mid] < x){
                left = mid + 1;
            }else if(arr[mid] > x){
                right = mid - 1;
            }else{
                break;
            }
        }
        if(left > right){
            int tmp = left;
            left = right;
            right = tmp;
        }else{
            nums[count++] = x;
            left = mid - 1;
            right = mid + 1;
        }
        while(left >= 0 && right < len && count < k){
            if(x- arr[left] > arr[right] - x){
                nums[count++] = arr[right++];
            }else{
                nums[count++] = arr[left--];
            }
        }
        while(count < k && left >= 0){
            nums[count++] = arr[left--];
        }
        while(count < k && right < len){
            nums[count++] = arr[right++];
        }
        Arrays.sort(nums);
        return Arrays.stream(nums).boxed().collect(Collectors.toList());
    }
}
```

## [27-移除元素](https://leetcode-cn.com/problems/remove-element/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/27.png)

这题我第一眼看上去居然要移动整个数组，真是太麻烦了

而实际上他正确的解法是用一个双指针，一个慢指针指向当前位置应该填写的元素，一个快指针指向下一个要填到慢指针位置处的元素

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int left = 0;
        int right = 0;
        int n = nums.length;
        while (right < n) {
            while (right < n && nums[right] == val) right++;
            if (right < n) nums[left++] = nums[right++];
        }
        return left;
    }
}
```

## [26-删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/26.png)

不想多说，同上

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int n = nums.length;
        int left = 0;
        for (int right = 0; right < n; left++) {
            int tmp = nums[right];
            while (right < n && nums[right] == tmp) right++;
            nums[left] = tmp;
        }
        return left;
    }
}
```

## [80-删除有序数组种的重复项II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/submissions/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/80.png)

现在允许重复的字符出现次数为2，我们还是移动right指针当和前一个元素相同的时候不断向前滑动

当right滑到不同的字符的时候我们会得到一个相同字符的区间长度，如果这个区间长度大于2的话，我们就对left指针的位置填入2次，如果这个区间长度小于2的话，我们就将left指针一直填到right的位置，所以其实就算题设更改允许重复的次数，我们的复杂度也不会变化

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int left = 0;
        int right = 0;
        int n = nums.length;
        while (right < n) {
            int start = right;
            while (right < n && nums[right] == nums[start]) right++;
            int len = Math.min(right - start, 2);
            while (len > 0) {
                nums[left++] = nums[start];
                len--;
            }
        }
        return left;
    }
}
```

# 10.19

## [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/21.png)

很常规

l1为空时返回l2，l2为空时返回l1

否则递归，判断l1，l2头部的大小关系决定第一个节点

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null){
            return l2;
        }else if(l2 == null){
            return l1;
        }else if(l1.val < l2.val){
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }else{
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```

### 22/3/7

2022/3/7重新写了一遍：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if (list1 == null) return list2;
        if (list2 == null) return list1;
        if (list1.val < list2.val) {
            list1.next = mergeTwoLists(list1.next, list2);
            return list1;
        }else {
            list2.next = mergeTwoLists(list1, list2.next);
            return list2;
        }
    }
}
```

> 为什么要用那么多的if-else呢...

## [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/23.png)

两种方法，可以分治，或使用优先队列（小顶堆）

分治时最小简化为两个链表合并，简化为21题，然后四个四个合并（两个合并的结果为一个链表，所以其实还是两个合并）

```java
class Solution {
    //单独写出来为了避免参数传递，没什么用
    private ListNode[] lists;
    public ListNode mergeKLists(ListNode[] lists) {
        this.lists = lists;
        int begin = 0;
        int end = lists.length - 1;
        if(end == -1){
            return null;
        }
        return mergeKLists(begin, end);
    }
    private ListNode mergeKLists(int begin, int end){
        //每次递归返回一个链表，所以需要将左右两个链表合并，即21题
        if(begin < end){
            int mid = begin + ((end - begin) >> 1);
            return merge(mergeKLists(begin, mid), mergeKLists(mid + 1, end));
        }else{
            //最终停止递归的条件是left == right，此时数组中只有一个链表，返回即可
        	return lists[begin];
        }
    }
    private ListNode merge(ListNode list1, ListNode list2){
        if(list1 == null){
            return list2;
        }else if(list2 == null){
            return list1;
        }else if(list1.val < list2.val){
            list1.next = merge(list1.next, list2);
            return list1;
        }else{
            list2.next = merge(list1, list2.next);
            return list2;
        }
    }
}
```

使用优先队列（小顶堆）时，考虑先将所有链表的头部加入小顶堆，然后堆顶元素出队列，如果该元素有后继节点，就让后继节点入队列

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        //使用lambda表达式的写法，实现小顶堆
        PriorityQueue<ListNode> queue = new PriorityQueue<ListNode>((ListNode node1, ListNode node2) -> node1.val - node2.val);
        ListNode rst = null;
        for(int i = 0; i < lists.length; i++) {
        	if(lists[i] != null) {
        		queue.offer(lists[i]);
        	}
        }
        ListNode tmp;
        ListNode current = null;
        while(!queue.isEmpty()) {
        	tmp = queue.poll();
        	if(tmp.next != null) {
        		queue.offer(tmp.next);
        	}
        	if(rst == null) {
        		rst = new ListNode(tmp.val);
        		current = rst;
        	}else {
        		current.next = new ListNode(tmp.val);
        		current = current.next;
        	}
        }
        return rst;
    }
}
```

### 22/3/7

2022/3/7重新写了一遍，用的的归并排序的写法：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) return null;
        return mergeKLists(lists, 0, lists.length - 1);
    }

    private ListNode mergeKLists(ListNode[] lists, int begin, int end) {
        if (begin == end) return lists[begin];
        int mid = begin + ((end - begin) >> 1);
        ListNode list1 = mergeKLists(lists, begin, mid);
        ListNode list2 = mergeKLists(lists, mid + 1, end);
        return mergeKLists(list1, list2);
    }

    private ListNode mergeKLists(ListNode list1, ListNode list2) {
        if (list1 == null) return list2;
        if (list2 == null) return list1;
        if (list1.val < list2.val) {
            list1.next = mergeKLists(list1.next, list2);
            return list1;
        }else {
            list2.next = mergeKLists(list1, list2.next);
            return list2;
        }
    }
}
```

> 还是归并用的顺手

## 373

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/373.png)

我的策略是采用小顶堆

首先因为两个数组是有序的，所以最小的和一定是nums1[0]和nums2[0]

我的策略是将首先将一个数组中的第一项和另一个数组中的所有项加入堆

然后去除堆顶，并加入数组的第二项和堆顶中对应的另一个元素的项

```java
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] num1, int[] num2) -> nums1[num1[0]] + nums2[num1[1]] - (nums1[num2[0]] + nums2[num2[1]]));
        int len1 = nums1.length;
        int len2 = nums2.length;
        for(int i = 0; i < len2; i++){
            queue.offer(new int[]{0, i});
        }
        List<List<Integer>> rst = new ArrayList<>();
        int count = 0;
        int[] tmp;
        //因为k的大小居然会超范围
        k = Math.min(len1 * len2 ,k);
        while(count < k){
            tmp = queue.poll();
            count++;
            rst.add(Arrays.stream(new int[] {nums1[tmp[0]], nums2[tmp[1]]}).boxed().collect(Collectors.toList()));
            if(tmp[0] < len1 - 1){
                queue.offer(new int[]{tmp[0] + 1, tmp[1]});
            }
        }
        return rst;
    }
}
```

> 感觉如果是找到最小的第k对元素的话，可以使用二分

## 378

这个题写过，不过我认为用堆也能解决

![](img/378.png)

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] nums1, int[] nums2) -> nums1[0] - nums2[0]);
        int n = matrix.length;
        for(int i = 0; i < matrix.length; i++){
            queue.offer(new int[]{matrix[0][i], 0, i});
        }
        int count = 0;
        int[] tmp;
        while(!queue.isEmpty()){
            tmp = queue.poll();
            count++;
            if(count == k){
                return tmp[0];
            }
            if(tmp[1] != n - 1 ){
                queue.offer(new int[]{matrix[tmp[1] + 1][tmp[2]], tmp[1] + 1, tmp[2]});
            }
        }
        return 0;
    }
}
```

加入的顺序很讲究，具体看[加入的先后顺序](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/shi-yong-dui-heapde-si-lu-xiang-jie-ling-fu-python/)

# 10.20

## 208

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/208.png)

实现一个字典树，字典树的特点是，根节点不保存数据，其具有若干子节点，在该题中个数为26个（小写字母的个数），若为ASCII码，则具有256个

且每一个节点具有布尔型变量isEnd，用来表示是否达到尾部

```java
class Trie {
    private Trie[] children;
    private boolean isEnd;
    public Trie() {
        children = new Trie[26];
        isEnd = false;
    }
    
    public void insert(String word) {
       Trie node = this;
       for(int i = 0; i < word.length(); i++){
           int index = word.charAt(i) - 'a';
           if(node.children[index] == null){
               node.children[index] = new Trie();
           }
           node = node.children[index];
       }
       node.isEnd = true;
    }
    
    public boolean search(String word) {
        Trie node = prefixNode(word);
        return node != null && node.isEnd;
    }
    
    public boolean startsWith(String prefix) {
    	return prefixNode(prefix) != null;
    }
    
    private Trie prefixNode (String prefix){
        Trie node = this;
        for(int i = 0; i < prefix.length(); i++){
            int index = prefix.charAt(i) - 'a';
            if(node.children[index] == null){
                return null;
            }else{
                node = node.children[index];
            }
        }
        return node;
    }
}
```

使用一个数组进行实现，实际中还可以使用map

```java
class Trie {
    private Map<Character, Trie> children;
    private boolean isEnd;
    public Trie() {
        children = new HashMap<>();
        isEnd = false;
    }
    
    public void insert(String word) {
       Trie node = this;
       char tmp = 0;
       for(int i = 0; i < word.length(); i++){
           tmp = word.charAt(i);
           if(node.children.get(tmp) == null){
               node.children.put(tmp, new Trie());
           }
           node = node.children.get(tmp);
       }
       node.isEnd = true;
    }
    
    public boolean search(String word) {
        Trie node = prefixNode(word);
        return node != null && node.isEnd;
    }
    
    public boolean startsWith(String prefix) {
    	return prefixNode(prefix) != null;
    }
    
    private Trie prefixNode (String prefix){
        Trie node = this;
        char tmp = 0;
        for(int i = 0; i < prefix.length(); i++){
            tmp = prefix.charAt(i);
            if(node.children.get(tmp) == null){
                return null;
            }else{
                node = node.children.get(tmp);
            }
        }
        return node;
    }
}
```

## 211

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/211.png)

```java
class WordDictionary {
    private Trie trie;

    public WordDictionary() {
        trie = new Trie();
    }
    
    public void addWord(String word) {
        trie.insert(word);
    }
    
    public boolean search(String word) {
        return trie.contains(word);
    }
}
class Trie{
    private Trie[] children;
    private boolean isEnd;

    public Trie(){
        children = new Trie[26];
        isEnd = false;
    }

    public void insert(String word){
        Trie node = this;
        for(int i = 0; i < word.length(); i++){
            int index = word.charAt(i) - 'a';
            if(node.children[index] == null){
                node.children[index] = new Trie();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }
	/*
		关键在于contains方法的实现上
		如果字符是“.”的情况时，那么就将string截断
		对于当前节点所有非空的子节点，判断是否能匹配
		值得注意的时当到达尾部的时候，此时如果word以“.”结尾
		那么迭代进入内层函数时，不会进入for循环，只要有一个子节点为尾部，就将返回true
	*/
    public boolean contains(String word){
        Trie node = this;
        char c = 0;
        int index = 0;
        for(int i = 0; i < word.length(); i++){
            c = word.charAt(i);
            if(c != '.'){
                index = c - 'a';
                if(node.children[index] == null){
                    return false;
                }
                node = node.children[index];
            }else{
                boolean flag = false;
                for(Trie t : node.children){
                    if(t != null){
                        if(t.contains(word.substring(i + 1, word.length()))){
                            flag = true;
                        }
                    }
                }
                return flag;
            }
        }
        return node.isEnd;
    }

}
```

## [648. 单词替换](https://leetcode.cn/problems/replace-words/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/648.png)

这个题，隐含着，如果dictionary中同时有：“a”,"aa"，那么以“a”为标准

首先将字典中所有的单词存入字典树中，然后将句子以“ ”分离获取数组，对数组中的每一个元素，放进字典树中查找

查找的标准是，只要找到节点的end，就返回由开始到end所有字符构成的字符串，否则返回输入本身

```java
class Solution {
    public String replaceWords(List<String> dictionary, String sentence) {
        Trie trie = new Trie();
        for(String s : dictionary){
            trie.insert(s);
        }
        String[] words = sentence.split(" ");
        for(int i = 0; i < words.length; i++){
            words[i] = trie.replace(words[i]);
        }
        StringBuilder sb = new StringBuilder();
        int i = 0;
        for(; i < words.length - 1; i++){
            sb.append(words[i]);
            sb.append(" ");
        }
        sb.append(words[i]);
        return sb.toString();
    }
}
class Trie{
    private Trie[] children;
    private boolean isEnd;

    public Trie(){
        this.children = new Trie[26];
        this.isEnd = false;
    }

    public void insert(String word){
        Trie node = this;
        int index = 0;
        for(int i = 0; i < word.length(); i++){
            index = word.charAt(i) - 'a';
            if(node.children[index] == null){
                node.children[index] = new Trie();
            }else if(node.children[index].isEnd){
                return;
            }
            node = node.children[index];
        }
        node.isEnd = true;
        //很关键，如果不加，对于字典输入为：{"aa","a"}的形式将构建错误的字典
        for(int i = 0; i < 26; i++){
            node.children[i] = null;
        }
    }

    public String replace(String word){
        Trie node = this;
        int index = 0;
        for(int i = 0; i < word.length(); i++){
            index = word.charAt(i) - 'a';
            if(node.children[index] != null){
                if(!node.children[index].isEnd){
                    node = node.children[index];
                }else{
                    return word.substring(0, i + 1);
                }   
            }else{
                break;
            }
        }
        return word;
    }
}
```

## 720

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/720.png)

使用字典树和回溯

使用一个stringbuilder用来记录路径

中止递归的条件是当节点的所有子节点都不具有尾部，或者子节点为空

此时记录一个rst，可能不是最长的，所以判断的时候需要比较当前rst的大小和其他路径递归后rst的大小确定最终的大小

```java
class Solution {
    public String longestWord(String[] words) {
        Trie trie = new Trie();
        for(int i = 0; i <words.length; i++){
            trie.insert(words[i]);
        }
        return trie.dfs();
    }
}
class Trie{
    private Trie[] children;
    private boolean isEnd;
    private String rst;
    public Trie(){
        children = new Trie[26];
        isEnd = false;
        rst = "";
    }

    public void insert(String word){
        Trie node = this;
        int index = 0;
        for(int i = 0; i < word.length(); i++){
            index = word.charAt(i) - 'a';
            if(node.children[index] == null){
                node.children[index] = new Trie();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }

    public String dfs(){
        StringBuilder sb = new StringBuilder();
        dfs(this, sb);
        return this.rst;
    }
    
    private void dfs(Trie trie, StringBuilder sb){
        boolean flag = true;
        for(int i = 0; i < 26; i++){
            if(trie.children[i] != null && trie.children[i].isEnd){
                flag = false;
                sb.append((char)(i + 'a'));
                dfs(trie.children[i], sb);
                sb.delete(sb.length() - 1, sb.length());
            }
        }
        if(flag && sb.length() > rst.length()){
            this.rst = sb.toString();
        }
    }
}
```

## 212

![](https://cdn.jsdelivr.net/gh/SunYuanI/img@latest/img/212.png)

单词搜索I需要判断矩阵中是否有某一个单词，而这个需要判断多个单词中有几个出现

朴素的想法是，对于矩阵中的每一个位置，都去判断是否可以构成一个完整的单词

因为不允许同一个位置在一个单词中重复出现，所以需要marked数组用来标识已经走过该路径

> 或者可以节省空间，类似题解的写法，直接将该位置的单词改写，结束遍历的时候再改回来

```java
class Solution {
    //directions用来指示每次行走的方法，final类型可以在编译器确定数值
    private final int[][] dircetions = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    //矩阵的行和列
    private int row;
    private int col;
    private boolean[][] marked;
    private char[][] board;
    //路径
    private List<Character> path;
    private Set<String> set;
    public List<String> findWords(char[][] board, String[] words) {
        Trie trie = new Trie();
        this.set = new HashSet<>();
        this.path = new ArrayList<>();
        this.board = board;
        for(int i = 0; i < words.length; i++){
            trie.insert(words[i]);
        }
        row = board.length;
        col = board[0].length;
        marked = new boolean[row][col];
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                char tmp = board[i][j];
                if(trie.children.get(tmp) != null && !marked[i][j]){
                    path.add(tmp);
                    marked[i][j] = true;
                    dfs(trie.children.get(tmp), i, j);
                    path.remove(path.size() - 1);
                    marked[i][j] = false;
                }
            }
        }
        return new ArrayList(set);
    }
    private void dfs(Trie trie, int x, int y){
        if(trie.isEnd){
            StringBuilder sb = new StringBuilder();
            for(Character c : path){
                sb.append(c);
            }
            set.add(sb.toString());
        }
        int mx = 0;
        int my = 0;
        char tmp = 0;
        for(int i = 0; i < 4; i++){
           mx = x + dircetions[i][0];
           my = y + dircetions[i][1];
           if(mx >= 0 && mx < row && my >= 0 && my < col && !marked[mx][my]){
               tmp = board[mx][my];
               if(trie.children.get(tmp) != null){
                   path.add(tmp);
                   marked[mx][my] = true;
                   dfs(trie.children.get(tmp), mx, my);
                   path.remove(path.size() - 1);
                   marked[mx][my] = false;
               }
           }
        }
    }
}
class Trie{
    HashMap<Character, Trie> children;
    boolean isEnd;

    public Trie(){
        this.children = new HashMap<>();
        this.isEnd = false;
    }

    public void insert(String word){
        Trie node = this;
        char index = 0;
        for(int i = 0; i < word.length(); i++){
            index = word.charAt(i);
            if(node.children.get(index) == null){
                node.children.put(index, new Trie());
            }
            node = node.children.get(index);
        }
        node.isEnd = true;
    }
}
```

额外插一个：

assertEquals（）方法：判断两个对象是否相等

assertArrayEquals（）方法：判断两个数组是否相等

前一个参数为期望值，后一个参数为实际值，如果不同会出现error

```java
	int[] nums = new int[] {1,2,3};
    try {
		Assert.assertArrayEquals(new int{1,2,2}, nums);
    }catch (java.lang.AssertionError e) {
        // TODO: handle exception
        
    }
```

# 10.23

## [133. 克隆图](https://leetcode-cn.com/problems/clone-graph/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/133.png)

使用DFS进行复制，使用一个map防止出现环路，map键为原节点，值为新节点

```java
class Solution {
    public Node cloneGraph(Node node) {
        if(node == null){
            return null;
        }
        HashMap<Node, Node> visited = new HashMap<>();
        return clone(node, visited);
    }
    private Node clone(Node node, HashMap<Node, Node> visited){
        if(visited.containsKey(node)){
            return visited.get(node);
        }
        Node rst = new Node(node.val);
        visited.put(node, rst);
        for(Node n : node.neighbors){
            rst.neighbors.add(clone(n, visited));
        }
        return rst;
    }
}
```

或者使用栈实现DFS

```JAVA
class Solution {
    public Node cloneGraph(Node node) {
        if(node == null){
            return null;
        }
        Deque<Node> stack = new LinkedList<>();
        HashMap<Node, Node> visited = new HashMap<>();
        Node rst = new Node(node.val);
        visited.put(node, rst);
        stack.push(node);
        Node tmp;
        while(!stack.isEmpty()){
            tmp = stack.pop();
            for(Node n : tmp.neighbors){
                if(!visited.containsKey(n)){
                    visited.put(n, new Node(n.val));
                    stack.push(n);
                }
                visited.get(n).neighbors.add(visited.get(tmp));
            }
        }
        return rst;
    }
}
```

## [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/138.png)

一个最直观的就是先遍历一遍链表，构建好链表每个节点的next节点

然后再遍历一遍，构建好每个节点的random节点

一个需要注意的是，为了能够获取新链表中random指向的节点，可以使用一个映射表

表的key为旧链表中的节点，而val为新链表中的节点

这样在查询的时候能够找到新链表中对应的节点

```JAVA
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null){
            return null;
        }
        HashMap<Node, Node> map = new HashMap<>();
        Node newHead = new Node(head.val);
        map.put(head, newHead);
        Node current = newHead;
        Node reference = head;
        while(reference.next != null){
            current.next = new Node(reference.next.val);
            current = current.next;
            reference = reference.next;
            map.put(reference, current);
        }
        current = newHead;
        reference = head;
        while(current != null){
            current.random = map.get(reference.random);
            current = current.next;
            reference = reference.next;
        }
        return newHead;
    }
}
```

而事实上，也可以一次遍历就构建一个链表

```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null){
            return null;
        }
        HashMap<Node, Node> map = new HashMap<>();
        Node newHead = new Node(head.val);
        map.put(head, newHead);
        Node current = newHead;
        Node reference = head;
        while(reference != null && (reference.next != null || reference.random != null)){
            if(map.containsKey(reference.next)){
                current.next = map.get(reference.next);
            }else if(reference.next != null){
                current.next = new Node(reference.next.val);
                map.put(reference.next, current.next);
            }
            if(map.containsKey(reference.random)){
                current.random = map.get(reference.random);
            }else if(reference.random != null){
                current.random = new Node(reference.random.val);
                map.put(reference.random, current.random);
            }
            current = current.next;
            reference = reference.next;
        }
        return newHead;
    }
}
```

同时构建next节点和random节点，为了保证不创建重复的节点，需要每次next，random操作的时候都需要查询map，如果map中已经存在对应val为对应的新节点，就连接新节点

> 这个题我选择还是按照next向前推进，只不过强行把random揉到这个过程中了

## [207-课程表](https://leetcode-cn.com/problems/course-schedule/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/207.png)

说是拓扑排序，其实就是看看图中有没有环

DFS方式：

```java
class Solution {
    private boolean[] marked;
    private List<List<Integer>> edges;
    private boolean[] onStack;
    private boolean hasCycle;
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        marked = new boolean[numCourses];
        onStack = new boolean[numCourses];
        hasCycle = false;
        edges = new ArrayList<>();
        for(int i = 0; i < numCourses; i++){
            edges.add(new ArrayList<>());
        }
        //使用edges作为邻接表，进而找到邻居
        for(int i = 0; i < prerequisites.length; i++){
            edges.get(prerequisites[i][1]).add(prerequisites[i][0]);
        }
        for(int i = 0; i < numCourses; i++){
            if(!marked[i]){
                dfs(i);
            }
        }
        return !hasCycle;
    }
    //onstack用来判断有向图中是否存在环
    private void dfs(int i){
        marked[i] = true;
        onStack[i] = true;
        for(int other : edges.get(i)){
            if(hasCycle){
                return;
            }
            if(!marked[other]){
                dfs(other);
            }else if(onStack[other]){
                hasCycle =  true;
                return;
            }
        }
        onStack[i] = false;
    }
}
```

BFS方式：为了判断能否完成所有课程，首先要完成那些没有先修课程的

没有先修课程体现为入度为0

随后将这些课程的邻居的入度递减，表示下一步可以上的课程

遍历最终的结果：如果没有课程的入度为0，即队列为空

而此时记录已经上过的课程数量，如果小于给定数量，就返回false

> 环的入度不可能是0

```java
class Solution {
    private int[] indegree;
    private List<List<Integer>> edges;
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        this.indegree = new int[numCourses];
        edges = new ArrayList<>();
        for(int i = 0; i < numCourses; i++){
            edges.add(new ArrayList<>());
        }
        for(int i = 0; i < prerequisites.length; i++){
            edges.get(prerequisites[i][1]).add(prerequisites[i][0]);
            indegree[prerequisites[i][0]]++;
        }
        Deque<Integer> queue = new LinkedList<>();
        for(int i = 0; i < numCourses; i++){
            if(indegree[i] == 0){
                queue.offerLast(i);
            }
        }
        int visit = 0;
        while(!queue.isEmpty()){
            int tmp = queue.pollFirst();
            visit++;
            for(int num : edges.get(tmp)){
                indegree[num]--;
                if(indegree[num] == 0){
                    queue.offerLast(num);
                }
            }
        }
        return visit == numCourses;
    }
}
```

## [210-课程表II](https://leetcode-cn.com/problems/course-schedule-ii/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/210.png)

和207最大的不同就是如果能完成就返回顺序，如果不能完成就返回空数组

这个显然就是拓扑排序了

还是一样的，对于DFS来说，需要额外的stack用来存储

要注意的是，如果这个节点所有的邻居节点都已经遍历过后就将这个节点压入栈

这样的顺序保证了栈底的课程是最后学习的课程，而栈顶的课程是最先学习的，所以构建返回数组的时候依次出栈即可

```java
class Solution {
    private boolean[] marked;
    private boolean[] onStack;
    private boolean hasCycle;
    private Deque<Integer> deque;
    private List<List<Integer>> edges;
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        marked = new boolean[numCourses];
        onStack = new boolean[numCourses];
        hasCycle = false;
        deque = new LinkedList<>();
        edges = new ArrayList<>();
        for(int i = 0; i < numCourses; i++){
            edges.add(new ArrayList<>());
        }
        for(int i = 0; i < prerequisites.length; i++){
            edges.get(prerequisites[i][1]).add(prerequisites[i][0]);
        }
        for(int i = 0; i < numCourses; i++){
            if(!marked[i]){
                dfs(i);
            }
        }
        if(hasCycle){
            return new int[0];
        }
        int[] rst = new int[deque.size()];
        for(int i = 0; i < rst.length; i++){
            rst[i] = deque.pollLast();
        }
        return rst;
    }
    private void dfs(int i){
        marked[i] = true;
        onStack[i] = true;
        for(int num : edges.get(i)){
            if(hasCycle){
                return;
            }else if(!marked[num]){
                dfs(num);
            }else if(onStack[num]){
                hasCycle = true;
                return;
            }
        }
        if(hasCycle){
            return;
        }
        onStack[i] = false;
        deque.offerLast(i);
    }
}
```

而对于BFS来说，好在会先处理所有的课程选到入度为0的课程先入队，所以入队的顺序就是返回的顺序

```java
class Solution {
    private List<List<Integer>> edges;
    private int[] indegree;
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        this.indegree = new int[numCourses];
        edges = new ArrayList<>();
        for(int i = 0; i < numCourses; i++){
            edges.add(new ArrayList<>());
        }
        for(int i = 0; i < prerequisites.length; i++){
            edges.get(prerequisites[i][1]).add(prerequisites[i][0]);
            indegree[prerequisites[i][0]]++;
        }
        Deque<Integer> queue = new LinkedList<>();
        for(int i = 0; i < numCourses; i++){
            if(indegree[i] == 0){
                queue.offerLast(i);
            }
        }
        int[] rst = new int[numCourses];
        int visit = 0;
        while(!queue.isEmpty()){
            int tmp = queue.pollFirst();
            rst[visit++] = tmp;
            for(int num : edges.get(tmp)){
                indegree[num]--;
                if(indegree[num] == 0){
                    queue.offerLast(num);
                }
            }
        }
        if(visit == numCourses){
            return rst;
        }else{
            return new int[0];
        }
    }
}
```

## [329-矩阵中最长的递增路径](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/329.png)

这个题一看上去就没什么犹豫的，DFS就完事了

最开始的想法：遍历矩阵中的每一个节点，进行DFS，记录最大值

这样会超时

其实这样的DFS做了很多重复的工作，就以图中的线路而言，显然`1`位置处的最长路径为`2`位置处的最大路径加一得到

所以引入缓存buffer，用来记录，每一个位置处的路径最大值，查询的时候先查buffer

```java
class Solution {
    private int row;
    private int col;
    private int[][] matrix;
    private int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    private int[][] buffer;
    public int longestIncreasingPath(int[][] matrix) {
        this.row = matrix.length;
        this.col = matrix[0].length;
        this.buffer = new int[row][col];
        this.matrix = matrix;
        int max = 0;
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                max = Math.max(max, dfs(i, j));
            }
        }
        return max;
    }
    //记住buffer就是当前位置最长路径，缺省值为0，而实际中最小为1
    private int dfs (int x, int y){
        if(buffer[x][y] != 0){
            return buffer[x][y];
        }
        int mx;
        int my;
        buffer[x][y]++;
        for(int i = 0; i < 4; i++){
            mx = x + directions[i][0];
            my = y + directions[i][1];
            if(mx >= 0 && mx < row && my >= 0 && my < col && matrix[x][y] < matrix[mx][my]){
               buffer[x][y] = Math.max(buffer[x][y], dfs(mx, my) + 1);
            }
        }
        return buffer[x][y];
    } 
}
```

## [684-冗余连接](https://leetcode-cn.com/problems/redundant-connection/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/684.png)

这题一眼上去就是看看就是环，一看到环，我就想到前面的题了

关键他这个返回值太奇怪了居然让我返回边

那我就把环中所有的节点都记录下来，然后用边去筛选，如果一条边中的两个点都在环中我就更新返回值

```java
class Solution {
    private boolean[] marked;
    private Set<Integer> cycle;
    private List<List<Integer>> table;
    private boolean hasCycle;
    private Deque<Integer> stack;
    public int[] findRedundantConnection(int[][] edges) {
        int n = edges.length;
        this.marked = new boolean[n];
        this.cycle = new HashSet<>();
        this.table = new ArrayList<>();
        this.hasCycle = false;
        this.stack = new LinkedList<>();
        for(int i = 0; i < n; i++){
            table.add(new ArrayList<>());
        } 
        for(int i = 0; i < n; i++){
            table.get(edges[i][1] - 1).add(edges[i][0] - 1);
            table.get(edges[i][0] - 1).add(edges[i][1] - 1);
        }
        for(int i = 0; i < n; i++){
            if(hasCycle){
                break;
            }
            if(!marked[i]) {
            	dfs(i, i);
            }
            
        }
        int[] rst = new int[2];
        for(int i = 0; i < n; i++){
            if(cycle.contains(edges[i][0] - 1) && cycle.contains(edges[i][1] - 1)){
                rst[0] = edges[i][0];
                rst[1] = edges[i][1];
            }
        }
        return rst;
    }
    private void dfs(int i, int before){
        marked[i] = true;
        stack.push(i);
        for(int num : table.get(i)){
            if(hasCycle){
                return;
            }
            if(!marked[num]){
                dfs(num, i);
            }else if(num != before){
                hasCycle = true;
                while(stack.peek() != num){
                    cycle.add(stack.pop());
                }
                cycle.add(stack.pop());
            }
        }
        if(hasCycle) {
        	return;
        }
        stack.pop();
    }
}
```

鬼能想到，这个破题居然可以用并查集解决

根据边的信息，构建并查集，构建到如果新边中两个节点已经具有公共的父节点了，那么这条新边就是多余的，返回就好了

需要实现并查集中的方法：

* `boolean isConnected()`
* `void union()`
* `int getParent()`

```java
class Solution {
    private int[] parent;
    private int[] weight;
    public int[] findRedundantConnection(int[][] edges) {
        int n = edges.length;
        parent = new int[n];
        weight = new int[n];
        for(int i = 0; i < n; i++){
            parent[i] = i;
            weight[i] = 1;
        }
        for(int i = 0; i < n; i++){
            if(isConnect(edges[i][0] - 1, edges[i][1] - 1)){
                return edges[i];
            }
            union(edges[i][0] - 1, edges[i][1] - 1);
        }
        return null;
    }
    private void union(int i, int j){
        int iParent = getParent(i);
        int jParent = getParent(j);
        //带权重的并查集，小树连到大树上，这样平均树高最小
        if(weight[iParent] < weight[jParent]){
            weight[jParent] += weight[iParent];
            parent[iParent] = jParent;
        }else{
            weight[iParent] += weight[jParent];
            parent[jParent] = iParent;
        }
    }
    private boolean isConnect(int i, int j){
        return getParent(i) == getParent(j);
    }
    private int getParent(int i){
        while(parent[i] != i){
            i = parent[i]; 
        }
        return i;
    }
    
}
```

# 10.24

## 638

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/638.png)

这个题，一眼看上去确实没什么思路，真的没有想到居然能DFS

题解的方式和昨天329差不多，就是引入了缓存后进行DFS

首先，输入中可能存在礼包的价格大于单买的价格（那还买什么礼包），对于这种礼包直接滤掉就好

然后，最费钱的方式就是每一个都单买，把这个计算出来

再然后，尝试买礼包，注意题目中要求购买的数目不能超过needs的范围，就算那样会让价格更低也不行

这样的话，就只能尝试买那些不超过范围的礼包了

尝试购买礼包后，会得到新的needs，就是当前needs中的数量减去礼包中的数量

然后对新的needs进行递归，至于递归结束的标志：显然是剩下的needs买不了礼包的时候

```java
class Solution {
    //除了needs会有不同，剩下的都是共享的数据
    private HashMap<List<Integer>, Integer> buffer;
    private List<Integer> price;
    private List<List<Integer>> filterSpecial;
    private int length;
    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {
        this.filterSpecial = new ArrayList<>();
        this.buffer = new HashMap<>();
        this.price = price;
        this.length = price.size();
        //筛选礼包的过程，除掉那些不合格的礼包
        for(List<Integer> list : special){
            int total = 0;
            int i = 0;
            for(; i < length; i++){
                total += price.get(i) * list.get(i);
            }
            if(total > list.get(i)){
                filterSpecial.add(list);
            }
        }
        return dfs(needs);
    }
    private int dfs(List<Integer> needs){
        //计算最费钱的购买方式
        if(buffer.get(needs) == null){
            int total = 0;
            for(int i = 0; i < length; i++){
                total += price.get(i) * needs.get(i);
            }
            buffer.put(needs, total);
        }
        int min = buffer.get(needs);
        //遍历礼包，看看那个能买
        for(List<Integer> list : filterSpecial){
            boolean flag = true;
            for(int i = 0; i < length; i++){
                if(list.get(i) > needs.get(i)){
                    flag = false;
                }
            }
            //如果能买，那就递归
            if(flag){
                List<Integer> newNeeds = new ArrayList<>();
                int i = 0;
                for(; i < length; i++){
                    int gap = needs.get(i) - list.get(i);
                    if(gap > 0){
                        newNeeds.add(gap);
                    }else{
                        //注意这里，如果needs中的某一项变为0了也需要加进新的needs中
                        newNeeds.add(0);
                    }
                }
                min = Math.min(min, list.get(i) + dfs(newNeeds));
            }
        }
        buffer.put(needs, min);
        return min;
    }
}
```

## 310

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/310.png)

这个题，很玄

首先，题解说如果有多解，那么最多为2个，因为他说，图给定了，就有一个最长路径，在这条最长路径上，找到路径的中点，就是需要求得的根节点，如果路径长度为奇数，那么最小高度树的根节点就只有一个，如果长度为偶数，那么最小高度树的根节点有2个

> 感觉很有道理的样子，那如果最长路径有多条怎么办呢

然后这个题解说，要找最小高度树的根，这个根的入度应该越大越好

> 自己画图看上去是这样，但总感觉证明不了

所以他的策略是，将那些入度为1的删去，多次迭代，最终当队列中（因为用的时BFS）节点的个数和未遍历的节点个数相同时，返回队列中的元素

```java
class Solution {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        List<List<Integer>> edge = new ArrayList<>();
        int[] indegree = new int[n];
        for(int i = 0; i < n; i++){
            edge.add(new ArrayList<>());
        }
        //生成邻接表并统计入度
        for(int i = 0; i < edges.length; i++){
            edge.get(edges[i][1]).add(edges[i][0]);
            indegree[edges[i][0]]++;
            edge.get(edges[i][0]).add(edges[i][1]);
            indegree[edges[i][1]]++;
        }
        Deque<Integer> deque = new LinkedList<>();
        //入度为1的入队
        for(int i = 0; i < n; i++){
            if(indegree[i] <= 1){
                deque.offerLast(i);
            }
        }
        int count = n;
        boolean flag = false;
        List<Integer> rst = new ArrayList<>();
        //多次迭代，直到队列中剩下元素的个数和未遍历的元素个数相同时，返回队列中的元素
        while(!deque.isEmpty()){
            int size = deque.size();
            flag = count == size;
            for(int i = 0; i < size; i++){
                int tmp = deque.pollFirst();
                count--;
                indegree[tmp]--;
                if(flag){
                    rst.add(tmp);
                }else{
                    for(int num : edge.get(tmp)){
                        indegree[num]--;
                        if(indegree[num] == 1){
                            deque.offerLast(num);
                        }
                    }
                }
            }
        }
        return rst;
    }
}
```

# 10.28

## 869

> 每日一题

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/869.png)

这个题，一眼看上去就是回溯

```java
class Solution {
    private int[] count;
    private int i;
    public boolean reorderedPowerOf2(int n) {
        this.count = new int[10];
        this.i = 0;
        while(n > 0){
            count[n % 10]++;
            i++;
            n /= 10;
        }
        return dfs(0, 0);
    }
    private boolean dfs(int num, int total){
        if(num == i){
            boolean rst = false;
            while(total > 0){
                if((total & 1) == 1){
                    if(rst){
                        return false;
                    }
                    rst = true;
                }
                total >>= 1;
            }
            return rst;
        }
        int i = 0;
        if(num == 0){
            i++;
        }
        for(; i <= 9; i++){
            if(count[i] > 0){
                int tmp = total * 10;
                tmp += i;
                count[i]--;
                if(dfs(num + 1, tmp)){
                    return true;
                }
                count[i]++;
            }
        }
        return false;
    }
}
```

另一个方法是统计字符出现的频率

首先因为输入的大小$0\leq N \leq 10^9$，可以计算处在这个范围内2的幂次一共有30个

> 都有一个明显的特征，就是二进制表示中只有一位是1

统计输入的频率，和对应长度的2的幂次表示的字符的频率，比较二者是否相等

## 322

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/322.png)

因为每一个硬币的数量是无限的，所有可以认为是完全背包dp

```java
class Solution {
    private final int INF = 0x3f3f3f3f;
    public int coinChange(int[] coins, int amount) {
        int len = coins.length;
        int[][] dp = new int[len][amount + 1];
        for(int j = 0; j <= amount; j++){
            if(j % coins[0] == 0){
                dp[0][j] = j / coins[0];
            }else{
                dp[0][j] = INF;
            }
        }
        for(int i = 1; i < len; i++){
            for(int j = 0; j <= amount; j++){
                dp[i][j] = dp[i - 1][j];
                for(int k = 1; k * coins[i] <= j; k++){
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - k * coins[i]] + k);
                }
            }
        }
        if(dp[len - 1][amount] == INF){
            return -1;
        }
        return dp[len - 1][amount];
    }
}
```

优化降维

```java
class Solution {
    private final int INF = 0x3f3f3f3f;
    public int coinChange(int[] coins, int amount) {
        int len = coins.length;
        int[] dp = new int[amount + 1];
        for(int j = 0; j <= amount; j++){
            if(j % coins[0] == 0){
                dp[j] = j / coins[0];
            }else{
                dp[j] = INF;
            }
        }
        for(int i = 1; i < len; i++){
            for(int j = 0; j <= amount; j++){
                if(j >= coins[i]){
                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
                }
            }
        }
        if(dp[amount] == INF){
            return -1;
        }
        return dp[amount];
    }
}
```

## 518

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/518.png)

统计的是可以组成amount对应的方案个数，这个题本质上和上面没有什么区别

```java
class Solution {
    public int change(int amount, int[] coins) {
        int len = coins.length;
        int[][] dp = new int[len + 1][amount + 1];
        dp[0][0] = 1;
        for(int i = 1; i <= len; i++){
            for(int j = 0; j <= amount; j++){
                dp[i][j] += dp[i - 1][j];
                for(int k = 1; k * coins[i - 1] <= j; k++){
                    dp[i][j] += dp[i - 1][j - k * coins[i - 1]];
                }
            }
        }
        return dp[len][amount];
    }
}
```

降维

```java
class Solution {
    public int change(int amount, int[] coins) {
        int len = coins.length;
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for(int i = 1; i <= len; i++){
            int tmp = coins[i - 1];
            for(int j = 0; j <= amount; j++){
                if(j >= tmp){
                    dp[j] += dp[j - tmp];
                }
            }
        }
        return dp[amount];
    }
}
```

因为这个题，我的初始条件`dp[0][j]`变为了，当加入coins中的第0个元素（不加元素）的时候，且价值恰为`j`时的组合个数

和前面不一样，前面时coins中加入第一个元素时...，对应的，我写了如果`dp[0][j]`表示为当加入coins中的第1个元素（不加元素）的时候，且价值恰为`j`时的组合个数的程序，看起来长得差不多，其实就是没什么区别

本来应该就是一样的，之所以分开应该时为了方便计算初始值

> 这个好像叫哨兵

```java
class Solution {
    public int change(int amount, int[] coins) {
        int len = coins.length;
        int[] dp = new int[amount + 1];
        for(int j = 0; j <= amount; j++){
            if(j % coins[0] == 0){
                dp[j] = 1;
            }
        }
        for(int i = 1; i < len; i++){
            for(int j = 0; j <= amount; j++){
                if(j >= coins[i]){
                    dp[j] += dp[j - coins[i]];
                }
            }
        }
        return dp[amount];
    }
}
```

## 474

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/474.png)

这个题，要求求出当子集中最多具有m个0，n个1的时候，最大子集的大小

> 真的没看出是背包问题，我看有的帖子说，背包问题就是组合优化问题

反正就变成了一个0/1背包问题

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int len = strs.length;
        //统计strs中每一个元素0和1的个数
        int[] z = new int[len];
        int[] o = new int[len];
        for(int i = 0; i < len; i++){
            String tmp = strs[i];
            for(int j = 0; j < tmp.length(); j++){
                if(tmp.charAt(j) == '0'){
                    z[i]++;
                }else{
                    o[i]++;
                }
            }
        }
        //dp[i][j][k]表示，当包含数组中第i+1个元素时，且0的个数不超过j，1的个数不超过k的子集的最长长度
        int[][][] dp = new int[len][m + 1][n + 1];
        //初始化，当包含数组中第一个元素时集合的长度要么为0要么为1
        for(int j = z[0]; j <= m; j++){
            for(int k = o[0]; k <= n; k++){
                dp[0][j][k] = 1;
            }
        }
        for(int i = 1; i < len; i++){
            for(int j = m; j >= 0; j--){
                for(int k = n; k >= 0; k--){
                    dp[i][j][k] = dp[i - 1][j][k];
                    if(j >= z[i] && k >= o[i]){
                        dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j - z[i]][k - o[i]] + 1);
                    }
                }
            }
        }
        return dp[len - 1][m][n];
    }
}
```

状态转移方程`dp[i][j][k] = Math.max(dp[i - 1][j][k], dp[i - 1][j - z[i]][k - o[i]])`

> 要达到后面的条件，需要同时满足：$j \geq z[i],k\geq o[i]$

降维：

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int len = strs.length;
        int[] z = new int[len];
        int[] o = new int[len];
        for(int i = 0; i < len; i++){
            String tmp = strs[i];
            for(int j = 0; j < tmp.length(); j++){
                if(tmp.charAt(j) == '0'){
                    z[i]++;
                }else{
                    o[i]++;
                }
            }
        }
        int[][] dp = new int[m + 1][n + 1];
        for(int j = z[0]; j <= m; j++){
            for(int k = o[0]; k <= n; k++){
                dp[0][j][k] = 1;
            }
        }
        for(int i = 1; i < len; i++){
            for(int j = m; j >= 0; j--){
                for(int k = n; k >= 0; k--){
                    if(j >= z[i] && k >= o[i]){
                        dp[j][k] = Math.max(dp[j][k], dp[j - z[i]][k - o[i]] + 1);
                    }
                }
            }
        }
        return dp[m][n];
    }
}
```

## 879

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/879.png)

其实有了上面的铺垫，这个应该就能好看出来了

也是一个三维的dp，`dp[i][j][k]`，表示在考虑了第i项工作后，人数不超过j，利润不小于k的方案的个数

初始化时，显然`dp[0][x][0] = 1`

状态住转移方程：`dp[i][j][k] = dp[i - 1][j][k] + dp[i - 1][j - group[i - 1]][k - profit[i - 1]]`

> 要注意的是，考虑数组下标是否越界
>
> 故如果要考虑第i项工作，需要人数至少为该项工作的人数，即必须有$j\geq group[i - 1]$
>
> 而对于利润，如果$k \leq profit[i - 1]$，意味着该项工作的利润已经大于特定的k值了，此时，认为未进行这项工作时利润为0即可

```java
class Solution {
    private final int mod = 1000000007;
    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
        int nums = group.length;
        int[][][] dp = new int[nums + 1][n + 1][minProfit + 1];
        for(int j = 0; j <= n; j++){
            dp[0][j][0] = 1;
        }
        for(int i = 1; i <= nums; i++){
            for(int j = 0; j <= n; j++){
                for(int k = 0; k <= minProfit; k++){
                    dp[i][j][k] += dp[i - 1][j][k];
                    //下面这个很关键
                    if(j >= group[i - 1]){
                        dp[i][j][k] += dp[i - 1][j - group[i - 1]][Math.max(0, k - profit[i - 1])];
                        dp[i][j][k] %= mod;
                    }
                }
            }
        }
        return dp[nums][n][minProfit];
    }
}

```

降维优化：

```java
class Solution {
    private final int mod = 1000000007;
    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
        int nums = group.length;
        int[][][] dp = new int[2][n + 1][minProfit + 1];
        for(int j = 0; j <= n; j++){
            dp[0][j][0] = 1;
        }
        for(int i = 1; i <= nums; i++){
            for(int j = 0; j <= n; j++){
                for(int k = 0; k <= minProfit; k++){
                    dp[i & 1][j][k] = dp[(i - 1) & 1][j][k];
                    if(j >= group[i - 1]){
                        dp[i & 1][j][k] += dp[(i - 1) & 1][j - group[i - 1]][Math.max(0, k - profit[i - 1])];
                        dp[i & 1][j][k] %= mod;
                    }
                }
            }
        }
        return dp[nums & 1][n][minProfit];
    }
}
```

## 494

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/494.png)

一眼看过去，感觉像是DFS

```java
class Solution {
    private int rst;
    private int[] nums;
    private int target;
    private int len;
    public int findTargetSumWays(int[] nums, int target) {
        this.rst = 0;
        this.nums = nums;
        this.target = target;
        this.len = nums.length;
        dfs(0, 0);
        return rst;
    }
    private void dfs(int i, int total){
        if(i == len){
            if(total == target){
                rst++;
            }
            return;
        }
        total += nums[i];
        dfs(i + 1, total);
        total -= 2 * nums[i];
        dfs(i + 1, total);
        total += nums[i];
    }
}
```

确实费时间

也可使使用背包dp的想法：`dp[i][j]`表示，选择第i个数后，组合恰为j的方案个数

显然状态转移方程：`dp[i][j] = dp[i - 1][j - nums[i]] + dp[i - 1][j + nums[i]]`

因为target可正可负，考虑到最大和最小的情况，计算sum，令数组的第二个维度大小为2sum+1，这样j为0的时候，表示组合为-sum，j为sum的时候表示组合为0

对于初始状态，显然有：`dp[0][sum] = 1`

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int len = nums.length;
        int sum = 0;
        for(int i = 0; i < len; i++){
            sum += Math.abs(nums[i]);
        }
        if(target > sum || target < -sum){
            return 0;
        }
        int[][] dp = new int[len + 1][2 * sum + 1];
        dp[0][0 + sum] = 1;
        for(int i = 1; i <= len; i++){
            for(int j = 0; j <= 2 * sum; j++){
                int tmp = nums[i - 1];
                if(j >= tmp){
                    dp[i][j] += dp[i - 1][j - tmp];
                }	
                if(j + tmp <= 2 * sum){
                    dp[i][j] += dp[i - 1][j + tmp];
                }
            }
        }
        return dp[len][target + sum];
    }
}
```

然而这还不算

对于一个特定的target，显然是由nums中很多负的项和很多正的项组成的

即target = 负数部分 + 正数部分（这里负数部分和正数部分都可以是0）

如果对于负数部分，考虑其绝对值为m，对于nums中所有数均取正数的时候和为sum

那么一定有负数部分为：-m，正数部分为sum - m

一定有$target = -m + (sum - m)$

求解出$m = \frac{sum - target}{2}$

不要忘了m表示的是负数部分的绝对值，如果能把m求出来，那么剩下的部分一定取正号，对应组合后一定为target

这样原来的问题：在nums中选择正负号，使其组合为targer，变为了在nums中选择正号，使其组合为m

就变成了典型的0/1背包问题

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int len = nums.length;
        int sum = 0;
        for(int i = 0; i < len; i++){
            sum += Math.abs(nums[i]);
        }
        //因为nums中均为正整数，如果m带着小数点，意味着m不可求，也就是target不可求
        if(target > sum || target < -sum || (sum - target) % 2 != 0){
            return 0;
        }
        int m  = (sum - target) / 2;
        int[][] dp = new int[len + 1][m + 1];
        dp[0][0] = 1;
        for(int i = 1; i <= len; i++){
            for(int j = 0; j <= m; j++){
                int tmp = nums[i - 1];
                dp[i][j] += dp[i - 1][j];
                if(j >= tmp){
                    dp[i][j] += dp[i - 1][j - tmp];
                }
            }
        }
        return dp[len][m];
    }
}
```

降维优化：

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int len = nums.length;
        int sum = 0;
        for(int i = 0; i < len; i++){
            sum += Math.abs(nums[i]);
        }
        if(target > sum || target < -sum || (sum - target) % 2 != 0){
            return 0;
        }
        int m  = (sum - target) / 2;
        int[] dp = new int[m + 1];
        dp[0] = 1;
        for(int i = 1; i <= len; i++){
            for(int j = m; j >= 0; j--){
                int tmp = nums[i - 1];
                if(j >= tmp){
                    dp[j] += dp[j - tmp];
                }
            }
        }
        return dp[m];
    }
}
```

## 983

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/983.png)

这题确实一看上去就没什么思路

结果是一个从后向前的dp，`dp[i]`表示从第i天到最后一天的开销

```java
class Solution {
    public int mincostTickets(int[] days, int[] costs) {
        int[] dp = new int[days[days.length - 1] + 30 + 1];
        int per = days.length - 1;
        for(int i = days[per]; i >= days[0]; i--){
            //如果今日是旅行的日子，就找一个最小的
            if(i == days[per]){
                dp[i] = Math.min(dp[i + 1] + costs[0], dp[i + 7] + costs[1]);
                dp[i] = Math.min(dp[i], dp[i + 30] + costs[2]);
                per--;
            //如果今日不是旅行的日子，那么今天的开销和明天相同
            }else{
                dp[i] = dp[i + 1];
            }
        }
        return dp[days[0]];
    }
}
```

# 10.29

## 335

> 每日一题

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/335.png)

这个题，最开始被骗了，我以为distance大小固定为4呢，我还想呢，这不是困难题吗

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/335_%E8%8C%83%E5%9B%B4.png)

这个题需要考虑当：

* 第i条边和第i - 3条边是否相交
* 第i条边和第i - 4条边是否相交
* 第i条边和第i - 5条边是否相交

再更多的边，考虑第i条边和第i - 6条边的情况，此时如果画图会看见，此时可以看成第i条边和第i - 5条边相交的情况

如果更多的边，可以考虑一个螺旋线的情况，一定不可能有第i条边和第i - 7条边相交的时候而不和其他边相交的情况

* 第i条边和第i - 3条边是否相交：这个最好想，一画图就能看出来：需要满足`distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]`

* 第i条边和第i - 4条边是否相交：满足这个条件需要恰好能对应上，因为第i条边和第i - 4条边的方向是一样的，如果相交一定有`distance[i - 1] == distance[i - 3]`，同时还需要`distance[i] + distance[i - 4] >= distance[i - 2]`

* 第i条边和第i - 5条边是否相交：这个最麻烦

```java
class Solution {
    public boolean isSelfCrossing(int[] distance) {
        int len = distance.length;
        if(len >= 4){
            for(int i = 3; i < len; i++){
                if(distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]){
                    return true;
                }
            }
            for(int i = 4; i < len; i++){
                if(distance[i] + distance[i - 4] >= distance[i - 2] && distance[i - 1] == distance[i - 3]){
                    return true;
                }
            }
            for(int i = 5; i < len; i++){
                if(distance[i - 1] <= distance[i - 3] && distance[i - 1] + distance[i - 5] >= distance[i - 3]  && distance[i] + distance[i - 4] >= distance[i - 2] && distance[i - 4] <= distance[i - 2]){
                    return true;
                }
            }
        }
        return false;
    }
}
```

## 416

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/416.png)

如果将集合中所有元素都加起来，这个题等价位，是否存在子集，其元素和为集合的一半，这是一个0/1背包问题

`dp[i][j]`定义为考虑数组前i个元素时，是否有其和为j的子集

显然初始化的时候`dp[0][0] = ture`，即如果不考虑集合中的元素，那么显然和为0

状态转移方程`dp[i][j] = dp[i - 1][j] | dp[i - 1][j - nums[i - 1]]`

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = Arrays.stream(nums).boxed().reduce((a, b) -> a + b).get();
        int target = sum / 2;
        //如果求和sum为一个奇数，那么必然不可能分成这样两个子集
        if(target * 2 < sum){
            return false;
        }
        int len = nums.length;
        boolean[][] dp = new boolean[len + 1][target + 1];
        dp[0][0] = true;
        for(int i = 1; i <= len; i++){
            for(int j = 0; j <= target; j++){
                dp[i][j] = dp[i - 1][j];
                if(j >= nums[i - 1]){
                    dp[i][j] |= dp[i - 1][j - nums[i - 1]];
                }
            }
        }
        return dp[len][target];
    }
}
```

降维优化：

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = Arrays.stream(nums).boxed().reduce((a, b) -> a + b).get();
        int target = sum / 2;
        if(target * 2 < sum){
            return false;
        }
        int len = nums.length;
        boolean[] dp = new boolean[target + 1];
        dp[0] = true;
        //0/1背包问题降维，需要从后向前遍历
        for(int i = 1; i <= len; i++){
            for(int j = target; j >= 0; j--){
                if(j >= nums[i - 1]){
                    dp[j] |= dp[j - nums[i - 1]];
                }
            }
        }
        return dp[target];
    }
}
```

## 279

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/279.png)

也就是求凑成某一个数的最小数量，一个背包问题，且为完全背包问题

其中物品的value需要自己去找，要求是value的平方小于n

`dp[i][j]`为考虑了数组中第i个元素时，和恰好为j的最小数量

显然`dp[0][j]`，当j可以整除第一个元素的时候，有合法取值，剩下的都是INF

```java
class Solution {
    //因为存在不能凑成j的情况，因为要找的时最小数量，此时给一个很大的值即可
    private final int INF = 0x3f3f3f3f;
    public int numSquares(int n) {
        List<Integer> list = new ArrayList<>();
        //自己构建一个value集合
        for(int i = 1; i * i <= n; i++){
            list.add(i * i);
        }
        int len = list.size();
        int[][] dp = new int[len][n + 1];
        //因为时完全背包问题，所以当考虑数组中第一个元素的时候，可以放多个
        for(int j = 0; j <= n; j++){
            if(j % list.get(0) == 0){
                dp[0][j] = j / list.get(0);
            }else{
                //仅考虑第一个元素，因为凑不成j，就让他取INF
                dp[0][j] = INF;
            }
        }
        for(int i = 1; i < len; i++){
            for(int j = 0; j <= n; j++){
                dp[i][j] = dp[i - 1][j];
                for(int k = 1; k * list.get(i) <= j; k++){
                    //这里这个判断可以注释掉，因为INF很大，就算某些值时非法的，在取min的时候也会忽略它
                    if(dp[i - 1][j - k * list.get(i)] != INF){
                        dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - k * list.get(i)] + k);
                    }
                }
            }
        }
        return dp[len - 1][n];
    }
}
```

> 基本上算是卡着时间线过的

降维优化：

```java
class Solution {
    private final int INF = 0x3f3f3f3f;
    public int numSquares(int n) {
        List<Integer> list = new ArrayList<>();
        for(int i = 1; i * i <= n; i++){
            list.add(i * i);
        }
        int len = list.size();
        int[] dp = new int[n + 1];
        for(int j = 0; j <= n; j++){
            if(j % list.get(0) == 0){
                dp[j] = j / list.get(0);
            }else{
                dp[j] = INF;
            }
        }
        for(int i = 1; i < len; i++){
            //完全背包问题从前向后遍历
            for(int j = list.get(i); j <= n; j++){
                //同样的这里的判断也可以注释掉
                if(dp[j - list.get(i)] != INF){
                    dp[j] = Math.min(dp[j], dp[j - list.get(i)] + 1);
                }
            }
        }
        return dp[n];
    }
}
```

## 1049

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1049.png)

这个题，等价为，将石头集合划分为两个子集，并且让子集中石头的总重尽可能接近总重的一半

`dp[i][j]`表示为在考虑第i块石头时，总重不超过j的最大重量

显然`dp[0][j]`，当j大于stones[0]的时候，取值均为stones[0]

状态转移方程`dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i] `

> 即不考虑当前的这块石头以及考虑当前石头这两者取最大值

```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = Arrays.stream(stones).boxed().reduce((a, b) -> a + b).get();
        //让target的取值尽可能小，这样最后返回的时候可以直接做差
        int target = sum / 2;
        int len = stones.length;
        int[][] dp = new int[len][target + 1];
        for(int j = stones[0]; j <= target; j++){
            dp[0][j] = stones[0];
        }
        for(int i = 1; i < len; i++){
            for(int j = 0; j <= target; j++){
                dp[i][j] = dp[i - 1][j];
                if(j >= stones[i]){
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - stones[i]] + stones[i]);
                }
            }
        }
        //相当于在全集中，让另外的一个集合减去刚求出来的集合
        return sum - 2 * dp[len - 1][target];
    }
}
```

降维优化：

```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = Arrays.stream(stones).boxed().reduce((a, b) -> a + b).get();
        int target = sum / 2;
        int len = stones.length;
        int[] dp = new int[target + 1];
        for(int j = stones[0]; j <= target; j++){
            dp[j] = stones[0];
        }
        for(int i = 1; i < len; i++){
            //0/1背包改变遍历顺序
            for(int j = target; j >= 0; j--){
                if(j >= stones[i]){
                    dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
                }
            }
        }
        return sum - 2 * dp[target];
    }
}
```

## 1155

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1155.png)

考虑`dp[i][j]`为在包括了第i个骰子后，所有骰子总和为j的方案个数

显然`dp[0][j] = 1`，当且仅当$1\leq j\leq f$，即当仅考虑第一个骰子的时候，此时点数为1-f的方案有一种

状态转移方程：`dp[i][j] = dp[i - 1][j - 1] + ... + dp[i - 1][j - f]`

> 轮到第i个骰子，那么第i个骰子的取值可以为1-f

```java
class Solution {
    private final int mod = 1000000007;
    public int numRollsToTarget(int d, int f, int target) {
        int[][] dp = new int[d][target + 1];
        //因为可能出现target小于f的情况，此时需要注意
        for(int k = 1; k <= f && k <= target; k++){
            dp[0][k] = 1;
        }
        for(int i = 1; i < d; i++){
            for(int j = 1; j <= target; j++){
                for(int k = 1; k <= f && k <= j; k++){
                    dp[i][j] += dp[i - 1][j - k];
                    dp[i][j] %= mod;
                }
            }
        }
        return dp[d - 1][target];
    }
}
```

降维优化：

```java
class Solution {
    private final int mod = 1000000007;
    public int numRollsToTarget(int d, int f, int target) {
        int[] dp = new int[target + 1];
        for(int k = 1; k <= f && k <= target; k++){
            dp[k] = 1;
        }
        for(int i = 1; i < d; i++){
            //因为当前状态和矩阵上一行的前多列有关，考虑从后向前遍历
            for(int j = target; j >= 1; j--){
                //这个很关键
                dp[j] = 0;
                for(int k = 1; k <= f && k <= j; k++){
                    dp[j] += dp[j - k];
                    dp[j] %= mod;
                }
            }
        }
        return dp[target];
    }
}
```

## 1449

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1449.png)

为了满足题目中尽可能大的要求，凑出target的时候，需要元素的数量尽可能多

那么此时`dp[i][j]`即为，当考虑第i个元素的时候，和为j的最大元素数量

显然`dp[0][j]`当j可以整除第一个元素的时候取合法值，剩下j的取INF，因为要找一个最大的数量，此时INF应该是一个小的值

关键在于在给出了最大的数量后，如果找到是那些元素凑成的

为了让返回值最大，需要从后向前遍历cost数组

因为对于所有选取的数，一定有：`dp[j] = dp[j - cost[i]] + 1`，此时证明i被选上了，初始时，j取target，结束时，j取0

```java
class Solution {
    private static final int INF = Integer.MIN_VALUE;
    public String largestNumber(int[] cost, int target) {
       	int len = cost.length;
        int[] dp = new int[target + 1];
        for(int j = 0; j <= target; j++){
            if(j % cost[0] == 0) {
            	dp[j] = j / cost[0];
            }else {
            	dp[j] = INF;
            }
        }
        for(int i = 1; i < len; i++){
            //完全背包，所以从前向后遍历
            for(int j = cost[i]; j <= target; j++){
         		/*
         			正常而言这里不能注释掉，因为INF是一个很小的值，如果凑不出的话，必然有dp[j],dp[j - cost[i]]均为INF
         			此时dp[j]取INF + 1
         			下面判断的时候会出错
         			如果非要注释掉，可以把下面的判断变为dp[target] < 0
         		*/
                if(dp[j - cost[i]] != INF) {
                	dp[j] = Math.max(dp[j], dp[j - cost[i]] + 1);
                }
            }
        }
        //说明凑不出
        if(dp[target] == INF){
            return "0";
        }
        
        StringBuilder sb = new StringBuilder();
        int tmp = target;
        for(int i = 8; i >= 0 && tmp > 0; i--){
            while(tmp >= cost[i] && dp[tmp - cost[i]] + 1 == dp[tmp]){
                sb.append(i + 1);
                tmp -= cost[i];
            }
        }
        return sb.toString();
    }
}
```

# 10.30

## 260

> 每日一题

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/260.png)

这个题一看上去就是用一个HashMap存下来，然后找value为1个键，加入rst就行了

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i++){
            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
        }
        int[] rst = new int[2];
        int i = 0;
        for(int num : map.keySet()){
            if(map.get(num) == 1){
                rst[i++] = num;
            }
        }
        return rst;
    }
}
```

这样的话，时间复杂度和空间复杂度都是O(n)

题目中明确了，只有两个元素的个数是1，剩下的元素都有两个

一个元素和自身的异或一定是0：`101 ^ 101 = 000`

而任何元素和0异或一定是本身`101 ^ 000 = 101` 

利用这个性质，如果将数组中所有元素全都取异或，最后的值`"sum"`一定是数组中数量为1的元素的异或值

在这个sum中，位数为1的表示两个元素在该位置取值不同，位数为0的表示两个元素在该位置取值相同

找到sum中任意一个位数为1的位，记为k

数组中所有元素在k处有0和1两种取值，基于此将数组分配，分别异或，最后得到的两个数就是代求的两个数

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        int sum = 0;
        for(int num : nums){
            sum ^= num;
        }
        int k = 0;
        while((sum & 1) == 0){
            sum >>= 1;
            k++;
        }
        int[] rst = new int[2];
        for(int num : nums){
            if(((num >> k) & 1 )== 1){
                rst[1] ^= num;
            }else{
                rst[0] ^= num;
            }
        }
        return rst;
    }
}
```

## 1448

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1448.png)

这个题一眼看上去没什么思路

实际上可以通过DFS，分别统计所有的节点，和不是好节点的节点，二者做差得到的就是好节点的数量

> 因为好节点不好直接统计个数

DFS的时候需要记录当前路径上，最大的节点，如果遍历到该节点的时候，该节点的值小于最大值，那么该节点就不是好节点，在fail属性上自增即可

```java
class Solution {
    private int total;
    private int fail;
    public int goodNodes(TreeNode root) {
        this.total = 0;
        this.fail = 0;
        //从根节点开始的时候，因为根节点是第一个节点，路径上最大值设置为Integer的最小值
        dfs(root, Integer.MIN_VALUE);
        return total - fail;
    }
    private void dfs(TreeNode node, int pathMax){
        if(node != null){
            total++;
            if(node.val < pathMax){
                fail++;
            }else{
                //如果当前节点的值大于路径最大值更新最大值即可
                pathMax = node.val;
            }
            dfs(node.left, pathMax);
            dfs(node.right, pathMax);
        }
    }
}
```

## 931

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/931.png)

这不一看就是DP

返回的数是DP最后一行上的最小值

> 压缩了一下，就剩下两行了，但不知道为什么跑的更慢了

```java
class Solution {
    public int minFallingPathSum(int[][] matrix) {
        int row = matrix.length;
        int col = matrix[0].length;
        int[][] dp = new int[2][col];
        int min = Integer.MAX_VALUE;
        for(int j = 0; j < col; j++){
            dp[0][j] = matrix[0][j];
            //把min的取值放在这里面，防止matrix就只有一行的特殊情况，而需要特判
            min = Math.min(min, dp[0][j]);
        }
        for(int i = 1; i < row; i++){
            min = Integer.MAX_VALUE;
            for(int j = 0; j < col; j++){
                dp[i & 1][j] = dp[(i - 1) & 1][j];
                if(j > 0){
                    dp[i & 1][j] = Math.min(dp[i & 1][j], dp[(i - 1) & 1][j - 1]);
                }
                if(j < col - 1){
                    dp[i & 1][j] = Math.min(dp[i & 1][j], dp[(i - 1) & 1][j + 1]);
                }
                dp[i & 1][j] += matrix[i][j];
                min = Math.min(min, dp[i & 1][j]);
            }
        }
        return min;
    }
}
```

因为这个需要考虑上一行前一列，上一行后一列，上一行本列的数据，所以不知道怎么把状态进一步压缩

> 感觉其实也行，每次赋值的时候把上一行的状态存下来，感觉一共需要两个指针就够了

## 1289

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1289.png)

和上一个题不同的地方在于，对于某一行，不能找上一行本列的，剩下的都可以

那么实际上，我们要找的就是上一行最小的那一列就行了，这样这一行所有列都是从那一列转移过来

但又出现了一个问题，对于本行中对应上一行最小的那一列，他要转移，不能直接从上一行本列转移过来

因此，一共需要考虑，上一行最小的那一列和第二小的那一列

> 也压缩了一下数组，变为一个$2\times n$的大小的数组了

```java
class Solution {
    public int minFallingPathSum(int[][] grid) {
        int row = grid.length;
        int col = grid[0].length;
        int[][] dp = new int[2][col];
        int min = Integer.MAX_VALUE;
        for(int j = 0; j < col; j++){
            dp[0][j] = grid[0][j];
            min = Math.min(min, dp[0][j]);
        }
        for(int i = 1; i < row; i++){
            min = Integer.MAX_VALUE;
            //findmin函数返回一个数组，第一个元素为上一行最小的元素的下标，第二个元素为上一行第二小的元素的下标
            int[] rst = findmin(dp[(i - 1) & 1]);
            for(int j = 0; j < col; j++){
                if(j == rst[0]){
                    dp[i & 1][j] = dp[(i - 1) & 1][rst[1]] + grid[i][j];
                }else{
                    dp[i & 1][j] = dp[(i - 1) & 1][rst[0]] + grid[i][j];
                }
                min = Math.min(dp[i & 1][j], min);
            }
        }
        return min;
    }
    //有两个指针，一个min，一个bigger
    private int[] findmin(int[] arr){
        int[] rst = new int[2];
        /*
        	初始时min为0，bigger为1，随后根据数组大小选择是否交换bigger和min
        	要注意的时，我没有考虑当数组大小为1的情况，这是因为，如果数组大小为1，那么上一行只有一个元素
        	根据题意，此时matrix中只有一个元素
        */
        int min = 0;
        int bigger = 1;
        if(arr[min] > arr[bigger]) {
        	min = 1;
        	bigger = 0;
        }
        /*
        	指针从数组中第三个元素开始，不断后移
        	注意一定要先判断指针所指元素和bigger所指元素的大小关系
        	如果比bigger的小，就进一步判断和min的关系
        		如果比min小，就让min指向这个位置，bigger指向min原来的位置
        		否则只是改变bigger指向的位置
        */
        for(int i = 2; i < arr.length; i++){
            if(arr[i] < arr[bigger]) {
            	if(arr[i] < arr[min]){
                	bigger = min;
                    min = i;
                }else {
                	bigger = i;
                }
            }
        }
        rst[0] =  min;
        rst[1] = bigger;
        return rst;
    }
}

```

## 1575

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1575.png)

这个题一眼看上取就是DFS然后就开始了：

```java
class Solution {
    private int finish;
    private int[] locations;
    private int amount;
    private static final int mod = 1000000007;
    public int countRoutes(int[] locations, int start, int finish, int fuel) {
        this.finish = finish;
        this.locations = locations;
        dfs(start, fuel);
        return amount;
    }
    private void dfs(int p, int fuel){
        if(p == finish){
            amount++;
            amount %= mod;
        }
       	for(int i = 0; i < locations.length; i++){
            if(i != p){
                int comsume = Math.abs(locations[i] - locations[p]);
                if(comsume <= fuel){
                    dfs(i, fuel - consume);
                }
            }
        }
    }
}

```

结果显然是超时了

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1575_%E8%B6%85%E6%97%B6%E8%BE%93%E5%85%A5.png)

这输入就离谱

然后考虑记忆化搜素

```java
class Solution {
    private int finish;
    private int[] locations;
    private int[][] buffer;
    private static final int mod = 1000000007;
    public int countRoutes(int[] locations, int start, int finish, int fuel) {
        this.finish = finish;
        this.locations = locations;
        this.buffer = new int[locations.length][fuel + 1];
        //这里填-1说明buffer这个位置是无效的
        for(int i = 0; i < locations.length; i++){
            Arrays.fill(buffer[i], -1);
        }
        return dfs(start, fuel);
    }
    private int dfs(int p, int fuel){
        if(buffer[p][fuel] != -1){
            return buffer[p][fuel];
        }
        //如果当前位置为终点，那么至少有一个路径了，否则还没找到路径
        int sum = p == finish ? 1 : 0;
        //如果当前位置不能到终点的话，那么其他的路径也不用找了，因为这个题不会给车加油，油只会越跑越少，额外的路走的越多耗的油越多
        if(fuel - Math.abs(locations[p] - locations[finish]) >= 0){
            for(int i = 0; i < locations.length; i++){
                if(i != p){
                    int comsume = Math.abs(locations[i] - locations[p]);
                    if(comsume <= fuel){
                        sum += dfs(i, fuel - comsume);
                        sum %= mod;
                    }
                }
            }
        }   
        buffer[p][fuel] = sum;
        return sum;
    }
}
```

# 10.31

## 500

> 每日一题

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/500.png)

没什么说的，将每个字母分类，一共26个分成三类

然后逐个遍历字符串，只有字符串中每一个字符都属于一个类的时候才加入rst中

```java
class Solution {
    private static final String[] strings = new String[]{"qwertyuiop", "asdfghjkl","zxcvbnm"};
    private static int[] order;
    static {
        order = new int[26];
        for(int i = 0; i < strings.length; i++){
            for(int j = 0; j < strings[i].length(); j++){
                order[strings[i].charAt(j) - 'a'] = i;
            }
        }
    }
    public String[] findWords(String[] words) {
        List<String> rst = new ArrayList<>();
        for(int i = 0; i < words.length; i++){
            char[] word = words[i].toLowerCase().toCharArray();
            int p = order[word[0] - 'a'];
            boolean flag = true;
            for(int j = 1; j < word.length; j++){
                if(order[word[j] - 'a'] != p){
                    flag = false;
                    break;
                }
            }
            if(flag){
                rst.add(words[i]);
            }
        }
        return rst.toArray(new String[rst.size()]);
    }
}
```

## [576. 出界的路径数](https://leetcode-cn.com/problems/out-of-boundary-paths/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/576.png)

最开始是这么想的，就暴力dfs，如果出界了令全局变量amount++，显然不行超时

记忆化搜索，`buffer[i][j][k]`，表示当处于位置`[i][j]`的时候，做多可移动大小为k的路径数量

```java
class Solution {
    private static final int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    private static final int mod = 1000000007;
    private int[][][] buffer;
    private int m;
    private int n;
    public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        if(maxMove == 0){
            return 0;
        }
        this.buffer = new int[m][n][maxMove + 1];
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                //buffer中每一项默认填-1，表示INF
                Arrays.fill(buffer[i][j], -1);
            }
        }
        this.m = m;
        this.n = n;
        return dfs(startRow, startColumn, maxMove);
    }
    private int dfs(int startRow, int startColumn, int maxMove){
        if(buffer[startRow][startColumn][maxMove] != -1){
            return buffer[startRow][startColumn][maxMove];
        }
        
        int sum = 0;
        for(int i = 0; i < 4; i++){
            int mx = startRow + directions[i][0];
            int my = startColumn + directions[i][1];
            //如果此时出界就不搜了，直接加
            if(mx >= m || mx < 0 || my >= n || my < 0){
                sum++;
                sum %= mod;
                //判断maxMove大于1很关键，或者在dfs开头的位置特判一下也行
            }else if (maxMove > 1){
                sum += dfs(mx, my, maxMove - 1);
                sum %= mod;
            }
        }
        buffer[startRow][startColumn][maxMove] = sum;
        return sum;
    }
}
```

## [688. 骑士在棋盘上的概率](https://leetcode-cn.com/problems/knight-probability-in-chessboard/)

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/688.png)

这个题和上面的很类似

只不过这个计算的是移动后还留在棋盘上的方案个数

这个题计算概率，需要在每次迭代的时候计算

因为，对于某一个位置，一共有8种路径，如果都没有出界，那么不出界的概率就是1

如果有出界的情况，统计概率的时候，不统计就好了

```java
class Solution {
    private static final int[][] directions = {{1, -2}, {1, 2}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {-2, -1}, {-2, 1}};
    private double[][][] inBuffer;
    private int n;
    public double knightProbability(int n, int k, int row, int column) {
        if(k == 0){
            return 1;
        }
        this.n = n;
        inBuffer = new double[n][n][k + 1];
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                Arrays.fill(inBuffer[i][j], -1);
            }
        }
        return inDfs(row, column, k);
    }
    private double inDfs(int row, int column, int k){
        if(inBuffer[row][column][k] != -1){
            return inBuffer[row][column][k];
        }

        double sum = 0;
        for(int i = 0; i < 8; i++){
            int mx = row + directions[i][0];
            int my = column + directions[i][1];
            if(mx >= 0 && mx < n && my >= 0 && my < n){
                if(k > 1){
                    sum += inDfs(mx, my, k - 1);
                }else{
                    sum++;
                }
            }
        }
        
        sum /= 8;
        inBuffer[row][column][k] = sum;
        return sum;
    }
}
```

## 1301

![](https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1301.png)

一个题相当于两个题，不仅要计算最大得分，还要统计最大的得分

```java
class Solution {
    private static final int mod = 1000000007;
    private static final int INF = Integer.MIN_VALUE;
    private static final int[][] directions = {{1, 0}, {0, 1}, {1, 1}};
    public int[] pathsWithMaxScore(List<String> board) {
        int n = board.size();
        //max[i][j]表示从i，j到起点的最大得分
        int[][] max = new int[n][n];
        //amount[i][j]表示从i，j到起点最大得分的个数
        int[][] amount = new int[n][n];
        for(int i = n - 1; i >= 0; i--) {
        	for(int j = n - 1; j >= 0; j--) {
                //初始化
                if(i == n - 1 && j == n - 1) {
        			 max[n - 1][n - 1] = 0;
        			 amount[n - 1][n - 1] = 1;
        			 continue;
        		}
                //如果此时的位置上为'X'那么得分取非法值，标识作用，状态转移方程就不从这里取
        		if(board.get(i).charAt(j) == 'X'){
                    max[i][j] = INF;
                    continue;
                }
        		int m = INF;
        		int count = 0;
        		for(int k = 0; k < 3; k++) {
        			int mx = i + directions[k][0];
        			int my = j + directions[k][1];
        			if(mx < n && my < n && max[mx][my] != INF) {
        				 m = Math.max(m, max[mx][my]);
        			}
        		}
        		for(int k = 0; k < 3; k++) {
        			int mx = i + directions[k][0];
        			int my = j + directions[k][1];
        			if(mx < n && my < n && max[mx][my] != INF && max[mx][my] == m) {
        				 count += amount[mx][my];
        				 count %= mod;
        			}
        		}
                if(m == INF){
                    max[i][j] = INF;
                }else{
                    //m不为INF的时候可能到终点了，也可能还在路上
                    if(i == 0 && j == 0) {
                        max[i][j] = m;
                    }else {
                        m += board.get(i).charAt(j) - '0';
                        m %= mod;
                        max[i][j] = m;
        		    }
                }
        		amount[i][j] = count;
        	}
        }
        int[] rst = new int[2];
        rst[0] = max[0][0] == INF ? 0 : max[0][0];
        rst[1] = amount[0][0];
        return rst;
    }   
}
```

[题解](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247485565&idx=1&sn=9d307e3ef239d9ba509624736408fc3c&scene=21#wechat_redirect)

























