其实正则表达式更多的是看文档，毕竟这玩意太难记了，只要能理解就行了，真正需要使用的时候，还是查手册吧

我向来认为应该以应用为导向，为了实现同一个需求，有很多方法，选择其中综合"性价比"高的就挺好的，不仅仅从性能上考虑，还要考虑实现难度

比如对于正则表达式而言，就很难实现匹配特定长度的输入的情况，特别的，对于密码校验，如果我希望密码长度为 6-16 位，就很难通过正则表达式限制长度

而反过来，基本上所有的语言应该都具有字符串 string 类，使用 string 类自带的 length 方法，很容易实现这个校验

也许正则表达式性能会更好，但像这样简单的需求，浪费这一点点的性能，换来代码的简单易读，我觉得是合适的

总之，只要能实现功能，怎么都好了

学习正则表达式的时候，总会忘掉一些特殊元字符的意义，还是得一老看，[正则表达式 – 语法 | 菜鸟教程](https://www.runoob.com/regexp/regexp-syntax.html) 涵盖了常见的语法

此外学习的时候，还需要手动写正则表达式，并使用字符串进行匹配，如果每次都使用特定语言的环境还是挺麻烦的(学个正则表达式而已，没必要再开一个 IDE 起一个项目)，使用可视化网站 [RegExr: 学习、构建 和 测试 正则表达式 Test RegEx (regexr-cn.com)](https://regexr-cn.com/) 可以很方便的练习

如果实在不想自己造轮子了，还可以使用别人已经写好的正则表达式，[Road 2 Coding](https://r2coding.com/#/README?id=常用正则表达式示例) 中的示例涵盖了大部分使用场景，反正我是够用了

# non-capturing group

group but not capture, 通常使用 `(...)` 表示分组, 并被 capture -> meaning it is remembered and can be referenced later; 但有的时候可能是希望其被匹配, 而不是真的分组, 此时需要使用 `(?: ...)` 表示只进行分组匹配

考虑如下例子:

```python
import re

text = "abc123"

# Capturing group
pattern_capturing = re.compile(r"([a-z]+)(\d+)")
match_capturing = pattern_capturing.match(text)
if match_capturing:
    print("Capturing group results:")
    print("Group 1:", match_capturing.group(1))			# abc
    print("Group 2:", match_capturing.group(2))			# 123

# Non-capturing group
pattern_non_capturing = re.compile(r"(?:[a-z]+)(\d+)")
match_non_capturing = pattern_non_capturing.match(text)
if match_non_capturing:
    print("Non-capturing group results:")
    # Note: No group(1) because the first group is non-capturing
    print("Group 2:", match_non_capturing.group(1))		# 123

```

在后一个使用了 non-capturing 的例子中, 尽管匹配了分组, 但是没有捕获该分组

# 零宽断言

我真是服了起这个名字的人，为什么使用这么一个难懂的名字概括呢

一共有四种：(?=exp)、(?<=exp)、(?!exp)、(?<!exp)

>   单从写法上来看，可以将前两个分成一类，后两个分成一类

这里不会说具体的每种的意义，其他博客中已经说了很多了，这里主要讨论的是零宽断言的一些应用

首先零宽断言是"不消费"字符的，即从字符串中返回的结果中不包含零宽断言中表达式的部分

书上和网上大部分也就只能说到这里了，然而，这个不消费其实还具有更深层的含义

一般说：`a(?=b)` 会匹配带有后面带有 b 的 a，而有没有考虑如果表达式为 `(?=b)` 即没有前面的 a 会发生什么呢？答案是可能报错，因为这是一个错误的正则表达式(如果不信的话可以上[RegExr](https://regexr-cn.com/)上验证一下)，`(?=b)` 本身就是一个定位的作用，所以如果前面没有 a，就好像正则表达式为空一样，好像写了一个正则表达式，又好像没写；

而如果写成了 `(?=.*b).*`，由于是向前匹配，而前面的字符为空，所以这个表达式只会检查输入中是否包含了b，如果包含了，那么所有字符都会被匹配，注意正是因为零宽断言的"不消费"使得被匹配的字符也包括了 b 本身

可以这样理解，本身正则表达式首先根据 .\*b 进行定位，如果找不到定位，就直接返回，因为此时一定不匹配，而如果找到了匹配，就会在按照括号前面的项进行匹配，然后发现括号前面为空，从而零宽断言结束，进行后面的匹配，而又因为零宽断言是"不消费"的，所以匹配的起点还是字符串的开头

>   **注意 (?=b) 和 (?=.*b) 的区别**

所以`(?=.*b).*`和`.*`其实没什么区别，最大的区别在于相当于增加了限制，字符串中必须包含字符 b

现在考虑一个密码校验的场景，要求必须包含大小写、数字三种字符，密码中不可以包含空字符，密码长度必须为 6 到 16 位

那么可以将正则表达式写为：`^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?!.*\s).{6,16}$`

要注意的是 `(?!.*\s)`，相当于是匹配空格前面的位置，而因为有了 ! 那么如果匹配成功了，反而相当于是匹配失败了，这条相当于增加了限制，密码不能有空；**而这里一定不可以写成 `(?=.*\S)`，因为这个是匹配所有的非空字符的，只要出现了一次，就可以匹配，而我们希望的是所有字符都是非空，而不是只有一个字符是否空字符**

如果还是看不懂的话，可以看 [Stack Overflow 上的高赞回答](https://stackoverflow.com/questions/17105943/what-do-we-need-lookahead-lookbehind-zero-width-assertions-for?answertab=trending#tab-top)
