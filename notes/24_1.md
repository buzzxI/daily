# 1.2

## [466. 统计重复个数](https://leetcode.cn/problems/count-the-repetitions/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/problems/count-the-repetitions/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/02/20:17:13:466.png" />
	</a>
</div>



题解提到了循环节的概念, 实际进行匹配的循环节可能不是以 s2 的开头开始的, 因此实际匹配的时候, 可能以有如下结构: prefix + loop + suffix

其中 loop 为 s2 的循环节, prefix 为 s2 的某个 prefix, suffix 为不能构成循环节的部分, 具体的可以看题解

由于循环节的编码需要使用 map 映射 index 和一个 array, 比较复杂, 这里使用两种相对比较简单的方式

### 暴力

n1 为 $10^6$ 级别, s1 为 $10^2$ 级别, 因此两重循环的开销: $10^8$ 其实是可以接受的 (也算是擦边了)

简单来说就是遍历整个 S1 (没错就是由 n1 和 s1 拼接得到的 S1), 同时维护一个 s2 上的指针即可, 暴力循环

```java
class Solution {
    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {
        int len1 = s1.length();
        int len2 = s2.length();
        if (len1 * n1 < len2 * n2) return 0;
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();

        int rst = 0;
        int k = 0;
        for (int i = 0; i < n1; i++) {
            for (int j = 0; j < len1; j++) {
                if (c1[j] == c2[k]) {
                    k = (k + 1) % len2;
                    if (k == 0) rst++;
                }
            }
        }
        return rst / n2;
    }
}
```

> 真正意义上的擦边, 2.8s ...

其实是可以优化的, 定义 f[i] 表示前 i 个 s1, 可以构成的完整的 s2 的个数, 在执行上述循环的时候, 在完成内层循环后, 如果指针 k 恰好指向了 s2 的开头, 则跳出循环 (某种意义上的剪枝吧, 这里对应了在某些输入的情况下, 循环节的开头恰好是 s2 的开头的情况)

### dp?

定义 f[i] 表示从 s2 的第 i 个字符开始可以匹配一个 s1 中字符的个数, 显然 dp 数组的构建时间复杂度为: $O(s1 \times s2)$, 由于在本题中 s1 和 s2 均为 $10^2$ 级别, 因此构建 f 数组的时间复杂度为: $10^4$

然后遍历整个 n1, 同时一个指向了 s2 的指针, 查找每个 n1 可以搜索 s2 中字符的个数

```java

```java
class Solution {
    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {
        int len1 = s1.length();
        int len2 = s2.length();
        if (len1 * n1 < len2 * n2) return 0;
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();

        int[] f = new int[len2];
        for (int i = 0; i < len2; i++) {
            int k = i;
            for (int j = 0; j < len1; j++) {
                if (c1[j] == c2[k]) {
                    f[i]++;
                    k = (k + 1) % len2;
                }
            }    
        }

        int len = 0;
        int idx = 0;
        for (int i = 0; i < n1; i++) {
            len += f[idx];
            // 在当前 s1 可以匹配 f[idx] 个字符的情况下, 下一个 s1 需要从 idx + f[idx] 开始匹配
            idx = (idx + f[idx]) % len2;
        }

        return len / len2 / n2;
    }
}
```

# 1.4

## [2397. 被列覆盖的最多行数](https://leetcode.cn/problems/maximum-rows-covered-by-columns/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/04/20:00:54:2397.png" />
	</a>
</div>

从 m 列中选择 numSelect 列, 标记这几列中的 1, 求解可以覆盖的行的个数, 最开始的想法就是暴力枚举, 枚举 n 元集合的 m 元子集, 具体的, 这里使用了 Gosper's Hack algorithm, 可以在 $O(1)$ 的时间内完成子集的枚举

```cpp
void gosper_hack(int k, int n) {
    int cur = (k << 1) - 1;
    int lim = 1 << n;
    while (cur < lim) {
        // current permutation
        // printf("%d\n", cur);
        
        // next permutation
        int lowbit = cur & (-cur);
        int r = cur + lowbit;
        cur = r | (((r ^ cur) >> 2) / lowbit);
    }
}
```

由于矩阵中仅仅包含了 0 和 1, 因此可以通过 bit mask 表示每一行, 而枚举的各个子集本身也是 mask, 如果当前枚举的子集 cur 可以完整覆盖本行的 mask(mask & cur = mask), 则表示本行可以被当前枚举的子集覆盖

```java
class Solution {
    public int maximumRows(int[][] matrix, int numSelect) {
        int n = matrix.length;
        int m = matrix[0].length;
        int[] masks = new int[n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == 1) masks[i] |= (1 << j);
            }
        }
        
        int cur = (1 << numSelect) - 1;
        int lim = 1 << m;
        int rst = 0;
        while (cur < lim) {
            int tmp = 0;
            for (int i = 0; i < n; i++) {
                if ((masks[i] & cur) == masks[i]) tmp++;
            }
            
            rst = Math.max(rst, tmp);
            int lowbit = cur & (-cur);
            int r = cur + lowbit;
            cur = r | (((r ^ cur) >> 2) / lowbit);
        }
        return rst;
    }
}
```

## [2870. Minimum Number of Operations to Make Array Empty](https://leetcode.com/problems/minimum-number-of-operations-to-make-array-empty/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/minimum-number-of-operations-to-make-array-empty/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/04/20:40:16:2870.png" />
	</a>
</div>

每次删除的顺序并没有限制, 只要数组中存在多个相同的元素就可以执行删除, 因此这里直接统计每个数字出现的频率即可

特别的, 为了保证删除的次数最少, 应该尽可能的一次性去除三个数字, 但要注意, 不能无脑先三个三个的去除, 首先应该保证的是按照该顺序去除后, 不会剩余元素

这里首先枚举一下简单的情况:

*   首先考虑只出现了一次的元素, 此时没有任何方法清空, 直接返回 -1;
*   对于出现频率为 2 的元素, 直接成对去除即可
*   对于出现频率为 3 的元素, 类似的直接去除即可
*   对于出现频率为 4 的元素, 唯一的清空方式就是两个两个的清除
*   对于出现频率为 5 的元素, 唯一的清空方式是先清除 3 个再清除 2 个

...

继续向后遍历, 会发现规律, 对于各种频率, 只有三种处理方式: 

*   一次性按照 3 个元素的方式去除
*   先按照 3 个元素的方式去除, 最后仅剩 2 个元素
*   先按照 3 个元素的方式去除, 最后仅剩 4 个元素

如果将只出现一次的情况特殊处理 (直接返回 -1), 那么可以看到这里的三种情况, 恰好对应了模 3 的各个余数

```java
class Solution {
    public int minOperations(int[] nums) {
        Map<Integer, Integer> b = new HashMap<>();
        for (int num : nums) b.put(num, b.getOrDefault(num, 0) + 1);
        int rst = 0;
        for (int k : b.keySet()) {
            int v = b.get(k);
            if (v == 1) return -1;
            // i like switch expression
            rst += switch (v % 3) {
                case 0 -> v / 3;
                case 1 -> (v - 4) / 3 + 2;
                case 2 -> (v - 2) / 3 + 1;
                default -> 0;
            };
        }
        return rst;
    }
}
```

# 1.5

## [1944. 队列中可以看到的人数](https://leetcode.cn/classic/problems/number-of-visible-people-in-a-queue/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/number-of-visible-people-in-a-queue/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/05/10:10:50:1944.png" />
	</a>
</div>

对于任何一个位置的人, 其能看到所有人按照从左向右的顺序排序, 一定是升序的, 并且其看不到的人可以分为两类, 一类排在当前位置可以看到的两个人中间, 一类排在当前位置可以看到的最后一个人的后面; 但不管怎么分类, 这两类人都比所有能看到的人要矮

>   本题特意强调了每个整数都互不相同

从后向前遍历数组, 同时使用一个单调递减的单调栈维护每个位置的高度, 特别的, 当前遍历位置 i 的高度比栈顶更小时, 表示此时当前位置只能看到后一位 (i + 1) 的人; 当前遍历位置 i 的高度比栈顶更大时, 此时需要让单调栈弹栈, 每个弹栈的元素都对应了一个可以从当前位置看到的人

```java
class Solution {
    private static final int N = (int)1e5 + 10;
    private static int[] stk = new int[N];
    public int[] canSeePersonsCount(int[] h) {
        int n = h.length;
        int[] rst = new int[n];
        int sp = 0;
        for (int i = n - 1; i >= 0; i--) {
            while (sp > 0 && h[stk[sp - 1]] < h[i]) {
                sp--;
                rst[i]++;
            }
            if (sp > 0) rst[i]++;
            stk[sp++] = i;
        }
        return rst;
    }
}
```

# 1.6

## [1235. Maximum Profit in Job Scheduling](https://leetcode.com/problems/maximum-profit-in-job-scheduling/)


<div style="text-align:center;">
	<a href="https://leetcode.com/problems/maximum-profit-in-job-scheduling/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1235.png" />
	</a>
</div>

输入范围 $5 \times 10^4$, 显然两层循环肯定是不行的, 必须想办法将复杂度优化到: $O(n\log n)$

本题还是一样的, 可以通过 dp 或者记忆化搜索两种方式解决

### 记忆化搜索

定义状态 f[i] 表示所有从 i 开始的选举方案中, 收益的最大值, 要注意从 i 开始并不意味着必须选择第 i 项工作, 显然最终直接返回 dfs(0) 即可

对于第 i 项工作有选和不选两种方式:

*   如果不选, 那么当前收益的最大值为: f[i + 1]
*   如果选的话, 那么当前收益的最大值为: $profit[i] + max_{begin[j] >= end[i]}(f[j + 1])$, 即从所有开始时间大于当前工作结束时间的工作中选择一个执行, 此时暴力枚举的时间复杂度为: $O(n)$, 直接超时

因此这里枚举的时候进行优化, 将所有的工作按照开始时间进行排序, 这样在枚举到第 i 项工作的时候, 可以使用二分在 $O(\log n)$ 的时间内找到下一个不重叠的 j

```java
class Solution {
    private int[][] b;
    private int[] f;
    public int jobScheduling(int[] s, int[] e, int[] p) {
        int n = s.length;
        this.b = new int[n][3];
        this.f = new int[n];
        Arrays.fill(f, -1);
        for (int i = 0; i < n; i++) {
            b[i][0] = s[i];
            b[i][1] = e[i];
            b[i][2] = p[i];
        }
        Arrays.sort(b, (b1, b2) -> b1[0] - b2[0]);
        return dfs(0);
    }
    
    private int dfs(int idx) {
        // 记忆化搜索
        if (f[idx] != -1) return f[idx];
        if (idx == f.length - 1) {
            f[idx] = b[idx][2];
            return f[idx];
        }
        // 不选
        int jump = dfs(idx + 1);
        // 选择当前工作
        int non_jump = b[idx][2];
        int l = idx + 1;
        int r = f.length - 1;
        while (l < r) {
            int m = l + ((r - l) >> 1);
            if (b[m][0] < b[idx][1]) l = m + 1;
            else r = m;
        }
        if (b[l][0] >= b[idx][1]) non_jump += dfs(l);
        
        f[idx] = Math.max(jump, non_jump);
        return f[idx];
    }
}
```

### dp

搜索相关的都可以按照自顶向下和自底向上分为记忆化搜索和 dp, 本题也一样, 定义状态 f[i] 表示前 i 项工作的最大值, 显然返回值为: f[n - 1] (下标从 0 开始的话)

同样的对于第 i 项工作有选和不选两种操作:

*   如果不选的则有: f[i] = f[i - 1] (i > 0)
*   如果选, 有: $f[i] = profix[i] + max_{end[j] <= begin[i]}(f[j])$, 类似的, 要从所有结束时间比当前工作开始时间早的工作中选择一个, 同样为了优化搜索, 这里根据结束时间排序, 而使用二分加速搜索

```java
class Solution {
    public int jobScheduling(int[] s, int[] e, int[] p) {
        int n = s.length;
        int[][] b = new int[n][3];
        int[] f = new int[n];
        for (int i = 0; i < n; i++) {
            b[i][0] = s[i];
            b[i][1] = e[i];
            b[i][2] = p[i];
        }
        Arrays.sort(b, (b1, b2) -> b1[1] - b2[1]);
        // 第 1 项工作没有前置工作
        f[0] = b[0][2];
        for (int i = 1; i < n; i++) {
			// 不选
            f[i] = f[i - 1];
            int l = 0;
            int r = i - 1;
            while (l < r) {
                int m = l + ((r - l + 1) >> 1);
                if (b[m][1] > b[i][0]) r = m - 1;
                else l = m;
            }
            // 选
            if (b[r][1] <= b[i][0]) f[i] = Math.max(f[i], f[r] + b[i][2]);
            // 这里注意可能没有合适的前置, 此时还有一种方案就是不要前置了
            else f[i] = Math.max(f[i], b[i][2]);
        }
        return f[n - 1];
    }
}
```

# 1.9

## [2707. 字符串中的额外字符](https://leetcode.cn/classic/problems/extra-characters-in-a-string/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/extra-characters-in-a-string/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/09/21:11:32:2707.png" />
	</a>
</div>

由于是子字符串, 因此必须是连续的, 定义 f[i] 表示前 i 个字符中没有使用的字符的最少的个数

显然, 进行状态转移时, 当前字符可以直接不进行处理, 有: f[i] = f[i - 1] + 1

而如果要处理当前字符时, 需要找到前置字符位置 j, 使得 j...i 作为 s 的子字符串, 出现在 dictionary 中, 则有: f[i] = f[j - 1]

>   注意到这里是子字符串, 因此在考虑选取第 i 个字符时, 必须找到以第 i 个字符作为结尾的字符串
>
>   而如果是子序列, 则应该从 j 开始进行匹配, 这里就不需要考虑字符 i 是否作为结尾存在, 因为就算找到了一种不包含 i 的选取方式, 还是可以找到包含了 i 的替代方案

找子字符串的过程通过字典树进行优化

```java
class Solution {
    public int minExtraChar(String s, String[] dict) {
        int n = s.length();
        int[] f = new int[n];
        Trie root = new Trie();
        for (String w : dict) add(w, root);
        
        for (int i = 0; i < n; i++) {
            if (i > 0) f[i] = f[i - 1] + 1;
            else f[i] = 1;
            Trie node = root;
            for (int j = i; j >= 0; j--) {
                int idx = s.charAt(j) - 'a';
                if (node.children[idx] == null) break;
                node = node.children[idx];
                if (node.isEnd) {
                    if (j > 0) f[i] = Math.min(f[i], f[j - 1]);
                    else f[i] = 0;
                }
            }
        }
        return f[n - 1];
    }
    
    private void add(String s, Trie root) {
        Trie node = root;
        for (int i = s.length() - 1; i >= 0; i--) {
            int idx = s.charAt(i) - 'a';
            if (node.children[idx] == null) node.children[idx] = new Trie();
            node = node.children[idx];
        }
        node.isEnd = true;
    }
}

class Trie {
    Trie[] children;
    boolean isEnd;
    
    public Trie() {
        this.children = new Trie[26];
        this.isEnd = false;
    }
}
```

# 1.21

## [410. 分割数组的最大值](https://leetcode.cn/classic/problems/split-array-largest-sum/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/split-array-largest-sum/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/21/14:55:26:410.png" />
	</a>
</div>

### dp

最开始的想法是 dp, 由于输入范围 $10^3$, 所以多几层循环也没逝吧, 定义状态 f\[i][j] 表示前 i 个数字, 分为 j 个分组时, 让每个分组和的最大值最小时的最小值

对于枚举到的第 i 个数字, 其状态由其所在的分组决定, 由于要分成子数组, 因此各个数组必须连续, 因此状态 f\[i][j] 可以通过枚举第 j 个分组的起始位置决定, 具体而言对于第 j 个分组通过枚举左边界 x, 有: $f[i][j] = min_{x \leq i}(f[x - 1][j - 1] + sum(x, i))$

由于需要求解区间和, 这里提前使用前缀和数组进行预处理 (但实际中这种处理是没有必要的, 因为在枚举左边界的过程可以累加区间和)

```java
class Solution {
    private static final int INF = 0x3f3f3f3f;
    public int splitArray(int[] nums, int k) {
        int n = nums.length;
        int[][] f = new int[n + 1][k + 1];
        for (int i = 0; i <= n; i++) Arrays.fill(f[i], INF);
        int[] pre = new int[n + 1];
        for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + nums[i - 1];

        f[0][0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= k; j++) {
                for (int x = i - 1; x >= j - 1; x--) {
                    int val = pre[i] - pre[x];
                    f[i][j] = Math.min(f[i][j], Math.max(f[x][j - 1], val));
                }
            }
        }
        return f[n][k];
    }
}
```

这里三重循环, 时间复杂度: $O(n^2m)$, 大概是: $10^9$ 级别, 由于本题的输入不强, 这里暴力的三重循环也可以过

### 二分

一般而言, 最大化最小值、最小化最大值, 都可以考虑使用二分求解, 本题也不例外, 这里对结果 (返回值) 进行二分, 结果的下限为整个数组的最大值, 结果的上限为整个数组的和

```java
class Solution {
    private int[] nums;
    private int k;
    public int splitArray(int[] nums, int k) {
        this.nums = nums;
        this.k = k;
        int mx = 0;
        int s = 0;
        for (int n : nums) {
            mx = Math.max(mx, n);
            s += n;
        }
        int l = mx;
        int r = s;
        while (l < r) {
            int m = l + ((r - l) >> 1);
            if (!check(m)) l = m + 1;
            else r = m;
        }
        return l;
    }
    
    private boolean check(int mx) {
        int s = 0;
        int cnt = 1;
        for (int n : nums) {
            s += n;
            if (s > mx) {
                cnt++;
                s = n;
                if (cnt > k) return false;
            }
        }
        return true;
    }
}
```

对返回值的枚举需要使用方法 check 校验, 表示在子数组的和不超过 @param: mx 的情况下, 子数组的数量是否不超过

要注意的时, 在 mx 很大的情况下, cnt 可能远比 k 小, 这没关系, 因为根据输入参数范围: $k\leq len(nums)$ 只要上限足够大, 可能可以找到一种可行的分割数组的方式

# 1.22

## [670. 最大交换](https://leetcode.cn/problems/maximum-swap/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/problems/maximum-swap/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/670.png" />
	</a>
</div>

考虑如果各位数在原数字中按照降序排列, 则不需要进行任何交换就可以得到最大数字, 一旦某一个位置出现了升序, 则必定可以通过交换获得一个更大的数字

由于只能交换一次, 因此需要尽可能让靠后的大的数字和靠前的小的数字, 因此整体思路如下, 如果各位数字呈现非递增排列的, 则直接返回, 不需要进行交换

只要出现了一个递增的位置, 则需要进行交换

```java
class Solution {
    public int maximumSwap(int num) {
        int[] ns = new int[10];
        int e = 0;
        while (num != 0) {
            ns[e++] = num % 10;
            num /= 10;
        }
        for (int i = 0, j = e - 1; i < j; i++, j--) {
            int tmp = ns[i];
            ns[i] = ns[j];
            ns[j] = tmp;
        }
        int idx = 1;
        for (; idx < e && ns[idx] <= ns[idx - 1]; idx++);
        // 不需要进行交换
        if (idx != e) {
            // 有 ns[idx - 1] < ns[idx]
            int p = idx - 1;
            // 从 idx 开始向后搜索一个更大的数字
            for (int i = idx + 1; i < e; i++) {
                if (ns[i] >= ns[idx]) idx = i;
            }
            // 对于给定的最大值的位置, 向前搜索, 在所有小于最大值的位置中找到一个最大的数字
            for (; p >= 0 && ns[idx] > ns[p]; p--);
            p++;
            // 交换
            int tmp = ns[p];
            ns[p] = ns[idx];
            ns[idx] = tmp;
        }
        int rst = 0;
        for (int i = 0; i < e; i++) {
            rst *= 10;
            rst += ns[i];
        }
        return rst;
    }
}
```

# 1.23

## [1239. Maximum Length of a Concatenated String with Unique Characters](https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1239.png" />
	</a>
</div>

根据题目描述, s 中的每个字符只能出现一次, 这意味着子字符串中也不能出现重复的字符, 因此这里首先对 arr 进行了筛选, 排除那些本身就包含了重复字符的子字符串

由于子字符串中只包含小写字母, 因此在去重之后, 每个子字符串最多包含 26 个字符, 最终返回值不考虑字符之间的顺序关系, 因此这里进一步将每个子字符串使用 bit mask 表示

然后执行 dfs 搜索, 函数签名 dfs(int idx, int mask) 表示从 idx 开始, 当前已有的 bit mask 为 mask 的情况下, 可以得到的最长长度, 入口为 dfs(0, 0)

```java
class Solution {
    private int[] stk;
    private int e;
    public int maxLength(List<String> arr) {
        this.stk = new int[arr.size()];
        for (String s : arr) {
            int mask = 0;
            boolean flag = true;
            for (int i = 0; i < s.length(); i++) {
                int idx = s.charAt(i) - 'a';
                if (((mask >> idx) &  1) == 1) {
                    flag = false;
                    break;
                }
                mask |= (1 << idx);
            }
            if (!flag) continue;
            stk[e++] = mask;
        }
        return dfs(0, 0);
    }
    
    private int dfs(int idx, int mask) {
        if (idx == e) return 0;
        
        int rst = dfs(idx + 1, mask);
        // current mask can be append
        if ((mask & stk[idx]) == 0) rst = Math.max(rst, dfs(idx + 1, mask | stk[idx]) + bitCount(stk[idx]));
        return rst;
    }
    
    // bit count by lowbit
    private int bitCount(int x) {
        int rst = 0;
        for (; x != 0; x -= (x & -x)) rst++;
        return rst;
    }
}
```

# 1.24

## [2865. 美丽塔 I](https://leetcode.cn/classic/problems/beautiful-towers-i/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/beautiful-towers-i/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/24/10:58:02:2865.png" />
	</a>
</div>

输入范围仅 $10^3$, 可以支持 $O(n^2)$ 的时间复杂度, 因此这里就暴力枚举了, 枚举以每个位置为最高峰时的高度和, 并不断更新

```java
class Solution {
    public long maximumSumOfHeights(List<Integer> hs) {
        long rst = 0;
        for (int i = 0; i < hs.size(); i++) {
            long tmp = 0;
            int pre = hs.get(i);
            for (int j = i - 1; j >= 0; j--) {
                int cur = hs.get(j);
                if (cur <= pre) {
                    tmp += cur;
                    pre = cur;
                }
                else tmp += pre; 
            }
            pre = hs.get(i);
            for (int j = i + 1; j < hs.size(); j++) {
                int cur = hs.get(j);
                if (cur <= pre) {
                    tmp += cur;
                    pre = cur;
                } else tmp += pre;
            }
            tmp += hs.get(i);
            rst = Math.max(rst, tmp);
        }
        return rst;
    }
}
```

### 使用单调栈辅助的前后缀和计算

内层遍历的目的是计算某种特殊的 "前后缀和", 因此可以通过预处理进行优化, 特别的, 这里使用单调栈维护, 每个元素的入栈时进行前缀(后缀)的计算

维护一个单调递增的单调栈, 同时维护当前的前缀(后缀)和 sum, 当新的元素比栈顶元素更大时直接入栈, 否则需要进行弹栈

这里前缀和的维护体现在弹栈的过程中, 每个元素的弹栈都需要对当前的前缀(后缀)和 sum 进行修改

```java
class Solution {
    public long maximumSumOfHeights(List<Integer> hs) {
        int n = hs.size();
        int[] stk = new int[n];
        int e = 0;

        long[] pre = new long[n];
        long sum = 0;
        for (int i = 0; i < hs.size(); i++) {
            while (e > 0 && hs.get(i) <= hs.get(stk[e - 1])) {
                int r = stk[--e];
                int l = -1;
                if (e > 0) l = stk[e - 1];
                // 栈顶弹栈之后, 修正前缀和
                sum -= (long)(r - l) * hs.get(r);
                sum += (long)(r - l) * hs.get(i);
            }
            sum += hs.get(i);
            pre[i] = sum;
            stk[e++] = i;
        }

        e = 0;
        long[] suf = new long[n];
        sum = 0;
        for (int i = hs.size() - 1; i >= 0; i--) {
            while (e > 0 && hs.get(i) <= hs.get(stk[e - 1])) {
                int l = stk[--e];
                int r = hs.size();
                if (e > 0) r = stk[e - 1];
                sum -= (long)(r - l) * hs.get(l);
                sum += (long)(r - l) * hs.get(i);
            }
            sum += hs.get(i);
            suf[i] = sum;
            stk[e++] = i;
        }
        long rst = 0;
        for (int i = 0; i < n; i++) rst = Math.max(rst, pre[i] + suf[i] - hs.get(i));
        
        return rst;
    }
}
```

>   这个题是一个系列, 在 i 中输入只有 $10^3$ 级别的输入, 而在 ii 中输入达到了 $10^5$ 级别, 这个时候就必须使用前后缀和预处理优化了

## [1457. Pseudo-Palindromic Paths in a Binary Tree](https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/24/11:12:01:1457.png" />
	</a>
</div>
简单来说, 本题就是遍历一棵树的所有路径...

```java
class Solution {
    private int[] b;
    public int pseudoPalindromicPaths (TreeNode root) {
        this.b = new int[10];
        b[root.val]++;
        return dfs(root);
    }
    
    private int dfs(TreeNode root) {
        if (root.left == null && root.right == null) {
            int odd = 0;
            for (int i = 1; i <= 9; i++) {
                if ((b[i] & 1) == 1) odd++;
            }
            if (odd > 1) return 0;
            else return 1;
        }
        
        int rst = 0;
        if (root.left != null) {
            b[root.left.val]++;
            rst += dfs(root.left);
            b[root.left.val]--;
        }
        
        if (root.right != null) {
            b[root.right.val]++;
            rst += dfs(root.right);
            b[root.right.val]--;
        }
        return rst;
    }
}
```

