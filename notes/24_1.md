# 1.2

## [466. 统计重复个数](https://leetcode.cn/problems/count-the-repetitions/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/problems/count-the-repetitions/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/02/20:17:13:466.png" />
	</a>
</div>



题解提到了循环节的概念, 实际进行匹配的循环节可能不是以 s2 的开头开始的, 因此实际匹配的时候, 可能以有如下结构: prefix + loop + suffix

其中 loop 为 s2 的循环节, prefix 为 s2 的某个 prefix, suffix 为不能构成循环节的部分, 具体的可以看题解

由于循环节的编码需要使用 map 映射 index 和一个 array, 比较复杂, 这里使用两种相对比较简单的方式

### 暴力

n1 为 $10^6$ 级别, s1 为 $10^2$ 级别, 因此两重循环的开销: $10^8$ 其实是可以接受的 (也算是擦边了)

简单来说就是遍历整个 S1 (没错就是由 n1 和 s1 拼接得到的 S1), 同时维护一个 s2 上的指针即可, 暴力循环

```java
class Solution {
    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {
        int len1 = s1.length();
        int len2 = s2.length();
        if (len1 * n1 < len2 * n2) return 0;
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();

        int rst = 0;
        int k = 0;
        for (int i = 0; i < n1; i++) {
            for (int j = 0; j < len1; j++) {
                if (c1[j] == c2[k]) {
                    k = (k + 1) % len2;
                    if (k == 0) rst++;
                }
            }
        }
        return rst / n2;
    }
}
```

> 真正意义上的擦边, 2.8s ...

其实是可以优化的, 定义 f[i] 表示前 i 个 s1, 可以构成的完整的 s2 的个数, 在执行上述循环的时候, 在完成内层循环后, 如果指针 k 恰好指向了 s2 的开头, 则跳出循环 (某种意义上的剪枝吧, 这里对应了在某些输入的情况下, 循环节的开头恰好是 s2 的开头的情况)

### dp?

定义 f[i] 表示从 s2 的第 i 个字符开始可以匹配一个 s1 中字符的个数, 显然 dp 数组的构建时间复杂度为: $O(s1 \times s2)$, 由于在本题中 s1 和 s2 均为 $10^2$ 级别, 因此构建 f 数组的时间复杂度为: $10^4$

然后遍历整个 n1, 同时一个指向了 s2 的指针, 查找每个 n1 可以搜索 s2 中字符的个数

```java

```java
class Solution {
    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {
        int len1 = s1.length();
        int len2 = s2.length();
        if (len1 * n1 < len2 * n2) return 0;
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();

        int[] f = new int[len2];
        for (int i = 0; i < len2; i++) {
            int k = i;
            for (int j = 0; j < len1; j++) {
                if (c1[j] == c2[k]) {
                    f[i]++;
                    k = (k + 1) % len2;
                }
            }    
        }

        int len = 0;
        int idx = 0;
        for (int i = 0; i < n1; i++) {
            len += f[idx];
            // 在当前 s1 可以匹配 f[idx] 个字符的情况下, 下一个 s1 需要从 idx + f[idx] 开始匹配
            idx = (idx + f[idx]) % len2;
        }

        return len / len2 / n2;
    }
}
```

# 1.4

## [2397. 被列覆盖的最多行数](https://leetcode.cn/problems/maximum-rows-covered-by-columns/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/04/20:00:54:2397.png" />
	</a>
</div>

从 m 列中选择 numSelect 列, 标记这几列中的 1, 求解可以覆盖的行的个数, 最开始的想法就是暴力枚举, 枚举 n 元集合的 m 元子集, 具体的, 这里使用了 Gosper's Hack algorithm, 可以在 $O(1)$ 的时间内完成子集的枚举

```cpp
void gosper_hack(int k, int n) {
    int cur = (k << 1) - 1;
    int lim = 1 << n;
    while (cur < lim) {
        // current permutation
        // printf("%d\n", cur);
        
        // next permutation
        int lowbit = cur & (-cur);
        int r = cur + lowbit;
        cur = r | (((r ^ cur) >> 2) / lowbit);
    }
}
```

由于矩阵中仅仅包含了 0 和 1, 因此可以通过 bit mask 表示每一行, 而枚举的各个子集本身也是 mask, 如果当前枚举的子集 cur 可以完整覆盖本行的 mask(mask & cur = mask), 则表示本行可以被当前枚举的子集覆盖

```java
class Solution {
    public int maximumRows(int[][] matrix, int numSelect) {
        int n = matrix.length;
        int m = matrix[0].length;
        int[] masks = new int[n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == 1) masks[i] |= (1 << j);
            }
        }
        
        int cur = (1 << numSelect) - 1;
        int lim = 1 << m;
        int rst = 0;
        while (cur < lim) {
            int tmp = 0;
            for (int i = 0; i < n; i++) {
                if ((masks[i] & cur) == masks[i]) tmp++;
            }
            
            rst = Math.max(rst, tmp);
            int lowbit = cur & (-cur);
            int r = cur + lowbit;
            cur = r | (((r ^ cur) >> 2) / lowbit);
        }
        return rst;
    }
}
```

## [2870. Minimum Number of Operations to Make Array Empty](https://leetcode.com/problems/minimum-number-of-operations-to-make-array-empty/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/minimum-number-of-operations-to-make-array-empty/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/04/20:40:16:2870.png" />
	</a>
</div>

每次删除的顺序并没有限制, 只要数组中存在多个相同的元素就可以执行删除, 因此这里直接统计每个数字出现的频率即可

特别的, 为了保证删除的次数最少, 应该尽可能的一次性去除三个数字, 但要注意, 不能无脑先三个三个的去除, 首先应该保证的是按照该顺序去除后, 不会剩余元素

这里首先枚举一下简单的情况:

*   首先考虑只出现了一次的元素, 此时没有任何方法清空, 直接返回 -1;
*   对于出现频率为 2 的元素, 直接成对去除即可
*   对于出现频率为 3 的元素, 类似的直接去除即可
*   对于出现频率为 4 的元素, 唯一的清空方式就是两个两个的清除
*   对于出现频率为 5 的元素, 唯一的清空方式是先清除 3 个再清除 2 个

...

继续向后遍历, 会发现规律, 对于各种频率, 只有三种处理方式: 

*   一次性按照 3 个元素的方式去除
*   先按照 3 个元素的方式去除, 最后仅剩 2 个元素
*   先按照 3 个元素的方式去除, 最后仅剩 4 个元素

如果将只出现一次的情况特殊处理 (直接返回 -1), 那么可以看到这里的三种情况, 恰好对应了模 3 的各个余数

```java
class Solution {
    public int minOperations(int[] nums) {
        Map<Integer, Integer> b = new HashMap<>();
        for (int num : nums) b.put(num, b.getOrDefault(num, 0) + 1);
        int rst = 0;
        for (int k : b.keySet()) {
            int v = b.get(k);
            if (v == 1) return -1;
            // i like switch expression
            rst += switch (v % 3) {
                case 0 -> v / 3;
                case 1 -> (v - 4) / 3 + 2;
                case 2 -> (v - 2) / 3 + 1;
                default -> 0;
            };
        }
        return rst;
    }
}
```

# 1.5

## [1944. 队列中可以看到的人数](https://leetcode.cn/classic/problems/number-of-visible-people-in-a-queue/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/number-of-visible-people-in-a-queue/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/05/10:10:50:1944.png" />
	</a>
</div>

对于任何一个位置的人, 其能看到所有人按照从左向右的顺序排序, 一定是升序的, 并且其看不到的人可以分为两类, 一类排在当前位置可以看到的两个人中间, 一类排在当前位置可以看到的最后一个人的后面; 但不管怎么分类, 这两类人都比所有能看到的人要矮

>   本题特意强调了每个整数都互不相同

从后向前遍历数组, 同时使用一个单调递减的单调栈维护每个位置的高度, 特别的, 当前遍历位置 i 的高度比栈顶更小时, 表示此时当前位置只能看到后一位 (i + 1) 的人; 当前遍历位置 i 的高度比栈顶更大时, 此时需要让单调栈弹栈, 每个弹栈的元素都对应了一个可以从当前位置看到的人

```java
class Solution {
    private static final int N = (int)1e5 + 10;
    private static int[] stk = new int[N];
    public int[] canSeePersonsCount(int[] h) {
        int n = h.length;
        int[] rst = new int[n];
        int sp = 0;
        for (int i = n - 1; i >= 0; i--) {
            while (sp > 0 && h[stk[sp - 1]] < h[i]) {
                sp--;
                rst[i]++;
            }
            if (sp > 0) rst[i]++;
            stk[sp++] = i;
        }
        return rst;
    }
}
```

# 1.6

## [1235. Maximum Profit in Job Scheduling](https://leetcode.com/problems/maximum-profit-in-job-scheduling/)


<div style="text-align:center;">
	<a href="https://leetcode.com/problems/maximum-profit-in-job-scheduling/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1235.png" />
	</a>
</div>

输入范围 $5 \times 10^4$, 显然两层循环肯定是不行的, 必须想办法将复杂度优化到: $O(n\log n)$

本题还是一样的, 可以通过 dp 或者记忆化搜索两种方式解决

### 记忆化搜索

定义状态 f[i] 表示所有从 i 开始的选举方案中, 收益的最大值, 要注意从 i 开始并不意味着必须选择第 i 项工作, 显然最终直接返回 dfs(0) 即可

对于第 i 项工作有选和不选两种方式:

*   如果不选, 那么当前收益的最大值为: f[i + 1]
*   如果选的话, 那么当前收益的最大值为: $profit[i] + max_{begin[j] >= end[i]}(f[j + 1])$, 即从所有开始时间大于当前工作结束时间的工作中选择一个执行, 此时暴力枚举的时间复杂度为: $O(n)$, 直接超时

因此这里枚举的时候进行优化, 将所有的工作按照开始时间进行排序, 这样在枚举到第 i 项工作的时候, 可以使用二分在 $O(\log n)$ 的时间内找到下一个不重叠的 j

```java
class Solution {
    private int[][] b;
    private int[] f;
    public int jobScheduling(int[] s, int[] e, int[] p) {
        int n = s.length;
        this.b = new int[n][3];
        this.f = new int[n];
        Arrays.fill(f, -1);
        for (int i = 0; i < n; i++) {
            b[i][0] = s[i];
            b[i][1] = e[i];
            b[i][2] = p[i];
        }
        Arrays.sort(b, (b1, b2) -> b1[0] - b2[0]);
        return dfs(0);
    }
    
    private int dfs(int idx) {
        // 记忆化搜索
        if (f[idx] != -1) return f[idx];
        if (idx == f.length - 1) {
            f[idx] = b[idx][2];
            return f[idx];
        }
        // 不选
        int jump = dfs(idx + 1);
        // 选择当前工作
        int non_jump = b[idx][2];
        int l = idx + 1;
        int r = f.length - 1;
        while (l < r) {
            int m = l + ((r - l) >> 1);
            if (b[m][0] < b[idx][1]) l = m + 1;
            else r = m;
        }
        if (b[l][0] >= b[idx][1]) non_jump += dfs(l);
        
        f[idx] = Math.max(jump, non_jump);
        return f[idx];
    }
}
```

### dp

搜索相关的都可以按照自顶向下和自底向上分为记忆化搜索和 dp, 本题也一样, 定义状态 f[i] 表示前 i 项工作的最大值, 显然返回值为: f[n - 1] (下标从 0 开始的话)

同样的对于第 i 项工作有选和不选两种操作:

*   如果不选的则有: f[i] = f[i - 1] (i > 0)
*   如果选, 有: $f[i] = profix[i] + max_{end[j] <= begin[i]}(f[j])$, 类似的, 要从所有结束时间比当前工作开始时间早的工作中选择一个, 同样为了优化搜索, 这里根据结束时间排序, 而使用二分加速搜索

```java
class Solution {
    public int jobScheduling(int[] s, int[] e, int[] p) {
        int n = s.length;
        int[][] b = new int[n][3];
        int[] f = new int[n];
        for (int i = 0; i < n; i++) {
            b[i][0] = s[i];
            b[i][1] = e[i];
            b[i][2] = p[i];
        }
        Arrays.sort(b, (b1, b2) -> b1[1] - b2[1]);
        // 第 1 项工作没有前置工作
        f[0] = b[0][2];
        for (int i = 1; i < n; i++) {
			// 不选
            f[i] = f[i - 1];
            int l = 0;
            int r = i - 1;
            while (l < r) {
                int m = l + ((r - l + 1) >> 1);
                if (b[m][1] > b[i][0]) r = m - 1;
                else l = m;
            }
            // 选
            if (b[r][1] <= b[i][0]) f[i] = Math.max(f[i], f[r] + b[i][2]);
            // 这里注意可能没有合适的前置, 此时还有一种方案就是不要前置了
            else f[i] = Math.max(f[i], b[i][2]);
        }
        return f[n - 1];
    }
}
```

# 1.9

## [2707. 字符串中的额外字符](https://leetcode.cn/classic/problems/extra-characters-in-a-string/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/extra-characters-in-a-string/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/09/21:11:32:2707.png" />
	</a>
</div>

由于是子字符串, 因此必须是连续的, 定义 f[i] 表示前 i 个字符中没有使用的字符的最少的个数

显然, 进行状态转移时, 当前字符可以直接不进行处理, 有: f[i] = f[i - 1] + 1

而如果要处理当前字符时, 需要找到前置字符位置 j, 使得 j...i 作为 s 的子字符串, 出现在 dictionary 中, 则有: f[i] = f[j - 1]

>   注意到这里是子字符串, 因此在考虑选取第 i 个字符时, 必须找到以第 i 个字符作为结尾的字符串
>
>   而如果是子序列, 则应该从 j 开始进行匹配, 这里就不需要考虑字符 i 是否作为结尾存在, 因为就算找到了一种不包含 i 的选取方式, 还是可以找到包含了 i 的替代方案

找子字符串的过程通过字典树进行优化

```java
class Solution {
    public int minExtraChar(String s, String[] dict) {
        int n = s.length();
        int[] f = new int[n];
        Trie root = new Trie();
        for (String w : dict) add(w, root);
        
        for (int i = 0; i < n; i++) {
            if (i > 0) f[i] = f[i - 1] + 1;
            else f[i] = 1;
            Trie node = root;
            for (int j = i; j >= 0; j--) {
                int idx = s.charAt(j) - 'a';
                if (node.children[idx] == null) break;
                node = node.children[idx];
                if (node.isEnd) {
                    if (j > 0) f[i] = Math.min(f[i], f[j - 1]);
                    else f[i] = 0;
                }
            }
        }
        return f[n - 1];
    }
    
    private void add(String s, Trie root) {
        Trie node = root;
        for (int i = s.length() - 1; i >= 0; i--) {
            int idx = s.charAt(i) - 'a';
            if (node.children[idx] == null) node.children[idx] = new Trie();
            node = node.children[idx];
        }
        node.isEnd = true;
    }
}

class Trie {
    Trie[] children;
    boolean isEnd;
    
    public Trie() {
        this.children = new Trie[26];
        this.isEnd = false;
    }
}
```

# 1.21

## [410. 分割数组的最大值](https://leetcode.cn/classic/problems/split-array-largest-sum/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/split-array-largest-sum/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/21/14:55:26:410.png" />
	</a>
</div>

### dp

最开始的想法是 dp, 由于输入范围 $10^3$, 所以多几层循环也没逝吧, 定义状态 f\[i][j] 表示前 i 个数字, 分为 j 个分组时, 让每个分组和的最大值最小时的最小值

对于枚举到的第 i 个数字, 其状态由其所在的分组决定, 由于要分成子数组, 因此各个数组必须连续, 因此状态 f\[i][j] 可以通过枚举第 j 个分组的起始位置决定, 具体而言对于第 j 个分组通过枚举左边界 x, 有: $f[i][j] = min_{x \leq i}(f[x - 1][j - 1] + sum(x, i))$

由于需要求解区间和, 这里提前使用前缀和数组进行预处理 (但实际中这种处理是没有必要的, 因为在枚举左边界的过程可以累加区间和)

```java
class Solution {
    private static final int INF = 0x3f3f3f3f;
    public int splitArray(int[] nums, int k) {
        int n = nums.length;
        int[][] f = new int[n + 1][k + 1];
        for (int i = 0; i <= n; i++) Arrays.fill(f[i], INF);
        int[] pre = new int[n + 1];
        for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + nums[i - 1];

        f[0][0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= k; j++) {
                for (int x = i - 1; x >= j - 1; x--) {
                    int val = pre[i] - pre[x];
                    f[i][j] = Math.min(f[i][j], Math.max(f[x][j - 1], val));
                }
            }
        }
        return f[n][k];
    }
}
```

这里三重循环, 时间复杂度: $O(n^2m)$, 大概是: $10^9$ 级别, 由于本题的输入不强, 这里暴力的三重循环也可以过

### 二分

一般而言, 最大化最小值、最小化最大值, 都可以考虑使用二分求解, 本题也不例外, 这里对结果 (返回值) 进行二分, 结果的下限为整个数组的最大值, 结果的上限为整个数组的和

```java
class Solution {
    private int[] nums;
    private int k;
    public int splitArray(int[] nums, int k) {
        this.nums = nums;
        this.k = k;
        int mx = 0;
        int s = 0;
        for (int n : nums) {
            mx = Math.max(mx, n);
            s += n;
        }
        int l = mx;
        int r = s;
        while (l < r) {
            int m = l + ((r - l) >> 1);
            if (!check(m)) l = m + 1;
            else r = m;
        }
        return l;
    }
    
    private boolean check(int mx) {
        int s = 0;
        int cnt = 1;
        for (int n : nums) {
            s += n;
            if (s > mx) {
                cnt++;
                s = n;
                if (cnt > k) return false;
            }
        }
        return true;
    }
}
```

对返回值的枚举需要使用方法 check 校验, 表示在子数组的和不超过 @param: mx 的情况下, 子数组的数量是否不超过

要注意的时, 在 mx 很大的情况下, cnt 可能远比 k 小, 这没关系, 因为根据输入参数范围: $k\leq len(nums)$ 只要上限足够大, 可能可以找到一种可行的分割数组的方式

# 1.22

## [670. 最大交换](https://leetcode.cn/problems/maximum-swap/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/problems/maximum-swap/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/670.png" />
	</a>
</div>

考虑如果各位数在原数字中按照降序排列, 则不需要进行任何交换就可以得到最大数字, 一旦某一个位置出现了升序, 则必定可以通过交换获得一个更大的数字

由于只能交换一次, 因此需要尽可能让靠后的大的数字和靠前的小的数字, 因此整体思路如下, 如果各位数字呈现非递增排列的, 则直接返回, 不需要进行交换

只要出现了一个递增的位置, 则需要进行交换

```java
class Solution {
    public int maximumSwap(int num) {
        int[] ns = new int[10];
        int e = 0;
        while (num != 0) {
            ns[e++] = num % 10;
            num /= 10;
        }
        for (int i = 0, j = e - 1; i < j; i++, j--) {
            int tmp = ns[i];
            ns[i] = ns[j];
            ns[j] = tmp;
        }
        int idx = 1;
        for (; idx < e && ns[idx] <= ns[idx - 1]; idx++);
        // 不需要进行交换
        if (idx != e) {
            // 有 ns[idx - 1] < ns[idx]
            int p = idx - 1;
            // 从 idx 开始向后搜索一个更大的数字
            for (int i = idx + 1; i < e; i++) {
                if (ns[i] >= ns[idx]) idx = i;
            }
            // 对于给定的最大值的位置, 向前搜索, 在所有小于最大值的位置中找到一个最大的数字
            for (; p >= 0 && ns[idx] > ns[p]; p--);
            p++;
            // 交换
            int tmp = ns[p];
            ns[p] = ns[idx];
            ns[idx] = tmp;
        }
        int rst = 0;
        for (int i = 0; i < e; i++) {
            rst *= 10;
            rst += ns[i];
        }
        return rst;
    }
}
```

# 1.23

## [1239. Maximum Length of a Concatenated String with Unique Characters](https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1239.png" />
	</a>
</div>

根据题目描述, s 中的每个字符只能出现一次, 这意味着子字符串中也不能出现重复的字符, 因此这里首先对 arr 进行了筛选, 排除那些本身就包含了重复字符的子字符串

由于子字符串中只包含小写字母, 因此在去重之后, 每个子字符串最多包含 26 个字符, 最终返回值不考虑字符之间的顺序关系, 因此这里进一步将每个子字符串使用 bit mask 表示

然后执行 dfs 搜索, 函数签名 dfs(int idx, int mask) 表示从 idx 开始, 当前已有的 bit mask 为 mask 的情况下, 可以得到的最长长度, 入口为 dfs(0, 0)

```java
class Solution {
    private int[] stk;
    private int e;
    public int maxLength(List<String> arr) {
        this.stk = new int[arr.size()];
        for (String s : arr) {
            int mask = 0;
            boolean flag = true;
            for (int i = 0; i < s.length(); i++) {
                int idx = s.charAt(i) - 'a';
                if (((mask >> idx) &  1) == 1) {
                    flag = false;
                    break;
                }
                mask |= (1 << idx);
            }
            if (!flag) continue;
            stk[e++] = mask;
        }
        return dfs(0, 0);
    }
    
    private int dfs(int idx, int mask) {
        if (idx == e) return 0;
        
        int rst = dfs(idx + 1, mask);
        // current mask can be append
        if ((mask & stk[idx]) == 0) rst = Math.max(rst, dfs(idx + 1, mask | stk[idx]) + bitCount(stk[idx]));
        return rst;
    }
    
    // bit count by lowbit
    private int bitCount(int x) {
        int rst = 0;
        for (; x != 0; x -= (x & -x)) rst++;
        return rst;
    }
}
```

# 1.24

## [2865. 美丽塔 I](https://leetcode.cn/classic/problems/beautiful-towers-i/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/beautiful-towers-i/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/24/10:58:02:2865.png" />
	</a>
</div>

输入范围仅 $10^3$, 可以支持 $O(n^2)$ 的时间复杂度, 因此这里就暴力枚举了, 枚举以每个位置为最高峰时的高度和, 并不断更新

```java
class Solution {
    public long maximumSumOfHeights(List<Integer> hs) {
        long rst = 0;
        for (int i = 0; i < hs.size(); i++) {
            long tmp = 0;
            int pre = hs.get(i);
            for (int j = i - 1; j >= 0; j--) {
                int cur = hs.get(j);
                if (cur <= pre) {
                    tmp += cur;
                    pre = cur;
                }
                else tmp += pre; 
            }
            pre = hs.get(i);
            for (int j = i + 1; j < hs.size(); j++) {
                int cur = hs.get(j);
                if (cur <= pre) {
                    tmp += cur;
                    pre = cur;
                } else tmp += pre;
            }
            tmp += hs.get(i);
            rst = Math.max(rst, tmp);
        }
        return rst;
    }
}
```

### 使用单调栈辅助的前后缀和计算

内层遍历的目的是计算某种特殊的 "前后缀和", 因此可以通过预处理进行优化, 特别的, 这里使用单调栈维护, 每个元素的入栈时进行前缀(后缀)的计算

维护一个单调递增的单调栈, 同时维护当前的前缀(后缀)和 sum, 当新的元素比栈顶元素更大时直接入栈, 否则需要进行弹栈

这里前缀和的维护体现在弹栈的过程中, 每个元素的弹栈都需要对当前的前缀(后缀)和 sum 进行修改

```java
class Solution {
    public long maximumSumOfHeights(List<Integer> hs) {
        int n = hs.size();
        int[] stk = new int[n];
        int e = 0;

        long[] pre = new long[n];
        long sum = 0;
        for (int i = 0; i < hs.size(); i++) {
            while (e > 0 && hs.get(i) <= hs.get(stk[e - 1])) {
                int r = stk[--e];
                int l = -1;
                if (e > 0) l = stk[e - 1];
                // 栈顶弹栈之后, 修正前缀和
                sum -= (long)(r - l) * hs.get(r);
                sum += (long)(r - l) * hs.get(i);
            }
            sum += hs.get(i);
            pre[i] = sum;
            stk[e++] = i;
        }

        e = 0;
        long[] suf = new long[n];
        sum = 0;
        for (int i = hs.size() - 1; i >= 0; i--) {
            while (e > 0 && hs.get(i) <= hs.get(stk[e - 1])) {
                int l = stk[--e];
                int r = hs.size();
                if (e > 0) r = stk[e - 1];
                sum -= (long)(r - l) * hs.get(l);
                sum += (long)(r - l) * hs.get(i);
            }
            sum += hs.get(i);
            suf[i] = sum;
            stk[e++] = i;
        }
        long rst = 0;
        for (int i = 0; i < n; i++) rst = Math.max(rst, pre[i] + suf[i] - hs.get(i));
        
        return rst;
    }
}
```

>   这个题是一个系列, 在 i 中输入只有 $10^3$ 级别的输入, 而在 ii 中输入达到了 $10^5$ 级别, 这个时候就必须使用前后缀和预处理优化了

## [1457. Pseudo-Palindromic Paths in a Binary Tree](https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/24/11:12:01:1457.png" />
	</a>
</div>

简单来说, 本题就是遍历一棵树的所有路径...

```java
class Solution {
    private int[] b;
    public int pseudoPalindromicPaths (TreeNode root) {
        this.b = new int[10];
        b[root.val]++;
        return dfs(root);
    }
    
    private int dfs(TreeNode root) {
        if (root.left == null && root.right == null) {
            int odd = 0;
            for (int i = 1; i <= 9; i++) {
                if ((b[i] & 1) == 1) odd++;
            }
            if (odd > 1) return 0;
            else return 1;
        }
        
        int rst = 0;
        if (root.left != null) {
            b[root.left.val]++;
            rst += dfs(root.left);
            b[root.left.val]--;
        }
        
        if (root.right != null) {
            b[root.right.val]++;
            rst += dfs(root.right);
            b[root.right.val]--;
        }
        return rst;
    }
}
```

# 1.25

## [2859. 计算 K 置位下标对应元素的和](https://leetcode.cn/classic/problems/sum-of-values-at-indices-with-k-set-bits/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/sum-of-values-at-indices-with-k-set-bits/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/25/09:41:49:2859.png" />
	</a>
</div>

输入范围: $10^3$ 级别, 直接挨个位置 bit count 即可, 整体时间复杂度: $O(n\log U)$ 其中 U 为最大数字

因为题目要求二进制中存在 k 个置位, 即这里可以利用 gosper's hack 加速下标的计算, 在 $O(1)$ 的时间内求解 k 元子集, 减少枚举集合的个数

```java
class Solution {
    public int sumIndicesWithKSetBits(List<Integer> nums, int k) {
        if (k == 0) return nums.get(0);
        int rst = 0;
        int cur = (1 << k) - 1;
        while (cur < nums.size()) {
            int lbt = cur & -cur;
            int r = lbt + cur;
            rst += nums.get(cur);
            cur = r | (((r ^ cur) >> 2) / lbt);
        }
        return rst;
    }
}
```

# 1.26

## [576. 出界的路径数](https://leetcode-cn.com/problems/out-of-boundary-paths/)

<div style="text-align:center;">
	<a href="https://leetcode-cn.com/problems/out-of-boundary-paths/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/576.png" />
	</a>
</div>

因为和移动步数相关, 这里本想着用 BFS 来搜的, 每种出界情况都 + 1, 直到看到结果需要对 $10^9 + 7$ 取余, 显然结果的方案个数应该有很多种, 爆搜并不合适

本题使用记忆化搜索加速, 定义缓存 f\[i]\[j][k] 表示从点 (i, j) 出发, 最大允许移动步数为 k 时, 移除边界的方案数, 显然搜索入口: f\[startRow]\[startColumn][maxMove]

```java
class Solution {
    private static final int[][] dir = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    private static final int MOD = (int)1e9 + 7;
    private int[][][] buff;
    private int m, n;
    public int findPaths(int m, int n, int maxMove, int sr, int sc) {
        this.buff = new int[m][n][maxMove + 1];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) Arrays.fill(buff[i][j], -1);
        }
        this.m = m;
        this.n = n;
        return dfs(sr, sc, maxMove);
    }
    
    private int dfs(int x, int y, int cnt) {
        // 移出区域
        if (x < 0 || x >= m || y < 0 || y >= n) return 1;
        // 剩余可移动次数不足
        if (cnt == 0) return 0;
        
        if (buff[x][y][cnt] != -1) return buff[x][y][cnt];
        int rst = 0;
        for (int[] d : dir) {
            rst += dfs(x + d[0], y + d[1], cnt - 1);
            rst %= MOD;
        }
        buff[x][y][cnt] = rst;
        return rst;
    }
}
```

## [2846. 边权重均等查询 (Minimum Edge Weight Equilibrium Queries in a Tree)](https://leetcode.cn/classic/problems/minimum-edge-weight-equilibrium-queries-in-a-tree/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/minimum-edge-weight-equilibrium-queries-in-a-tree/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/26/20:03:50:2846.png" />
	</a>
</div>

由于是 n 个节点 n - 1 条边, 构成一个树, 因此肯定不存在环路, 因为需要考虑最小操作次数, 因此需要统计任意两个节点之间的边的频率, 保留出现频率最大的边, 剩下的所有边都应该丢弃

这样对于每个 queries[i] 其搜素的时间复杂度为: $O(n)$, 而整体上的时间复杂度为: $O(m\times n\times k)$, 看了一眼输入范围 n, m 都是 $10^4$ 级别, 而 k 却很小只有 26, 但整体时间复杂度会达到: $10^9$ 级别, 应该会超时

这里的一个想法是, 预处理路径上的边的频率, 在所有节点中随机找一个作为根节点, 预处理所有节点到根节点的边的出现频率, 定义 f\[i][j] 表示节点 i 到根节点, 其中边权为 j 的边的出现频率

对于节点 a 和 b, 其路径上的边出现的频率可以通过计算其最近公共祖先得到, 假设 c 为 a 和 b 的最近公共祖先, 显然有 w[i] = a[i] + b[i] - 2 * c[i], 其中 w[i] 表示从 a 到 b 路径上, 边权为 i 的边的出现频率

### 倍增

LCA 的经典做法, 倍增数组, 将搜索的时间优化到 $O(m\times\log n\times k)$ => 这里优化的点是, 在 $O(\log n\times k)$ 的时间内完成路径上各种边权出现频率的统计, 而之前的爆搜需要: $O(n\times k)$

```java
class Solution {
    private static final int INF = 0x3f3f3f3f;
    private int[] h;
    private int[] e;
    private int[] ne;
    private int[] w;
    private int idx;
    // 统计某个节点到根节点路径上各个边的频率
    private int[][] f;
    // lca 倍增数组
    private int[][] g;
    // 深度
    private int[] d;
    // 队列
    private int[] q;
    public int[] minOperationsQueries(int n, int[][] edges, int[][] qs) {
        this.h = new int[n];
        Arrays.fill(h, -1);
        this.e = new int[n << 1];
        this.ne = new int[n << 1];
        this.w = new int[n << 1];
        this.idx = 0;
        for (int[] edge : edges) {
            add(edge[0], edge[1], edge[2]);
            add(edge[1], edge[0], edge[2]);
        }
        this.g = new int[n][16];
        for (int i = 0; i < n; i++) Arrays.fill(g[i], -1);
        this.d = new int[n];
        this.q = new int[n];
        bfs(0);
        
        this.f = new int[n][30];
        dfs(0, -1);
        int[] rst = new int[qs.length];
        for (int i = 0; i < qs.length; i++) {
            int ca = lca(qs[i][0], qs[i][1]);
            int[] tmp = new int[30];
            for (int j = 0; j < 30; j++) tmp[j] += f[qs[i][0]][j] + f[qs[i][1]][j] - (f[ca][j] << 1);
            int mx = 0;
            int sum = 0;
            for (int j = 0; j < 30; j++) {
                sum += tmp[j];
                if (tmp[j] > mx) mx = tmp[j];
            }
            rst[i] = sum - mx;
        }
        return rst;   
    }
    
    // cal freq
    private void dfs(int n, int p) {
        for (int i = h[n]; i != -1; i = ne[i]) {
            int j = e[i];
            if (j == p) continue;
            int k = w[i];
            System.arraycopy(f[n], 0, f[j], 0, f[n].length);
            f[j][k] = f[n][k] + 1;
            dfs(j, n);
        }
    }
    
    // preprocess for lca
    private void bfs(int root) {
        Arrays.fill(d, INF);
        d[root] = 1;
        int hh = 0, tt = 0;
        q[hh] = root;
        while (hh <= tt) {
            int t = q[hh++];
            for (int i = h[t]; i != -1; i = ne[i]) {
                int j = e[i];
                if (d[j] > d[t] + 1) {
                    d[j] = d[t] + 1;
                    q[++tt] = j;
                    g[j][0] = t;
                    for (int k = 1; k < 16; k++) {
                        int p = g[j][k - 1];
                        if (p == -1) break;
                        g[j][k] = g[p][k - 1];
                    }
                }
            }
        }
    }
    
    private int lca(int a, int b) {
        for (int i = 15; i >= 0 && d[a] > d[b]; i--) {
            if (g[a][i] < 0) continue;
            if (d[g[a][i]] >= d[b]) a = g[a][i];
        }
        for (int i = 15; i >= 0 && d[b] > d[a]; i--) {
            if (g[b][i] < 0) continue;
            if (d[g[b][i]] >= d[a]) b = g[b][i];
        }
        if (a == b) return a;
        for (int i = 15; i >= 0; i--) {
            if (g[a][i] < 0) continue;
            if (g[a][i] != g[b][i]) {
                a = g[a][i];
                b = g[b][i];
            }
        }
        return g[a][0];
    }
    
    private void add(int a, int b, int c) {
        e[idx] = b;
        ne[idx] = h[a];
        w[idx] = c;
        h[a] = idx++;
    }
}
```

### tarjan

因为本题的查询均均是一次性全部给定了的, 因此可以采用 tarjan 进行离线搜索, 在 $O(m)$ 的时间内完成 $m$ 组 lca 的查询

```java
class Solution {
    private int[] h, e, ne, w;
    int idx;
    private int[] p;
    private Map<Integer, List<Integer>> m;
    private int[] rst;
    private int[][] qs;
    private int[][] f;
    private int[] vis;
    public int[] minOperationsQueries(int n, int[][] edges, int[][] qs) {
        this.h = new int[n];
        Arrays.fill(h, -1);
        this.e = new int[n << 1];
        this.ne = new int[n << 1];
        this.w = new int[n << 1];
        this.idx = 0;
        for (int[] edge : edges) {
            add(edge[0], edge[1], edge[2]);
            add(edge[1], edge[0], edge[2]);
        }
        
        this.p = new int[n];
        for (int i = 0; i < n; i++) p[i] = i;
        this.qs = qs;
        this.m = new HashMap<>(n);
        rst = new int[qs.length];
        for (int i = 0; i < qs.length; i++) {
            List<Integer> tmp = m.getOrDefault(qs[i][0], new ArrayList<>());
            tmp.add(i);
            m.put(qs[i][0], tmp);
            tmp = m.getOrDefault(qs[i][1], new ArrayList<>());
            tmp.add(i);
            m.put(qs[i][1], tmp);
        }
        this.f = new int[n][30];
        this.vis = new int[n];
        dfs(0, -1);
        return rst;
    }
    
    private void dfs(int n, int fa) {
        for (int i = h[n]; i != -1; i = ne[i]) {
            int j = e[i];
            if (j == fa) continue;
            System.arraycopy(f[n], 0, f[j], 0, f[j].length);
            f[j][w[i]]++;
            dfs(j, n);
            vis[j] = 1;
            union(j, n);
        }
        
        if (m.containsKey(n)) {
            for (int idx : m.get(n)) {
                int y = qs[idx][0];
                if (y == n) y = qs[idx][1];
                if (vis[y] == 1) {
                    int lca = find(y);
                    int[] tmp = new int[30];
                    int sum = 0;
                    int max = 0;
                    for (int i = 0; i < 30; i++) {
                        tmp[i] = f[n][i] + f[y][i] - (f[lca][i] << 1);
                        sum += tmp[i];
                        max = Math.max(max, tmp[i]);
                    }
                    rst[idx] = sum - max;
                }
            }
        }
    }
    
    private int find(int x) {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    
    private void union(int a, int b) {
        int pa = find(a);
        int pb = find(b);
        if (pa == pb) return;
        p[pa] = pb;
    }
    
    private void add(int a, int b, int c) {
        e[idx] = b;
        ne[idx] = h[a];
        w[idx] = c;
        h[a] = idx++;
    }
}
```

# 1.27

## [2861. 最大合金数 (Maximum Number of Alloys)](https://leetcode.cn/classic/problems/maximum-number-of-alloys/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/maximum-number-of-alloys/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/27/14:16:53:2861.png" />
	</a>
</div>

很难确定到底那个机器最优, 那就暴力搜索吧, 每个机器试一遍, 对结果进行二分搜索, 然后计算每个合金数量下需要的开销

```java
class Solution {
    private int b;
    private List<List<Integer>> c;
    private List<Integer> s;
    private List<Integer> cost;
    
    public int maxNumberOfAlloys(int n, int k, int b, List<List<Integer>> c, List<Integer> s, List<Integer> cost) {
        this.b = b;
        this.c = c;
        this.s = s;
        this.cost = cost;
        int l = 0, r = (int)1e9;
        while (l < r) {
            int m = l + ((r - l + 1) >> 1);
            if (!check(m)) r = m - 1;
            else l = m;
        }
        return l;
    }
    
    private boolean check(int cnt) {
        long[] tmp = new long[c.get(0).size()];
        // 暴力枚举所有的机器
        for (List<Integer> m : c) {
            long sum = 0;
            // 统计每个机器下, 为了合成 cnt 个合金需要的开销
            for (int i = 0; i < m.size() && sum <= b; i++) {
                tmp[i] = (long)m.get(i) * cnt - s.get(i);
                if (tmp[i] > 0) sum += tmp[i] * cost.get(i);
            }
            // 只要有一个机器的开销不超预算, 那么就可以得到 cnt 个合金
            if (sum <= b) return true;
        }
        return false;
    }
}
```

## [629. K个逆序对数组](https://leetcode.cn/problems/k-inverse-pairs-array/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/problems/k-inverse-pairs-array/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/629.png" />
	</a>
</div>
定义状态 f\[i][j] 表示前 i 个数字, 可以构成包含 j 个逆序对的序列种类数量

在考虑数字顺序递增的前提下, 第 i 个数字大于前面 i - 1 个数字, 因此 f\[i][j] 可以由: f\[i - 1][j] (将第 i 个数字放在之前序列的最后一位, 不会产生任何逆序), f\[i - 1][j - 1] (将第 i 个数字插在之前每个序列倒数第二位, 额外产生一个逆序), f\[i - 1][j - 2] ... f\[i - 1][j - (i - 1)] (将第 i 个数字放在之前各个序列的开头将产生 i - 1 个逆序对)

从而有: $f[i][j] = \sum_{x = 0}^{i - 1}f[i - 1][j - x]$, 即上一行的 i 个状态的和, 从最暴力的角度出发, 枚举 x, 则整体时间复杂度达到了: $O(n^2\times k)$ 本题中 n 和 k 都可以取到 $10^3$, 会超时

第 i 行的每个 j 的状态取决于上一行的 i 的个状态的和, 因此可以参考之前多重背包的优化思路, 本题不要求从 i 个状态之间取一个最大值, 而是要求 i 的状态的和, 因此不需要单调队列优化, 这里使用一个变量 sum 表示 i 个状态的和即可

```java
class Solution {
    private static final int MOD = (int)1e9 + 7;
    public int kInversePairs(int n, int k) {
        int[][] f = new int[n + 1][k + 1];
        for (int i = 1; i <= n; i++) {
            // 一个序列没有逆序对的情况只有一种, 就是正序
            f[i][0] = 1;
            // sum 统计了上一行大小为 i 的窗口内的状态和
            int sum = f[i - 1][0];
            for (int j = 1; j <= k; j++) {
                // 看成是入队操作
                sum += f[i - 1][j];
                sum %= MOD;
                f[i][j] = sum;
                // 看成是出队操作
                if (j - (i - 1) >= 0) {
                    sum = sum + MOD - f[i - 1][j - (i - 1)];
                    sum %= MOD;
                }
            }
        }
        return f[n][k];
    }
}
```





