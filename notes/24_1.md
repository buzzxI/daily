# 1.2

## [466. 统计重复个数](https://leetcode.cn/problems/count-the-repetitions/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/problems/count-the-repetitions/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/02/20:17:13:466.png" />
	</a>
</div>



题解提到了循环节的概念, 实际进行匹配的循环节可能不是以 s2 的开头开始的, 因此实际匹配的时候, 可能以有如下结构: prefix + loop + suffix

其中 loop 为 s2 的循环节, prefix 为 s2 的某个 prefix, suffix 为不能构成循环节的部分, 具体的可以看题解

由于循环节的编码需要使用 map 映射 index 和一个 array, 比较复杂, 这里使用两种相对比较简单的方式

### 暴力

n1 为 $10^6$ 级别, s1 为 $10^2$ 级别, 因此两重循环的开销: $10^8$ 其实是可以接受的 (也算是擦边了)

简单来说就是遍历整个 S1 (没错就是由 n1 和 s1 拼接得到的 S1), 同时维护一个 s2 上的指针即可, 暴力循环

```java
class Solution {
    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {
        int len1 = s1.length();
        int len2 = s2.length();
        if (len1 * n1 < len2 * n2) return 0;
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();

        int rst = 0;
        int k = 0;
        for (int i = 0; i < n1; i++) {
            for (int j = 0; j < len1; j++) {
                if (c1[j] == c2[k]) {
                    k = (k + 1) % len2;
                    if (k == 0) rst++;
                }
            }
        }
        return rst / n2;
    }
}
```

> 真正意义上的擦边, 2.8s ...

其实是可以优化的, 定义 f[i] 表示前 i 个 s1, 可以构成的完整的 s2 的个数, 在执行上述循环的时候, 在完成内层循环后, 如果指针 k 恰好指向了 s2 的开头, 则跳出循环 (某种意义上的剪枝吧, 这里对应了在某些输入的情况下, 循环节的开头恰好是 s2 的开头的情况)

### dp?

定义 f[i] 表示从 s2 的第 i 个字符开始可以匹配一个 s1 中字符的个数, 显然 dp 数组的构建时间复杂度为: $O(s1 \times s2)$, 由于在本题中 s1 和 s2 均为 $10^2$ 级别, 因此构建 f 数组的时间复杂度为: $10^4$

然后遍历整个 n1, 同时一个指向了 s2 的指针, 查找每个 n1 可以搜索 s2 中字符的个数

```java

```java
class Solution {
    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {
        int len1 = s1.length();
        int len2 = s2.length();
        if (len1 * n1 < len2 * n2) return 0;
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();

        int[] f = new int[len2];
        for (int i = 0; i < len2; i++) {
            int k = i;
            for (int j = 0; j < len1; j++) {
                if (c1[j] == c2[k]) {
                    f[i]++;
                    k = (k + 1) % len2;
                }
            }    
        }

        int len = 0;
        int idx = 0;
        for (int i = 0; i < n1; i++) {
            len += f[idx];
            // 在当前 s1 可以匹配 f[idx] 个字符的情况下, 下一个 s1 需要从 idx + f[idx] 开始匹配
            idx = (idx + f[idx]) % len2;
        }

        return len / len2 / n2;
    }
}
```

# 1.4

## [2397. 被列覆盖的最多行数](https://leetcode.cn/problems/maximum-rows-covered-by-columns/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/04/20:00:54:2397.png" />
	</a>
</div>

从 m 列中选择 numSelect 列, 标记这几列中的 1, 求解可以覆盖的行的个数, 最开始的想法就是暴力枚举, 枚举 n 元集合的 m 元子集, 具体的, 这里使用了 Gosper's Hack algorithm, 可以在 $O(1)$ 的时间内完成子集的枚举

```cpp
void gosper_hack(int k, int n) {
    int cur = (k << 1) - 1;
    int lim = 1 << n;
    while (cur < lim) {
        // current permutation
        // printf("%d\n", cur);
        
        // next permutation
        int lowbit = cur & (-cur);
        int r = cur + lowbit;
        cur = r | (((r ^ cur) >> 2) / lowbit);
    }
}
```

由于矩阵中仅仅包含了 0 和 1, 因此可以通过 bit mask 表示每一行, 而枚举的各个子集本身也是 mask, 如果当前枚举的子集 cur 可以完整覆盖本行的 mask(mask & cur = mask), 则表示本行可以被当前枚举的子集覆盖

```java
class Solution {
    public int maximumRows(int[][] matrix, int numSelect) {
        int n = matrix.length;
        int m = matrix[0].length;
        int[] masks = new int[n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == 1) masks[i] |= (1 << j);
            }
        }
        
        int cur = (1 << numSelect) - 1;
        int lim = 1 << m;
        int rst = 0;
        while (cur < lim) {
            int tmp = 0;
            for (int i = 0; i < n; i++) {
                if ((masks[i] & cur) == masks[i]) tmp++;
            }
            
            rst = Math.max(rst, tmp);
            int lowbit = cur & (-cur);
            int r = cur + lowbit;
            cur = r | (((r ^ cur) >> 2) / lowbit);
        }
        return rst;
    }
}
```

## [2870. Minimum Number of Operations to Make Array Empty](https://leetcode.com/problems/minimum-number-of-operations-to-make-array-empty/)

<div style="text-align:center;">
	<a href="https://leetcode.com/problems/minimum-number-of-operations-to-make-array-empty/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/04/20:40:16:2870.png" />
	</a>
</div>

每次删除的顺序并没有限制, 只要数组中存在多个相同的元素就可以执行删除, 因此这里直接统计每个数字出现的频率即可

特别的, 为了保证删除的次数最少, 应该尽可能的一次性去除三个数字, 但要注意, 不能无脑先三个三个的去除, 首先应该保证的是按照该顺序去除后, 不会剩余元素

这里首先枚举一下简单的情况:

*   首先考虑只出现了一次的元素, 此时没有任何方法清空, 直接返回 -1;
*   对于出现频率为 2 的元素, 直接成对去除即可
*   对于出现频率为 3 的元素, 类似的直接去除即可
*   对于出现频率为 4 的元素, 唯一的清空方式就是两个两个的清除
*   对于出现频率为 5 的元素, 唯一的清空方式是先清除 3 个再清除 2 个

...

继续向后遍历, 会发现规律, 对于各种频率, 只有三种处理方式: 

*   一次性按照 3 个元素的方式去除
*   先按照 3 个元素的方式去除, 最后仅剩 2 个元素
*   先按照 3 个元素的方式去除, 最后仅剩 4 个元素

如果将只出现一次的情况特殊处理 (直接返回 -1), 那么可以看到这里的三种情况, 恰好对应了模 3 的各个余数

```java
class Solution {
    public int minOperations(int[] nums) {
        Map<Integer, Integer> b = new HashMap<>();
        for (int num : nums) b.put(num, b.getOrDefault(num, 0) + 1);
        int rst = 0;
        for (int k : b.keySet()) {
            int v = b.get(k);
            if (v == 1) return -1;
            // i like switch expression
            rst += switch (v % 3) {
                case 0 -> v / 3;
                case 1 -> (v - 4) / 3 + 2;
                case 2 -> (v - 2) / 3 + 1;
                default -> 0;
            };
        }
        return rst;
    }
}
```

# 1.5

## [1944. 队列中可以看到的人数](https://leetcode.cn/classic/problems/number-of-visible-people-in-a-queue/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/number-of-visible-people-in-a-queue/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/05/10:10:50:1944.png" />
	</a>
</div>

对于任何一个位置的人, 其能看到所有人按照从左向右的顺序排序, 一定是升序的, 并且其看不到的人可以分为两类, 一类排在当前位置可以看到的两个人中间, 一类排在当前位置可以看到的最后一个人的后面; 但不管怎么分类, 这两类人都比所有能看到的人要矮

>   本题特意强调了每个整数都互不相同

从后向前遍历数组, 同时使用一个单调递减的单调栈维护每个位置的高度, 特别的, 当前遍历位置 i 的高度比栈顶更小时, 表示此时当前位置只能看到后一位 (i + 1) 的人; 当前遍历位置 i 的高度比栈顶更大时, 此时需要让单调栈弹栈, 每个弹栈的元素都对应了一个可以从当前位置看到的人

```java
class Solution {
    private static final int N = (int)1e5 + 10;
    private static int[] stk = new int[N];
    public int[] canSeePersonsCount(int[] h) {
        int n = h.length;
        int[] rst = new int[n];
        int sp = 0;
        for (int i = n - 1; i >= 0; i--) {
            while (sp > 0 && h[stk[sp - 1]] < h[i]) {
                sp--;
                rst[i]++;
            }
            if (sp > 0) rst[i]++;
            stk[sp++] = i;
        }
        return rst;
    }
}
```

# 1.6

## [1235. Maximum Profit in Job Scheduling](https://leetcode.com/problems/maximum-profit-in-job-scheduling/)


<div style="text-align:center;">
	<a href="https://leetcode.com/problems/maximum-profit-in-job-scheduling/" >
		<img src = "https://cdn.jsdelivr.net/gh/SunYuanI/img/img/1235.png" />
	</a>
</div>

输入范围 $5 \times 10^4$, 显然两层循环肯定是不行的, 必须想办法将复杂度优化到: $O(n\log n)$

本题还是一样的, 可以通过 dp 或者记忆化搜索两种方式解决

### 记忆化搜索

定义状态 f[i] 表示所有从 i 开始的选举方案中, 收益的最大值, 要注意从 i 开始并不意味着必须选择第 i 项工作, 显然最终直接返回 dfs(0) 即可

对于第 i 项工作有选和不选两种方式:

*   如果不选, 那么当前收益的最大值为: f[i + 1]
*   如果选的话, 那么当前收益的最大值为: $profit[i] + max_{begin[j] >= end[i]}(f[j + 1])$, 即从所有开始时间大于当前工作结束时间的工作中选择一个执行, 此时暴力枚举的时间复杂度为: $O(n)$, 直接超时

因此这里枚举的时候进行优化, 将所有的工作按照开始时间进行排序, 这样在枚举到第 i 项工作的时候, 可以使用二分在 $O(\log n)$ 的时间内找到下一个不重叠的 j

```java
class Solution {
    private int[][] b;
    private int[] f;
    public int jobScheduling(int[] s, int[] e, int[] p) {
        int n = s.length;
        this.b = new int[n][3];
        this.f = new int[n];
        Arrays.fill(f, -1);
        for (int i = 0; i < n; i++) {
            b[i][0] = s[i];
            b[i][1] = e[i];
            b[i][2] = p[i];
        }
        Arrays.sort(b, (b1, b2) -> b1[0] - b2[0]);
        return dfs(0);
    }
    
    private int dfs(int idx) {
        // 记忆化搜索
        if (f[idx] != -1) return f[idx];
        if (idx == f.length - 1) {
            f[idx] = b[idx][2];
            return f[idx];
        }
        // 不选
        int jump = dfs(idx + 1);
        // 选择当前工作
        int non_jump = b[idx][2];
        int l = idx + 1;
        int r = f.length - 1;
        while (l < r) {
            int m = l + ((r - l) >> 1);
            if (b[m][0] < b[idx][1]) l = m + 1;
            else r = m;
        }
        if (b[l][0] >= b[idx][1]) non_jump += dfs(l);
        
        f[idx] = Math.max(jump, non_jump);
        return f[idx];
    }
}
```

### dp

搜索相关的都可以按照自顶向下和自底向上分为记忆化搜索和 dp, 本题也一样, 定义状态 f[i] 表示前 i 项工作的最大值, 显然返回值为: f[n - 1] (下标从 0 开始的话)

同样的对于第 i 项工作有选和不选两种操作:

*   如果不选的则有: f[i] = f[i - 1] (i > 0)
*   如果选, 有: $f[i] = profix[i] + max_{end[j] <= begin[i]}(f[j])$, 类似的, 要从所有结束时间比当前工作开始时间早的工作中选择一个, 同样为了优化搜索, 这里根据结束时间排序, 而使用二分加速搜索

```java
class Solution {
    public int jobScheduling(int[] s, int[] e, int[] p) {
        int n = s.length;
        int[][] b = new int[n][3];
        int[] f = new int[n];
        for (int i = 0; i < n; i++) {
            b[i][0] = s[i];
            b[i][1] = e[i];
            b[i][2] = p[i];
        }
        Arrays.sort(b, (b1, b2) -> b1[1] - b2[1]);
        // 第 1 项工作没有前置工作
        f[0] = b[0][2];
        for (int i = 1; i < n; i++) {
			// 不选
            f[i] = f[i - 1];
            int l = 0;
            int r = i - 1;
            while (l < r) {
                int m = l + ((r - l + 1) >> 1);
                if (b[m][1] > b[i][0]) r = m - 1;
                else l = m;
            }
            // 选
            if (b[r][1] <= b[i][0]) f[i] = Math.max(f[i], f[r] + b[i][2]);
            // 这里注意可能没有合适的前置, 此时还有一种方案就是不要前置了
            else f[i] = Math.max(f[i], b[i][2]);
        }
        return f[n - 1];
    }
}
```

# 1.9

## [2707. 字符串中的额外字符](https://leetcode.cn/classic/problems/extra-characters-in-a-string/description/)

<div style="text-align:center;">
	<a href="https://leetcode.cn/classic/problems/extra-characters-in-a-string/description/" >
		<img src = "https://cdn.jsdelivr.net/gh/buzzxI/img@latest/img/24/01/09/21:11:32:2707.png" />
	</a>
</div>
由于是子字符串, 因此必须是连续的, 定义 f[i] 表示前 i 个字符中没有使用的字符的最少的个数

显然, 进行状态转移时, 当前字符可以直接不进行处理, 有: f[i] = f[i - 1] + 1

而如果要处理当前字符时, 需要找到前置字符位置 j, 使得 j...i 作为 s 的子字符串, 出现在 dictionary 中, 则有: f[i] = f[j - 1]

>   注意到这里是子字符串, 因此在考虑选取第 i 个字符时, 必须找到以第 i 个字符作为结尾的字符串
>
>   而如果是子序列, 则应该从 j 开始进行匹配, 这里就不需要考虑字符 i 是否作为结尾存在, 因为就算找到了一种不包含 i 的选取方式, 还是可以找到包含了 i 的替代方案

找子字符串的过程通过字典树进行优化

```java
class Solution {
    public int minExtraChar(String s, String[] dict) {
        int n = s.length();
        int[] f = new int[n];
        Trie root = new Trie();
        for (String w : dict) add(w, root);
        
        for (int i = 0; i < n; i++) {
            if (i > 0) f[i] = f[i - 1] + 1;
            else f[i] = 1;
            Trie node = root;
            for (int j = i; j >= 0; j--) {
                int idx = s.charAt(j) - 'a';
                if (node.children[idx] == null) break;
                node = node.children[idx];
                if (node.isEnd) {
                    if (j > 0) f[i] = Math.min(f[i], f[j - 1]);
                    else f[i] = 0;
                }
            }
        }
        return f[n - 1];
    }
    
    private void add(String s, Trie root) {
        Trie node = root;
        for (int i = s.length() - 1; i >= 0; i--) {
            int idx = s.charAt(i) - 'a';
            if (node.children[idx] == null) node.children[idx] = new Trie();
            node = node.children[idx];
        }
        node.isEnd = true;
    }
}

class Trie {
    Trie[] children;
    boolean isEnd;
    
    public Trie() {
        this.children = new Trie[26];
        this.isEnd = false;
    }
}
```









